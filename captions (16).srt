1
00:00:06,560 --> 00:00:11,360
so after proving

2
00:00:08,880 --> 00:00:13,840
the equivalence of context through

3
00:00:11,360 --> 00:00:19,119
grammar and pdas

4
00:00:13,840 --> 00:00:19,119
we can have a corollary here

5
00:00:19,840 --> 00:00:24,880
here that every regular language is

6
00:00:23,199 --> 00:00:26,400
context free

7
00:00:24,880 --> 00:00:27,439
okay

8
00:00:26,400 --> 00:00:31,279
why

9
00:00:27,439 --> 00:00:33,680
because remember that we define regular

10
00:00:31,279 --> 00:00:35,760
language as the language can be

11
00:00:33,680 --> 00:00:37,120
recognized by

12
00:00:35,760 --> 00:00:38,640
dfa

13
00:00:37,120 --> 00:00:40,800
then we

14
00:00:38,640 --> 00:00:42,239
prove that

15
00:00:40,800 --> 00:00:46,000
dfa and

16
00:00:42,239 --> 00:00:47,680
nfa are equivalent so that means

17
00:00:46,000 --> 00:00:50,879
every language

18
00:00:47,680 --> 00:00:52,800
can be recognized by nfa

19
00:00:50,879 --> 00:00:54,079
is a regular language

20
00:00:52,800 --> 00:00:55,520
right

21
00:00:54,079 --> 00:00:58,000
and then

22
00:00:55,520 --> 00:00:59,440
what is pda

23
00:00:58,000 --> 00:01:00,320
pda

24
00:00:59,440 --> 00:01:04,000
is

25
00:01:00,320 --> 00:01:04,000
basically an nfa

26
00:01:05,119 --> 00:01:08,240
with a stack

27
00:01:07,360 --> 00:01:09,040
okay

28
00:01:08,240 --> 00:01:12,640
so

29
00:01:09,040 --> 00:01:16,640
imagine that if you have a pda but you

30
00:01:12,640 --> 00:01:17,840
never use the capability of the stack

31
00:01:16,640 --> 00:01:21,439
then

32
00:01:17,840 --> 00:01:24,400
basically the stack of the pda becomes

33
00:01:21,439 --> 00:01:27,520
exactly an effect

34
00:01:24,400 --> 00:01:28,640
since pdas becomes exactly nfa that

35
00:01:27,520 --> 00:01:30,400
means

36
00:01:28,640 --> 00:01:33,520
all

37
00:01:30,400 --> 00:01:34,720
regular languages can be recognized by

38
00:01:33,520 --> 00:01:36,159
pda

39
00:01:34,720 --> 00:01:38,159
right

40
00:01:36,159 --> 00:01:43,439
and apparently

41
00:01:38,159 --> 00:01:44,320
we already have pda recognizing some

42
00:01:43,439 --> 00:01:46,960
sorry

43
00:01:44,320 --> 00:01:50,159
since all regular languages can be

44
00:01:46,960 --> 00:01:53,040
recognized by pda that means

45
00:01:50,159 --> 00:01:57,600
regular languages

46
00:01:53,040 --> 00:02:00,240
maybe exactly context-free languages or

47
00:01:57,600 --> 00:02:02,159
a part of context-free languages right

48
00:02:00,240 --> 00:02:05,119
that's the two possibilities

49
00:02:02,159 --> 00:02:08,959
for the conclusion here

50
00:02:05,119 --> 00:02:10,720
but we already have examples

51
00:02:08,959 --> 00:02:13,760
that

52
00:02:10,720 --> 00:02:13,760
the language here

53
00:02:16,720 --> 00:02:22,319
the language as the example to be

54
00:02:19,120 --> 00:02:26,480
non-regular here

55
00:02:22,319 --> 00:02:28,720
which we call b that previously right

56
00:02:26,480 --> 00:02:29,680
is not regular language

57
00:02:28,720 --> 00:02:31,760
but

58
00:02:29,680 --> 00:02:35,040
we can use

59
00:02:31,760 --> 00:02:37,040
pda to recognize it right

60
00:02:35,040 --> 00:02:40,800
so we know that

61
00:02:37,040 --> 00:02:42,959
regular languages is a proper subset of

62
00:02:40,800 --> 00:02:44,879
context free language

63
00:02:42,959 --> 00:02:47,040
and of course you can easily write

64
00:02:44,879 --> 00:02:50,480
grammar for this language

65
00:02:47,040 --> 00:02:52,000
you just need one variable right

66
00:02:50,480 --> 00:02:55,040
then

67
00:02:52,000 --> 00:02:56,560
this variable can become epsilon

68
00:02:55,040 --> 00:02:57,680
or

69
00:02:56,560 --> 00:02:58,879
zero

70
00:02:57,680 --> 00:03:00,640
s

71
00:02:58,879 --> 00:03:02,159
one

72
00:03:00,640 --> 00:03:03,200
right

73
00:03:02,159 --> 00:03:06,239
so

74
00:03:03,200 --> 00:03:06,239
since the language

75
00:03:06,640 --> 00:03:12,400
can be generated by context free grammar

76
00:03:10,720 --> 00:03:14,640
that language

77
00:03:12,400 --> 00:03:14,640
is

78
00:03:15,440 --> 00:03:18,400
context free

79
00:03:16,840 --> 00:03:21,040
language

80
00:03:18,400 --> 00:03:22,000
and it is not regular language so we

81
00:03:21,040 --> 00:03:24,080
know

82
00:03:22,000 --> 00:03:26,959
the relationship

83
00:03:24,080 --> 00:03:28,239
between regular language and context

84
00:03:26,959 --> 00:03:30,560
free language

85
00:03:28,239 --> 00:03:32,720
is like this

86
00:03:30,560 --> 00:03:34,480
now you can see that computational

87
00:03:32,720 --> 00:03:38,319
models of

88
00:03:34,480 --> 00:03:41,200
dfa nfa regular expression gnfa

89
00:03:38,319 --> 00:03:44,640
the four models are equivalent and they

90
00:03:41,200 --> 00:03:47,680
can handle regular languages

91
00:03:44,640 --> 00:03:51,760
and the later two models we introduced

92
00:03:47,680 --> 00:03:54,159
contextual grammar and pda

93
00:03:51,760 --> 00:03:55,120
they can handle context free languages

94
00:03:54,159 --> 00:03:57,519
and

95
00:03:55,120 --> 00:04:00,480
regular languages is a proper subset of

96
00:03:57,519 --> 00:04:03,920
context-free languages so apparently

97
00:04:00,480 --> 00:04:06,400
context free grammar and pda

98
00:04:03,920 --> 00:04:08,799
well in a sense

99
00:04:06,400 --> 00:04:11,200
is more powerful

100
00:04:08,799 --> 00:04:15,599
it's more powerful than

101
00:04:11,200 --> 00:04:17,280
dfa and lfa regular expression and gnfa

102
00:04:15,599 --> 00:04:21,280
okay

103
00:04:17,280 --> 00:04:22,960
then we go back to our

104
00:04:21,280 --> 00:04:25,520
idea that

105
00:04:22,960 --> 00:04:26,479
languages are problems

106
00:04:25,520 --> 00:04:28,960
so

107
00:04:26,479 --> 00:04:31,759
we want to have we want to discuss

108
00:04:28,960 --> 00:04:34,960
computational model computation

109
00:04:31,759 --> 00:04:37,199
uh the capability limit limitation of

110
00:04:34,960 --> 00:04:39,120
computation

111
00:04:37,199 --> 00:04:41,280
again if

112
00:04:39,120 --> 00:04:43,840
if

113
00:04:41,280 --> 00:04:44,720
if contest free languages

114
00:04:43,840 --> 00:04:47,280
are

115
00:04:44,720 --> 00:04:48,800
all possible languages

116
00:04:47,280 --> 00:04:50,560
just if okay

117
00:04:48,800 --> 00:04:52,160
if context-free languages are all

118
00:04:50,560 --> 00:04:53,120
possible languages

119
00:04:52,160 --> 00:04:56,160
then

120
00:04:53,120 --> 00:04:58,080
everything's fine and the pda

121
00:04:56,160 --> 00:05:01,600
or contextual grammar

122
00:04:58,080 --> 00:05:04,160
are universally powerful then

123
00:05:01,600 --> 00:05:06,320
we have no problem at all

124
00:05:04,160 --> 00:05:06,320
so

125
00:05:06,960 --> 00:05:10,400
is there any

126
00:05:08,840 --> 00:05:13,280
language

127
00:05:10,400 --> 00:05:13,280
outside of

128
00:05:13,600 --> 00:05:19,919
context-free languages

129
00:05:16,320 --> 00:05:19,919
that's the question okay

130
00:05:20,960 --> 00:05:26,080
so consider the language

131
00:05:23,120 --> 00:05:27,759
let's say also called b

132
00:05:26,080 --> 00:05:29,120
we have

133
00:05:27,759 --> 00:05:33,440
n a's

134
00:05:29,120 --> 00:05:35,199
and b's and c's and n

135
00:05:33,440 --> 00:05:37,440
is

136
00:05:35,199 --> 00:05:39,120
greater than

137
00:05:37,440 --> 00:05:40,080
or equal to zero

138
00:05:39,120 --> 00:05:42,800
okay

139
00:05:40,080 --> 00:05:44,880
so you you can easily imagine what kinds

140
00:05:42,800 --> 00:05:46,000
of strings are in the language that

141
00:05:44,880 --> 00:05:49,280
would be

142
00:05:46,000 --> 00:05:52,400
epsilon which n is zero right

143
00:05:49,280 --> 00:05:53,680
a b c a a b b

144
00:05:52,400 --> 00:05:59,759
c c

145
00:05:53,680 --> 00:06:01,680
a a a b b b c c c etcetera right that's

146
00:05:59,759 --> 00:06:05,199
pretty straightforward

147
00:06:01,680 --> 00:06:07,520
and let's think about how to uh

148
00:06:05,199 --> 00:06:10,960
write a grammar for a language or how to

149
00:06:07,520 --> 00:06:14,319
design a pdf or language okay

150
00:06:10,960 --> 00:06:17,759
and pdf probably easier to think right

151
00:06:14,319 --> 00:06:19,120
so you think of okay i can use

152
00:06:17,759 --> 00:06:21,840
a stack

153
00:06:19,120 --> 00:06:21,840
to push

154
00:06:22,080 --> 00:06:26,560
a

155
00:06:23,440 --> 00:06:28,240
and then mesh with b and we all know a

156
00:06:26,560 --> 00:06:29,680
and b

157
00:06:28,240 --> 00:06:31,199
are of the same

158
00:06:29,680 --> 00:06:33,840
length or not

159
00:06:31,199 --> 00:06:35,759
but the problem is that you own you

160
00:06:33,840 --> 00:06:38,319
always can only

161
00:06:35,759 --> 00:06:41,039
basically can use stack to check the

162
00:06:38,319 --> 00:06:42,960
first two symbols you won't be able to

163
00:06:41,039 --> 00:06:44,479
check if

164
00:06:42,960 --> 00:06:45,280
c

165
00:06:44,479 --> 00:06:48,880
is

166
00:06:45,280 --> 00:06:50,960
of the same length of b or a

167
00:06:48,880 --> 00:06:53,280
because everything in your stack has

168
00:06:50,960 --> 00:06:56,160
been popped out for checking and there

169
00:06:53,280 --> 00:06:57,759
is nothing remember

170
00:06:56,160 --> 00:07:00,840
how many

171
00:06:57,759 --> 00:07:02,720
symbols you have processed

172
00:07:00,840 --> 00:07:04,639
okay so

173
00:07:02,720 --> 00:07:08,240
the idea is that

174
00:07:04,639 --> 00:07:11,840
okay maybe we cannot design a pda

175
00:07:08,240 --> 00:07:15,360
and of course we will be unable to write

176
00:07:11,840 --> 00:07:17,680
a grammar for this language

177
00:07:15,360 --> 00:07:18,560
what is language

178
00:07:17,680 --> 00:07:20,000
but

179
00:07:18,560 --> 00:07:22,000
such an idea

180
00:07:20,000 --> 00:07:24,240
well cannot be

181
00:07:22,000 --> 00:07:25,759
cannot be considered as proof in

182
00:07:24,240 --> 00:07:28,400
mathematics because

183
00:07:25,759 --> 00:07:30,560
just because we are unable to do it it

184
00:07:28,400 --> 00:07:32,880
doesn't mean that other

185
00:07:30,560 --> 00:07:35,440
people cannot do it right so we need

186
00:07:32,880 --> 00:07:35,440
something

187
00:07:35,599 --> 00:07:42,880
more convincing and actually absolutely

188
00:07:39,280 --> 00:07:44,960
convincing so that's

189
00:07:42,880 --> 00:07:46,400
it it can be

190
00:07:44,960 --> 00:07:48,879
considered as

191
00:07:46,400 --> 00:07:50,479
as a proof

192
00:07:48,879 --> 00:07:54,720
so

193
00:07:50,479 --> 00:07:56,240
here like in regular languages we

194
00:07:54,720 --> 00:07:59,280
are introducing

195
00:07:56,240 --> 00:08:00,639
pumping lemma for

196
00:07:59,280 --> 00:08:01,840
context-free

197
00:08:00,639 --> 00:08:04,080
languages

198
00:08:01,840 --> 00:08:06,240
okay context-free languages

199
00:08:04,080 --> 00:08:08,560
since we are already familiar with

200
00:08:06,240 --> 00:08:10,800
paminema for regular languages so we

201
00:08:08,560 --> 00:08:10,800
just

202
00:08:10,879 --> 00:08:16,080
described

203
00:08:12,400 --> 00:08:17,759
this dilemma for context free language

204
00:08:16,080 --> 00:08:19,520
if uh

205
00:08:17,759 --> 00:08:22,000
if a

206
00:08:19,520 --> 00:08:24,160
is a context free language

207
00:08:22,000 --> 00:08:27,280
then there is a p

208
00:08:24,160 --> 00:08:28,639
which is called the pumping length

209
00:08:27,280 --> 00:08:29,919
where

210
00:08:28,639 --> 00:08:32,719
for

211
00:08:29,919 --> 00:08:35,039
any string in a

212
00:08:32,719 --> 00:08:38,080
of length at least p

213
00:08:35,039 --> 00:08:40,800
okay at least pumping lemma see until

214
00:08:38,080 --> 00:08:43,440
this part is exactly the same as company

215
00:08:40,800 --> 00:08:47,200
for regular languages okay

216
00:08:43,440 --> 00:08:48,480
then s may be divided okay same thing

217
00:08:47,200 --> 00:08:50,240
maybe

218
00:08:48,480 --> 00:08:53,200
divided into

219
00:08:50,240 --> 00:08:56,959
five pieces okay in regular language

220
00:08:53,200 --> 00:09:00,480
it's three right so now it's five phases

221
00:08:56,959 --> 00:09:04,320
let's say u v x y z

222
00:09:00,480 --> 00:09:04,320
satisfying the three conditions

223
00:09:04,720 --> 00:09:10,080
let's also look at the

224
00:09:08,320 --> 00:09:12,160
last two

225
00:09:10,080 --> 00:09:14,880
so

226
00:09:12,160 --> 00:09:16,240
the second condition is that

227
00:09:14,880 --> 00:09:19,760
the

228
00:09:16,240 --> 00:09:20,959
second and the fourth pieces

229
00:09:19,760 --> 00:09:25,200
cannot

230
00:09:20,959 --> 00:09:26,000
cannot be both empty that's why we write

231
00:09:25,200 --> 00:09:28,560
u

232
00:09:26,000 --> 00:09:30,880
y the length of u y

233
00:09:28,560 --> 00:09:33,920
larger than zero that means

234
00:09:30,880 --> 00:09:34,720
u and the y cannot

235
00:09:33,920 --> 00:09:39,120
be

236
00:09:34,720 --> 00:09:39,120
empty string at the same time

237
00:09:39,200 --> 00:09:43,519
they can be they can both be none empty

238
00:09:42,320 --> 00:09:45,839
that's okay

239
00:09:43,519 --> 00:09:46,880
and you can have u

240
00:09:45,839 --> 00:09:47,839
sorry v

241
00:09:46,880 --> 00:09:50,720
you can

242
00:09:47,839 --> 00:09:51,920
not u y v y okay

243
00:09:50,720 --> 00:09:52,640
you can have

244
00:09:51,920 --> 00:09:53,519
v

245
00:09:52,640 --> 00:09:57,279
empty

246
00:09:53,519 --> 00:10:00,320
and y non-empty or you can have v non

247
00:09:57,279 --> 00:10:02,320
empty and y empty that's okay they just

248
00:10:00,320 --> 00:10:06,000
cannot be

249
00:10:02,320 --> 00:10:07,839
empty at the same time so we write

250
00:10:06,000 --> 00:10:09,040
the condition like this

251
00:10:07,839 --> 00:10:11,760
okay

252
00:10:09,040 --> 00:10:13,680
and the middle three

253
00:10:11,760 --> 00:10:17,600
pieces

254
00:10:13,680 --> 00:10:20,320
v x y which is in the middle

255
00:10:17,600 --> 00:10:23,519
the length of v x y

256
00:10:20,320 --> 00:10:25,920
is less than or equal to

257
00:10:23,519 --> 00:10:26,720
the pumping length

258
00:10:25,920 --> 00:10:30,000
okay

259
00:10:26,720 --> 00:10:30,000
so it's very much like

260
00:10:30,480 --> 00:10:34,640
x y

261
00:10:32,399 --> 00:10:37,360
less than or equal to p in the regular

262
00:10:34,640 --> 00:10:38,640
language okay then the second one

263
00:10:37,360 --> 00:10:41,120
is like

264
00:10:38,640 --> 00:10:44,000
uh sorry

265
00:10:41,120 --> 00:10:45,760
the regular language okay so for pumping

266
00:10:44,000 --> 00:10:46,800
number five

267
00:10:45,760 --> 00:10:49,680
pieces

268
00:10:46,800 --> 00:10:52,800
and the second fourth pieces cannot both

269
00:10:49,680 --> 00:10:55,680
be empty string and

270
00:10:52,800 --> 00:10:58,720
the middle three pieces together their

271
00:10:55,680 --> 00:11:00,399
length is smaller than or equal to the

272
00:10:58,720 --> 00:11:03,440
pumping length

273
00:11:00,399 --> 00:11:07,040
okay given this the first

274
00:11:03,440 --> 00:11:10,160
condition is the pumping condition that

275
00:11:07,040 --> 00:11:11,440
the second and the fourth part

276
00:11:10,160 --> 00:11:12,959
of the string

277
00:11:11,440 --> 00:11:14,480
can be removed

278
00:11:12,959 --> 00:11:15,360
which is

279
00:11:14,480 --> 00:11:16,800
i

280
00:11:15,360 --> 00:11:20,720
zero

281
00:11:16,800 --> 00:11:22,880
or you can re you can repeat them

282
00:11:20,720 --> 00:11:25,440
indefinite times

283
00:11:22,880 --> 00:11:26,839
for example

284
00:11:25,440 --> 00:11:31,519
u v

285
00:11:26,839 --> 00:11:34,560
b x y y z

286
00:11:31,519 --> 00:11:36,320
must be in the language 2

287
00:11:34,560 --> 00:11:40,480
and the u v

288
00:11:36,320 --> 00:11:43,519
v v x y y y z

289
00:11:40,480 --> 00:11:44,560
must also be in that language

290
00:11:43,519 --> 00:11:46,079
so

291
00:11:44,560 --> 00:11:48,160
u

292
00:11:46,079 --> 00:11:49,040
4 time v

293
00:11:48,160 --> 00:11:49,839
sorry

294
00:11:49,040 --> 00:11:52,720
x

295
00:11:49,839 --> 00:11:52,720
for z

296
00:11:53,920 --> 00:11:57,920
must be in the language too

297
00:11:56,240 --> 00:12:01,839
so etc

298
00:11:57,920 --> 00:12:04,639
so in depth for each i

299
00:12:01,839 --> 00:12:07,839
equal to or greater than zero

300
00:12:04,639 --> 00:12:12,880
the resultant string like this

301
00:12:07,839 --> 00:12:14,160
which you pump the second and the fourth

302
00:12:12,880 --> 00:12:16,079
pieces

303
00:12:14,160 --> 00:12:17,600
the resultant string

304
00:12:16,079 --> 00:12:19,680
will always be

305
00:12:17,600 --> 00:12:22,880
in that language

306
00:12:19,680 --> 00:12:25,680
okay so that that is the pumping number

307
00:12:22,880 --> 00:12:27,440
for context-free languages

308
00:12:25,680 --> 00:12:29,920
okay that is the pumping name of account

309
00:12:27,440 --> 00:12:33,279
speed languages

310
00:12:29,920 --> 00:12:35,440
okay so let's see why we have such a

311
00:12:33,279 --> 00:12:37,120
property for you know context-free

312
00:12:35,440 --> 00:12:39,440
language

313
00:12:37,120 --> 00:12:42,240
it's pretty simple

314
00:12:39,440 --> 00:12:44,880
uh if you can if you consider the same

315
00:12:42,240 --> 00:12:46,639
thing for regular languages

316
00:12:44,880 --> 00:12:50,839
if you remember that

317
00:12:46,639 --> 00:12:53,760
uh why lego languages have such property

318
00:12:50,839 --> 00:12:54,800
because when the regular language

319
00:12:53,760 --> 00:12:56,000
can

320
00:12:54,800 --> 00:12:56,959
let's say

321
00:12:56,000 --> 00:12:59,680
since it

322
00:12:56,959 --> 00:13:00,880
since some language is regular means

323
00:12:59,680 --> 00:13:03,680
that

324
00:13:00,880 --> 00:13:05,120
there is a dfa recognized in the

325
00:13:03,680 --> 00:13:08,639
language

326
00:13:05,120 --> 00:13:10,720
and as long as that dfa can process

327
00:13:08,639 --> 00:13:14,079
some very long

328
00:13:10,720 --> 00:13:16,160
longer than the number of it states

329
00:13:14,079 --> 00:13:20,920
a string

330
00:13:16,160 --> 00:13:20,920
then while processing that string

331
00:13:21,040 --> 00:13:26,720
the dfa must step on

332
00:13:24,240 --> 00:13:27,680
duplicated

333
00:13:26,720 --> 00:13:29,040
states

334
00:13:27,680 --> 00:13:31,360
right

335
00:13:29,040 --> 00:13:33,360
may go back to some states it has

336
00:13:31,360 --> 00:13:37,600
stepped on before

337
00:13:33,360 --> 00:13:37,600
so by using this property we know that

338
00:13:39,680 --> 00:13:45,600
the repeating part can be repeated

339
00:13:42,639 --> 00:13:46,560
indefinite times

340
00:13:45,600 --> 00:13:50,399
right

341
00:13:46,560 --> 00:13:54,880
and the same thing goes to here

342
00:13:50,399 --> 00:13:54,880
because when a string is long enough

343
00:13:55,120 --> 00:14:01,440
remember that we in context free grammar

344
00:13:58,320 --> 00:14:04,000
we derive the string from start variable

345
00:14:01,440 --> 00:14:06,720
right and you derive something then

346
00:14:04,000 --> 00:14:09,040
derive something and derive something

347
00:14:06,720 --> 00:14:12,160
and derive something right

348
00:14:09,040 --> 00:14:15,279
and according to the length of the final

349
00:14:12,160 --> 00:14:18,000
string the terminal string

350
00:14:15,279 --> 00:14:20,480
if the lens is very

351
00:14:18,000 --> 00:14:22,480
or not not not very long it's long

352
00:14:20,480 --> 00:14:25,279
enough long enough

353
00:14:22,480 --> 00:14:26,560
then the steps here

354
00:14:25,279 --> 00:14:28,880
will be

355
00:14:26,560 --> 00:14:29,680
more than some steps

356
00:14:28,880 --> 00:14:31,600
and

357
00:14:29,680 --> 00:14:34,880
you must

358
00:14:31,600 --> 00:14:37,519
use the same variable somewhere because

359
00:14:34,880 --> 00:14:38,959
you have a finite set of variables

360
00:14:37,519 --> 00:14:39,920
okay

361
00:14:38,959 --> 00:14:42,560
so

362
00:14:39,920 --> 00:14:45,279
when you use the when you use the

363
00:14:42,560 --> 00:14:48,480
duplicate variable you when you use the

364
00:14:45,279 --> 00:14:48,480
same variable again

365
00:14:48,560 --> 00:14:52,800
at that time

366
00:14:50,320 --> 00:14:54,800
as i explained why the language is

367
00:14:52,800 --> 00:14:56,560
called context 3

368
00:14:54,800 --> 00:14:59,040
that means you don't

369
00:14:56,560 --> 00:15:01,680
you don't need to

370
00:14:59,040 --> 00:15:03,279
you don't need to apply some specific

371
00:15:01,680 --> 00:15:04,160
rules you can

372
00:15:03,279 --> 00:15:05,199
apply

373
00:15:04,160 --> 00:15:06,800
either

374
00:15:05,199 --> 00:15:08,320
one which is

375
00:15:06,800 --> 00:15:11,040
valid right

376
00:15:08,320 --> 00:15:14,240
so when you use the same variable for

377
00:15:11,040 --> 00:15:16,560
example a here a here

378
00:15:14,240 --> 00:15:18,880
you don't need to apply the same rule

379
00:15:16,560 --> 00:15:22,959
here you can apply

380
00:15:18,880 --> 00:15:27,360
you can apply the rule at this time

381
00:15:22,959 --> 00:15:29,920
with this a or vice versa

382
00:15:27,360 --> 00:15:31,839
so it creates

383
00:15:29,920 --> 00:15:34,639
the property

384
00:15:31,839 --> 00:15:36,800
described by the pumping lemma

385
00:15:34,639 --> 00:15:39,120
so let's say

386
00:15:36,800 --> 00:15:41,839
let g be a context-free grammar for

387
00:15:39,120 --> 00:15:44,560
language for country language a

388
00:15:41,839 --> 00:15:45,759
let's look at

389
00:15:44,560 --> 00:15:48,079
the rules

390
00:15:45,759 --> 00:15:51,519
let b

391
00:15:48,079 --> 00:15:54,240
be the maximum number of symbols

392
00:15:51,519 --> 00:15:57,360
in the right hand side of the rule okay

393
00:15:54,240 --> 00:15:58,880
what is that that means if you have rule

394
00:15:57,360 --> 00:16:01,040
like this

395
00:15:58,880 --> 00:16:03,360
and like this

396
00:16:01,040 --> 00:16:04,320
and like

397
00:16:03,360 --> 00:16:06,720
this

398
00:16:04,320 --> 00:16:10,000
and you choose

399
00:16:06,720 --> 00:16:11,519
the maximum length of the rule okay do

400
00:16:10,000 --> 00:16:12,880
you check which is

401
00:16:11,519 --> 00:16:15,519
not maximum

402
00:16:12,880 --> 00:16:17,199
you set it as b

403
00:16:15,519 --> 00:16:19,839
then

404
00:16:17,199 --> 00:16:20,839
that's derived you set it as b and

405
00:16:19,839 --> 00:16:22,399
that's the

406
00:16:20,839 --> 00:16:23,440
right

407
00:16:22,399 --> 00:16:25,519
and

408
00:16:23,440 --> 00:16:26,800
impossible

409
00:16:25,519 --> 00:16:30,240
upper bounds

410
00:16:26,800 --> 00:16:32,880
a ridiculous upper bound okay

411
00:16:30,240 --> 00:16:35,600
it is impossible to reach but let's say

412
00:16:32,880 --> 00:16:37,920
it is upper bound what is uh what what

413
00:16:35,600 --> 00:16:39,920
upper bound let's say from the start

414
00:16:37,920 --> 00:16:42,560
variable

415
00:16:39,920 --> 00:16:46,240
there are at most

416
00:16:42,560 --> 00:16:48,800
b leaves for one step

417
00:16:46,240 --> 00:16:52,000
right at most

418
00:16:48,800 --> 00:16:54,720
it it is impossible but

419
00:16:52,000 --> 00:16:56,720
that's it it's an upper bound

420
00:16:54,720 --> 00:16:57,680
and at the most

421
00:16:56,720 --> 00:16:58,800
b

422
00:16:57,680 --> 00:17:01,519
square

423
00:16:58,800 --> 00:17:05,839
leaves four second steps

424
00:17:01,519 --> 00:17:07,120
and of course at most b to the

425
00:17:05,839 --> 00:17:09,839
h

426
00:17:07,120 --> 00:17:10,799
power leaves for edge

427
00:17:09,839 --> 00:17:13,039
steps

428
00:17:10,799 --> 00:17:13,039
right

429
00:17:13,760 --> 00:17:16,559
then

430
00:17:14,640 --> 00:17:19,360
consider that

431
00:17:16,559 --> 00:17:21,280
if the grammar can generate a string at

432
00:17:19,360 --> 00:17:23,839
least

433
00:17:21,280 --> 00:17:23,839
this long

434
00:17:26,480 --> 00:17:29,200
then

435
00:17:27,439 --> 00:17:31,280
the pass three

436
00:17:29,200 --> 00:17:34,000
for this string

437
00:17:31,280 --> 00:17:36,320
must be at least

438
00:17:34,000 --> 00:17:38,799
h plus one high

439
00:17:36,320 --> 00:17:42,080
right you need so many so many steps you

440
00:17:38,799 --> 00:17:44,240
cannot generate that long string with

441
00:17:42,080 --> 00:17:45,840
fewer steps

442
00:17:44,240 --> 00:17:48,480
then that's the key

443
00:17:45,840 --> 00:17:48,480
let's say

444
00:17:49,280 --> 00:17:54,720
this is the cardinality of

445
00:17:52,000 --> 00:17:57,039
okay this is the number of variables the

446
00:17:54,720 --> 00:17:58,640
cardinality of the set b right the

447
00:17:57,039 --> 00:18:02,400
number of variables

448
00:17:58,640 --> 00:18:02,400
we set p as

449
00:18:04,000 --> 00:18:07,600
this this uh

450
00:18:06,080 --> 00:18:09,600
this number

451
00:18:07,600 --> 00:18:11,919
then you will see that

452
00:18:09,600 --> 00:18:12,840
to derive

453
00:18:11,919 --> 00:18:16,720
string

454
00:18:12,840 --> 00:18:19,840
of this length

455
00:18:16,720 --> 00:18:20,799
the right string of distance you need to

456
00:18:19,840 --> 00:18:22,559
have

457
00:18:20,799 --> 00:18:25,039
the derivation

458
00:18:22,559 --> 00:18:27,039
so many steps

459
00:18:25,039 --> 00:18:28,559
then you must

460
00:18:27,039 --> 00:18:30,559
used

461
00:18:28,559 --> 00:18:33,280
some duplicate

462
00:18:30,559 --> 00:18:34,960
variable along the derivation or the

463
00:18:33,280 --> 00:18:35,840
parse tree

464
00:18:34,960 --> 00:18:39,840
has

465
00:18:35,840 --> 00:18:39,840
some duplicate the sum

466
00:18:39,919 --> 00:18:44,240
variables so

467
00:18:41,679 --> 00:18:44,240
let's say

468
00:18:44,559 --> 00:18:47,840
from

469
00:18:45,600 --> 00:18:51,600
start variable

470
00:18:47,840 --> 00:18:51,600
you finally derived

471
00:18:52,160 --> 00:18:55,840
the string like this

472
00:18:53,919 --> 00:18:57,120
okay the string like the string like

473
00:18:55,840 --> 00:19:00,080
this

474
00:18:57,120 --> 00:19:01,360
and along the path

475
00:19:00,080 --> 00:19:03,039
you use

476
00:19:01,360 --> 00:19:05,039
duplicate

477
00:19:03,039 --> 00:19:06,960
you use duplicate

478
00:19:05,039 --> 00:19:09,200
variables

479
00:19:06,960 --> 00:19:12,160
okay

480
00:19:09,200 --> 00:19:14,799
then when you derived

481
00:19:12,160 --> 00:19:17,120
within the derivation here

482
00:19:14,799 --> 00:19:20,240
some some

483
00:19:17,120 --> 00:19:21,440
in at some step you have

484
00:19:20,240 --> 00:19:22,640
u

485
00:19:21,440 --> 00:19:23,760
r

486
00:19:22,640 --> 00:19:26,480
z

487
00:19:23,760 --> 00:19:26,480
and also

488
00:19:27,440 --> 00:19:30,559
you have

489
00:19:29,679 --> 00:19:31,600
b

490
00:19:30,559 --> 00:19:32,480
r

491
00:19:31,600 --> 00:19:35,760
y

492
00:19:32,480 --> 00:19:36,559
and also you have

493
00:19:35,760 --> 00:19:40,559
z

494
00:19:36,559 --> 00:19:40,559
oh sorry x x right

495
00:19:41,120 --> 00:19:46,640
and you will see that

496
00:19:43,679 --> 00:19:50,000
why don't you use

497
00:19:46,640 --> 00:19:52,000
r generate x

498
00:19:50,000 --> 00:19:55,919
in this part

499
00:19:52,000 --> 00:19:57,520
yes you can because it's context-free so

500
00:19:55,919 --> 00:20:00,960
you can have

501
00:19:57,520 --> 00:20:03,039
this part right within that grammar

502
00:20:00,960 --> 00:20:04,720
you can always do that because

503
00:20:03,039 --> 00:20:07,120
you can

504
00:20:04,720 --> 00:20:10,720
you can uh derive

505
00:20:07,120 --> 00:20:12,480
at r you can use r to derive x directly

506
00:20:10,720 --> 00:20:17,440
then you will have t

507
00:20:12,480 --> 00:20:18,880
u r z and r becomes x so t

508
00:20:17,440 --> 00:20:21,840
derives

509
00:20:18,880 --> 00:20:26,080
u x d which is

510
00:20:21,840 --> 00:20:27,520
u v zero x y zero z

511
00:20:26,080 --> 00:20:29,280
right

512
00:20:27,520 --> 00:20:31,120
and also

513
00:20:29,280 --> 00:20:32,840
you can

514
00:20:31,120 --> 00:20:35,039
have

515
00:20:32,840 --> 00:20:35,840
uh v

516
00:20:35,039 --> 00:20:38,080
r

517
00:20:35,840 --> 00:20:38,080
y

518
00:20:39,840 --> 00:20:48,559
r becomes v r y right and you can also

519
00:20:44,240 --> 00:20:50,880
do that again when you encounter r here

520
00:20:48,559 --> 00:20:52,480
so that will become

521
00:20:50,880 --> 00:20:54,640
this one

522
00:20:52,480 --> 00:20:54,640
t

523
00:20:54,880 --> 00:20:58,400
derives

524
00:20:56,240 --> 00:20:59,200
u

525
00:20:58,400 --> 00:21:01,280
v

526
00:20:59,200 --> 00:21:03,760
sorry

527
00:21:01,280 --> 00:21:09,520
u r z

528
00:21:03,760 --> 00:21:09,520
and then r derives v r y so u

529
00:21:11,120 --> 00:21:14,400
v

530
00:21:11,919 --> 00:21:15,200
r y z

531
00:21:14,400 --> 00:21:17,280
right

532
00:21:15,200 --> 00:21:19,360
and you do that again

533
00:21:17,280 --> 00:21:21,360
you don't derive r

534
00:21:19,360 --> 00:21:24,640
you don't derive x from r

535
00:21:21,360 --> 00:21:25,760
immediately you do this again you will

536
00:21:24,640 --> 00:21:26,559
get

537
00:21:25,760 --> 00:21:28,159
u

538
00:21:26,559 --> 00:21:31,200
b square

539
00:21:28,159 --> 00:21:33,760
r y squared z

540
00:21:31,200 --> 00:21:37,039
then if you like you can do that again

541
00:21:33,760 --> 00:21:40,559
and again again right so you can do that

542
00:21:37,039 --> 00:21:40,559
again if you want

543
00:21:41,120 --> 00:21:45,840
and then to write again if you want

544
00:21:46,559 --> 00:21:52,240
and so on

545
00:21:48,240 --> 00:21:52,240
right so for each i

546
00:21:52,720 --> 00:21:55,679
for each i

547
00:21:56,400 --> 00:21:59,600
integer

548
00:21:58,080 --> 00:22:01,760
the resultant

549
00:21:59,600 --> 00:22:04,320
string is always

550
00:22:01,760 --> 00:22:05,440
in that uh in the language of that

551
00:22:04,320 --> 00:22:07,760
grammar

552
00:22:05,440 --> 00:22:09,200
why because the past tree is always

553
00:22:07,760 --> 00:22:11,280
there

554
00:22:09,200 --> 00:22:12,480
and why the positive is always there

555
00:22:11,280 --> 00:22:13,919
because

556
00:22:12,480 --> 00:22:16,240
what we have

557
00:22:13,919 --> 00:22:17,600
is to repeat

558
00:22:16,240 --> 00:22:19,440
repeatedly

559
00:22:17,600 --> 00:22:21,360
using

560
00:22:19,440 --> 00:22:24,000
repeatedly using

561
00:22:21,360 --> 00:22:25,360
the same variable and we already know

562
00:22:24,000 --> 00:22:28,400
that

563
00:22:25,360 --> 00:22:30,720
we already know that variable what that

564
00:22:28,400 --> 00:22:31,760
variable can become

565
00:22:30,720 --> 00:22:35,200
okay

566
00:22:31,760 --> 00:22:37,280
so that is why we have the property of

567
00:22:35,200 --> 00:22:38,480
context free grammar

568
00:22:37,280 --> 00:22:39,360
uh sorry

569
00:22:38,480 --> 00:22:40,799
the

570
00:22:39,360 --> 00:22:42,720
property of

571
00:22:40,799 --> 00:22:44,480
of pumping lame are for context-free

572
00:22:42,720 --> 00:22:45,760
languages

573
00:22:44,480 --> 00:22:48,640
okay

574
00:22:45,760 --> 00:22:50,640
so all context-free languages

575
00:22:48,640 --> 00:22:52,240
satisfy

576
00:22:50,640 --> 00:22:54,159
pumping layman for context-free

577
00:22:52,240 --> 00:22:56,240
languages

578
00:22:54,159 --> 00:22:57,520
and which is

579
00:22:56,240 --> 00:22:59,520
if a

580
00:22:57,520 --> 00:23:01,679
is a context free language then there is

581
00:22:59,520 --> 00:23:02,960
a confidence p

582
00:23:01,679 --> 00:23:04,000
where

583
00:23:02,960 --> 00:23:07,120
if s

584
00:23:04,000 --> 00:23:10,480
is any string okay any string in the

585
00:23:07,120 --> 00:23:11,280
language of length at least p

586
00:23:10,480 --> 00:23:13,679
then

587
00:23:11,280 --> 00:23:17,120
the string here

588
00:23:13,679 --> 00:23:20,240
may be divided into five pieces

589
00:23:17,120 --> 00:23:23,600
satisfying the three conditions first

590
00:23:20,240 --> 00:23:25,919
one is that you can remove

591
00:23:23,600 --> 00:23:29,840
the second and the fourth

592
00:23:25,919 --> 00:23:32,960
pieces or repeat them in definite times

593
00:23:29,840 --> 00:23:34,960
the resultant string is always in the

594
00:23:32,960 --> 00:23:36,480
language

595
00:23:34,960 --> 00:23:38,960
and the second

596
00:23:36,480 --> 00:23:38,960
and the

597
00:23:39,120 --> 00:23:42,159
fourth piece cannot be

598
00:23:40,730 --> 00:23:44,799
[Music]

599
00:23:42,159 --> 00:23:46,720
empty together

600
00:23:44,799 --> 00:23:48,480
and the middle three

601
00:23:46,720 --> 00:23:50,480
will be

602
00:23:48,480 --> 00:23:52,799
less than or equal to p

603
00:23:50,480 --> 00:23:52,799
okay

604
00:23:55,679 --> 00:23:59,120
so

605
00:23:57,600 --> 00:24:01,679
again like

606
00:23:59,120 --> 00:24:04,480
complement for regular languages

607
00:24:01,679 --> 00:24:05,679
permanent are for counter free languages

608
00:24:04,480 --> 00:24:09,360
is

609
00:24:05,679 --> 00:24:12,240
also a sufficient conditions

610
00:24:09,360 --> 00:24:14,880
okay sufficient condition sorry

611
00:24:12,240 --> 00:24:18,000
necessary condition sorry sorry

612
00:24:14,880 --> 00:24:18,960
so it's also a necessary condition that

613
00:24:18,000 --> 00:24:21,279
all

614
00:24:18,960 --> 00:24:23,520
context-free languages

615
00:24:21,279 --> 00:24:26,720
has such property

616
00:24:23,520 --> 00:24:29,760
that means if a language has no such

617
00:24:26,720 --> 00:24:31,520
property it's not context-free

618
00:24:29,760 --> 00:24:34,240
but it doesn't mean that

619
00:24:31,520 --> 00:24:36,320
if you know some language has this

620
00:24:34,240 --> 00:24:38,400
property

621
00:24:36,320 --> 00:24:40,400
it's a content context free it doesn't

622
00:24:38,400 --> 00:24:43,039
mean that okay

623
00:24:40,400 --> 00:24:44,799
so the only

624
00:24:43,039 --> 00:24:46,400
way to use family name of account

625
00:24:44,799 --> 00:24:49,679
accounts free languages

626
00:24:46,400 --> 00:24:51,520
is to prove some language not

627
00:24:49,679 --> 00:24:54,159
context-free

628
00:24:51,520 --> 00:24:56,480
so how to use it

629
00:24:54,159 --> 00:24:59,480
the way to use it is the same

630
00:24:56,480 --> 00:24:59,480
that

631
00:25:03,600 --> 00:25:06,880
we assume

632
00:25:04,960 --> 00:25:09,440
a language b

633
00:25:06,880 --> 00:25:10,799
to be context-free

634
00:25:09,440 --> 00:25:12,960
okay

635
00:25:10,799 --> 00:25:15,279
if we want to prove some language not

636
00:25:12,960 --> 00:25:17,279
context-free you assume it to be

637
00:25:15,279 --> 00:25:20,000
context-free first

638
00:25:17,279 --> 00:25:21,520
since it is context-free the language

639
00:25:20,000 --> 00:25:24,400
must have

640
00:25:21,520 --> 00:25:26,799
the property described by the pumping

641
00:25:24,400 --> 00:25:26,799
lemma

642
00:25:26,840 --> 00:25:29,840
right

643
00:25:28,400 --> 00:25:31,600
then

644
00:25:29,840 --> 00:25:33,120
confidence p

645
00:25:31,600 --> 00:25:36,080
exists

646
00:25:33,120 --> 00:25:39,039
so for any string in the language can be

647
00:25:36,080 --> 00:25:40,400
pumped if the length the string is long

648
00:25:39,039 --> 00:25:42,559
enough

649
00:25:40,400 --> 00:25:46,960
so we need to choose some particular

650
00:25:42,559 --> 00:25:50,400
string s as our counter example

651
00:25:46,960 --> 00:25:53,360
at what s must be it must be long enough

652
00:25:50,400 --> 00:25:56,400
and then to prove that x

653
00:25:53,360 --> 00:26:00,080
cannot be pumped as described

654
00:25:56,400 --> 00:26:01,679
then we get the contradiction

655
00:26:00,080 --> 00:26:05,120
so b

656
00:26:01,679 --> 00:26:08,559
the language is not context free

657
00:26:05,120 --> 00:26:12,240
okay so that's what we want to do here

658
00:26:08,559 --> 00:26:15,360
so let's see an example for this

659
00:26:12,240 --> 00:26:18,080
the example we just described that

660
00:26:15,360 --> 00:26:19,679
we have a language b

661
00:26:18,080 --> 00:26:21,120
which is

662
00:26:19,679 --> 00:26:25,279
then

663
00:26:21,120 --> 00:26:26,720
same number of a's b's and c's

664
00:26:25,279 --> 00:26:28,320
okay

665
00:26:26,720 --> 00:26:29,919
firstly

666
00:26:28,320 --> 00:26:33,200
we assume that

667
00:26:29,919 --> 00:26:36,559
the language is context-free

668
00:26:33,200 --> 00:26:39,279
okay since it is context-free

669
00:26:36,559 --> 00:26:41,600
there is a pumping length

670
00:26:39,279 --> 00:26:43,919
for b we don't know how

671
00:26:41,600 --> 00:26:48,000
what what the value what is the value

672
00:26:43,919 --> 00:26:50,799
but there is a number here

673
00:26:48,000 --> 00:26:53,679
then we know that for any string longer

674
00:26:50,799 --> 00:26:56,080
than p must be pumped

675
00:26:53,679 --> 00:26:59,200
but there must there must be some way

676
00:26:56,080 --> 00:27:02,320
for that string to be pumped right

677
00:26:59,200 --> 00:27:02,320
now we select

678
00:27:02,480 --> 00:27:06,520
the counter example as

679
00:27:06,960 --> 00:27:14,799
p asp bs and pcs

680
00:27:10,720 --> 00:27:16,799
right pas pbs and pcs

681
00:27:14,799 --> 00:27:19,120
so they'll be

682
00:27:16,799 --> 00:27:19,120
a

683
00:27:19,200 --> 00:27:21,440
b

684
00:27:21,520 --> 00:27:26,480
c

685
00:27:22,880 --> 00:27:26,480
and the length is p

686
00:27:26,960 --> 00:27:30,080
p

687
00:27:29,120 --> 00:27:30,960
m p

688
00:27:30,080 --> 00:27:33,120
right

689
00:27:30,960 --> 00:27:36,880
so what is the length the whole length

690
00:27:33,120 --> 00:27:36,880
the whole the length of the whole string

691
00:27:37,679 --> 00:27:40,399
is 3p

692
00:27:40,720 --> 00:27:44,640
3p of course greater than and equal to p

693
00:27:43,760 --> 00:27:47,600
so

694
00:27:44,640 --> 00:27:49,440
firstly the string is long enough

695
00:27:47,600 --> 00:27:52,000
okay long enough and the string is

696
00:27:49,440 --> 00:27:54,799
apparently in a language

697
00:27:52,000 --> 00:27:57,679
now we need to say that

698
00:27:54,799 --> 00:28:02,080
we need to say that

699
00:27:57,679 --> 00:28:04,880
such as there is no way to divide it the

700
00:28:02,080 --> 00:28:07,600
way there is no way to divide the string

701
00:28:04,880 --> 00:28:10,000
into five pieces

702
00:28:07,600 --> 00:28:12,159
satisfying the three conditions

703
00:28:10,000 --> 00:28:15,440
described in the polynomial for

704
00:28:12,159 --> 00:28:18,960
context-free language at the same time

705
00:28:15,440 --> 00:28:23,200
we must prove that it's impossible

706
00:28:18,960 --> 00:28:25,279
the difficulty is that we cannot

707
00:28:23,200 --> 00:28:27,760
try all possibilities

708
00:28:25,279 --> 00:28:29,760
right because you don't know how

709
00:28:27,760 --> 00:28:32,640
you cannot

710
00:28:29,760 --> 00:28:35,520
since we don't know exactly what p is

711
00:28:32,640 --> 00:28:35,520
then how can we

712
00:28:37,840 --> 00:28:43,360
prove all possibilities so we need to

713
00:28:40,559 --> 00:28:44,640
classify the situation and

714
00:28:43,360 --> 00:28:46,559
to cover

715
00:28:44,640 --> 00:28:47,520
all possibilities

716
00:28:46,559 --> 00:28:49,919
okay

717
00:28:47,520 --> 00:28:52,480
so we know that

718
00:28:49,919 --> 00:28:54,399
for the second

719
00:28:52,480 --> 00:28:57,440
condition

720
00:28:54,399 --> 00:29:00,640
v y cannot both be

721
00:28:57,440 --> 00:29:03,520
empty string at the same time right

722
00:29:00,640 --> 00:29:03,520
and we know that

723
00:29:04,000 --> 00:29:06,640
x

724
00:29:04,880 --> 00:29:09,520
y

725
00:29:06,640 --> 00:29:09,520
no not x y

726
00:29:10,320 --> 00:29:14,159
v

727
00:29:11,120 --> 00:29:17,279
x y the middle three pieces

728
00:29:14,159 --> 00:29:20,559
is less than or equal to p

729
00:29:17,279 --> 00:29:23,520
right we know that

730
00:29:20,559 --> 00:29:25,760
the way to divide the string into five

731
00:29:23,520 --> 00:29:28,559
pieces must satisfy

732
00:29:25,760 --> 00:29:31,919
three conditions and this this is the

733
00:29:28,559 --> 00:29:32,720
second one and the third one here

734
00:29:31,919 --> 00:29:34,799
so

735
00:29:32,720 --> 00:29:38,000
consider all

736
00:29:34,799 --> 00:29:39,600
possible divisions satisfying

737
00:29:38,000 --> 00:29:41,520
two and three

738
00:29:39,600 --> 00:29:44,320
criteria two and three

739
00:29:41,520 --> 00:29:44,320
we know that

740
00:29:44,720 --> 00:29:48,480
we can

741
00:29:47,039 --> 00:29:50,159
think of

742
00:29:48,480 --> 00:29:51,760
where is the

743
00:29:50,159 --> 00:29:56,720
three

744
00:29:51,760 --> 00:29:59,120
middle three pieces see and

745
00:29:56,720 --> 00:30:01,840
it is only

746
00:29:59,120 --> 00:30:03,520
possible that

747
00:30:01,840 --> 00:30:04,880
the middle three

748
00:30:03,520 --> 00:30:07,840
will lie

749
00:30:04,880 --> 00:30:09,360
here right because it must be

750
00:30:07,840 --> 00:30:11,760
less than p right

751
00:30:09,360 --> 00:30:14,799
so middle three in a

752
00:30:11,760 --> 00:30:17,360
or middle three in b

753
00:30:14,799 --> 00:30:19,039
or in c

754
00:30:17,360 --> 00:30:20,320
right

755
00:30:19,039 --> 00:30:23,679
or

756
00:30:20,320 --> 00:30:28,080
cross the border like this

757
00:30:23,679 --> 00:30:28,080
or cross the border like this

758
00:30:28,799 --> 00:30:32,320
but

759
00:30:29,600 --> 00:30:34,159
it will never

760
00:30:32,320 --> 00:30:36,000
be like this

761
00:30:34,159 --> 00:30:39,679
right because that would be longer than

762
00:30:36,000 --> 00:30:41,279
p and it's impossible

763
00:30:39,679 --> 00:30:43,120
so there are

764
00:30:41,279 --> 00:30:45,840
only five

765
00:30:43,120 --> 00:30:48,960
situations covers all

766
00:30:45,840 --> 00:30:50,640
possibilities for dividing

767
00:30:48,960 --> 00:30:54,159
the string

768
00:30:50,640 --> 00:30:54,159
okay for dividing the string

769
00:30:55,600 --> 00:30:57,919
then

770
00:30:59,600 --> 00:31:05,919
within the five possible five situations

771
00:31:02,880 --> 00:31:06,330
there are there are actually

772
00:31:05,919 --> 00:31:07,600
only

773
00:31:06,330 --> 00:31:09,919
[Music]

774
00:31:07,600 --> 00:31:09,919
two

775
00:31:10,000 --> 00:31:14,640
situations

776
00:31:11,600 --> 00:31:16,880
if you consider them together

777
00:31:14,640 --> 00:31:20,480
the first one is the three conditions

778
00:31:16,880 --> 00:31:21,840
here that is both

779
00:31:20,480 --> 00:31:24,559
the second

780
00:31:21,840 --> 00:31:29,440
piece and the fourth piece

781
00:31:24,559 --> 00:31:31,519
contain only one type of the alphabet

782
00:31:29,440 --> 00:31:33,440
alphabet symbol right

783
00:31:31,519 --> 00:31:36,240
so for the

784
00:31:33,440 --> 00:31:39,840
situation number one here

785
00:31:36,240 --> 00:31:42,799
b and y contains only a

786
00:31:39,840 --> 00:31:44,080
so the situation number two here

787
00:31:42,799 --> 00:31:45,679
b and y

788
00:31:44,080 --> 00:31:48,159
contains only b

789
00:31:45,679 --> 00:31:51,200
only a's only b

790
00:31:48,159 --> 00:31:53,200
and for situation number three here

791
00:31:51,200 --> 00:31:54,799
only c's

792
00:31:53,200 --> 00:31:57,120
right

793
00:31:54,799 --> 00:31:57,120
since

794
00:31:58,640 --> 00:32:05,120
only one type of the alphabet symbols

795
00:32:02,399 --> 00:32:05,120
is content

796
00:32:05,440 --> 00:32:11,919
then you know that

797
00:32:08,159 --> 00:32:11,919
as long as you check you

798
00:32:12,840 --> 00:32:15,440
you

799
00:32:14,399 --> 00:32:16,320
v

800
00:32:15,440 --> 00:32:17,360
v

801
00:32:16,320 --> 00:32:18,159
x

802
00:32:17,360 --> 00:32:19,039
y

803
00:32:18,159 --> 00:32:20,080
y

804
00:32:19,039 --> 00:32:22,960
z

805
00:32:20,080 --> 00:32:22,960
you all know that

806
00:32:23,039 --> 00:32:29,919
for example if they are both a

807
00:32:26,480 --> 00:32:31,360
then for the whole string here

808
00:32:29,919 --> 00:32:35,200
you will have

809
00:32:31,360 --> 00:32:36,399
more a's than b's and c's

810
00:32:35,200 --> 00:32:37,279
right

811
00:32:36,399 --> 00:32:39,440
so

812
00:32:37,279 --> 00:32:41,200
the resultant string

813
00:32:39,440 --> 00:32:45,360
will

814
00:32:41,200 --> 00:32:48,480
be not in the language

815
00:32:45,360 --> 00:32:51,519
right or your u and the y

816
00:32:48,480 --> 00:32:52,960
content contain only b

817
00:32:51,519 --> 00:32:55,679
then

818
00:32:52,960 --> 00:32:57,919
after repeating v and y

819
00:32:55,679 --> 00:33:00,240
the number of b

820
00:32:57,919 --> 00:33:01,919
this b okay not the language b the the

821
00:33:00,240 --> 00:33:03,039
alphabet symbol b

822
00:33:01,919 --> 00:33:04,399
small b

823
00:33:03,039 --> 00:33:05,600
will be

824
00:33:04,399 --> 00:33:07,519
more

825
00:33:05,600 --> 00:33:09,120
b's than

826
00:33:07,519 --> 00:33:12,320
a's and c's

827
00:33:09,120 --> 00:33:14,480
so that's not in c and also goes to

828
00:33:12,320 --> 00:33:14,480
c

829
00:33:14,960 --> 00:33:17,200
right

830
00:33:19,600 --> 00:33:22,840
then again

831
00:33:22,000 --> 00:33:26,720
for

832
00:33:22,840 --> 00:33:29,120
c the same thing so

833
00:33:26,720 --> 00:33:32,399
we know that for the

834
00:33:29,120 --> 00:33:34,080
condition here it's impossible to have a

835
00:33:32,399 --> 00:33:35,200
way to divide

836
00:33:34,080 --> 00:33:37,600
the

837
00:33:35,200 --> 00:33:38,559
counter example string here

838
00:33:37,600 --> 00:33:40,399
then

839
00:33:38,559 --> 00:33:42,080
let's go to the

840
00:33:40,399 --> 00:33:43,440
second situation

841
00:33:42,080 --> 00:33:46,240
the fourth

842
00:33:43,440 --> 00:33:47,120
situation here

843
00:33:46,240 --> 00:33:48,880
v

844
00:33:47,120 --> 00:33:51,919
probably

845
00:33:48,880 --> 00:33:56,000
v and y we don't know which part okay

846
00:33:51,919 --> 00:34:00,159
but we know that together they probably

847
00:33:56,000 --> 00:34:00,159
have both a and b

848
00:34:00,399 --> 00:34:06,399
okay

849
00:34:02,240 --> 00:34:09,040
or for the fifth situation here

850
00:34:06,399 --> 00:34:12,720
it may they may both

851
00:34:09,040 --> 00:34:12,720
together have b and c

852
00:34:13,440 --> 00:34:18,000
but if they have b a and b

853
00:34:16,320 --> 00:34:19,440
the same thing here

854
00:34:18,000 --> 00:34:20,480
u

855
00:34:19,440 --> 00:34:21,520
b

856
00:34:20,480 --> 00:34:22,320
v

857
00:34:21,520 --> 00:34:24,399
x

858
00:34:22,320 --> 00:34:26,320
y y

859
00:34:24,399 --> 00:34:28,320
z

860
00:34:26,320 --> 00:34:29,280
they are not in b

861
00:34:28,320 --> 00:34:32,159
why

862
00:34:29,280 --> 00:34:36,800
because they have only a and b and you

863
00:34:32,159 --> 00:34:41,280
repeat b and y so the number of a

864
00:34:36,800 --> 00:34:43,839
of a's and b's they may be you know kept

865
00:34:41,280 --> 00:34:46,000
identical

866
00:34:43,839 --> 00:34:48,639
but

867
00:34:46,000 --> 00:34:51,919
the number of c's is not

868
00:34:48,639 --> 00:34:53,760
increased right the number of c's stay

869
00:34:51,919 --> 00:34:56,159
the same as what

870
00:34:53,760 --> 00:34:58,400
p here

871
00:34:56,159 --> 00:35:03,440
so the resultant string

872
00:34:58,400 --> 00:35:05,680
will definitely not in b

873
00:35:03,440 --> 00:35:05,680
okay

874
00:35:05,839 --> 00:35:10,000
again

875
00:35:06,880 --> 00:35:13,760
if v and y

876
00:35:10,000 --> 00:35:13,760
together have b and c

877
00:35:14,000 --> 00:35:18,079
same argument

878
00:35:15,760 --> 00:35:20,400
the number of

879
00:35:18,079 --> 00:35:23,200
a's

880
00:35:20,400 --> 00:35:25,440
stay the same as p

881
00:35:23,200 --> 00:35:25,440
no

882
00:35:26,960 --> 00:35:31,599
no increase in the number of a's

883
00:35:29,760 --> 00:35:34,160
so

884
00:35:31,599 --> 00:35:36,960
the resultant string by repeating

885
00:35:34,160 --> 00:35:36,960
v and y

886
00:35:38,000 --> 00:35:42,320
will

887
00:35:38,960 --> 00:35:44,960
be not in b

888
00:35:42,320 --> 00:35:45,920
so

889
00:35:44,960 --> 00:35:49,280
by

890
00:35:45,920 --> 00:35:51,520
using the argument here we know that

891
00:35:49,280 --> 00:35:54,880
there is no way

892
00:35:51,520 --> 00:35:54,880
absolutely no way

893
00:35:55,040 --> 00:35:59,320
to

894
00:35:56,320 --> 00:35:59,320
divide

895
00:36:00,400 --> 00:36:03,680
ap

896
00:36:01,400 --> 00:36:05,359
bpcp here

897
00:36:03,680 --> 00:36:08,079
into

898
00:36:05,359 --> 00:36:10,640
three pieces satisfying

899
00:36:08,079 --> 00:36:12,240
the three conditions

900
00:36:10,640 --> 00:36:13,040
described

901
00:36:12,240 --> 00:36:15,760
by

902
00:36:13,040 --> 00:36:17,520
pumping lima for

903
00:36:15,760 --> 00:36:19,839
context free language

904
00:36:17,520 --> 00:36:22,000
like as here

905
00:36:19,839 --> 00:36:23,920
there's no way

906
00:36:22,000 --> 00:36:27,240
so we know that

907
00:36:23,920 --> 00:36:27,240
we know that

908
00:36:28,000 --> 00:36:37,040
the language

909
00:36:30,800 --> 00:36:37,040
a n b and c n is not context free

910
00:36:38,839 --> 00:36:44,079
okay so let's go back to see when

911
00:36:45,440 --> 00:36:47,680
when

912
00:36:48,160 --> 00:36:52,560
b

913
00:36:49,040 --> 00:36:55,119
y one of them is empty string

914
00:36:52,560 --> 00:36:57,920
it's actually quite easy because

915
00:36:55,119 --> 00:36:57,920
if you see

916
00:36:58,160 --> 00:37:03,119
the previous example we have here

917
00:37:03,839 --> 00:37:11,280
see let's say

918
00:37:06,839 --> 00:37:11,280
okay easy simple maybe okay

919
00:37:14,480 --> 00:37:17,599
let's do this

920
00:37:19,599 --> 00:37:23,839
okay

921
00:37:21,440 --> 00:37:23,839
see

922
00:37:25,280 --> 00:37:28,320
any string here

923
00:37:28,480 --> 00:37:31,440
any string here

924
00:37:32,320 --> 00:37:35,320
okay

925
00:37:38,079 --> 00:37:42,640
on the path tree

926
00:37:40,400 --> 00:37:45,680
they use the same variable

927
00:37:42,640 --> 00:37:45,680
again right

928
00:37:46,079 --> 00:37:51,280
since we have only one variable

929
00:37:48,800 --> 00:37:52,560
any steps more than one you use the same

930
00:37:51,280 --> 00:37:54,240
variable

931
00:37:52,560 --> 00:37:56,720
then you know that

932
00:37:54,240 --> 00:37:57,599
it can become

933
00:37:56,720 --> 00:37:59,839
you know

934
00:37:57,599 --> 00:37:59,839
so

935
00:38:00,160 --> 00:38:04,680
that that makes it r

936
00:38:04,720 --> 00:38:10,160
and of course it's only also r but we we

937
00:38:08,079 --> 00:38:11,359
just use the

938
00:38:10,160 --> 00:38:14,240
uh

939
00:38:11,359 --> 00:38:14,240
last two so

940
00:38:14,640 --> 00:38:18,880
this is x

941
00:38:16,079 --> 00:38:20,880
right

942
00:38:18,880 --> 00:38:23,040
and

943
00:38:20,880 --> 00:38:25,920
another accessory

944
00:38:23,040 --> 00:38:25,920
and these are

945
00:38:26,240 --> 00:38:28,880
derived

946
00:38:30,000 --> 00:38:33,400
this part

947
00:38:39,680 --> 00:38:43,760
and the whole thing derives this part

948
00:38:45,440 --> 00:38:47,839
okay

949
00:38:48,960 --> 00:38:51,839
so we have

950
00:38:55,599 --> 00:38:58,160
z here

951
00:38:59,119 --> 00:39:01,839
and

952
00:39:09,280 --> 00:39:14,640
we want to have u v

953
00:39:11,760 --> 00:39:15,520
x y z

954
00:39:14,640 --> 00:39:17,920
right

955
00:39:15,520 --> 00:39:19,359
and let's use t okay

956
00:39:17,920 --> 00:39:21,200
so t

957
00:39:19,359 --> 00:39:22,320
derives

958
00:39:21,200 --> 00:39:23,680
what

959
00:39:22,320 --> 00:39:24,960
u

960
00:39:23,680 --> 00:39:27,960
r

961
00:39:24,960 --> 00:39:27,960
z

962
00:39:28,400 --> 00:39:32,800
and r

963
00:39:30,000 --> 00:39:35,359
the first r derives what

964
00:39:32,800 --> 00:39:35,359
u uh

965
00:39:35,760 --> 00:39:37,119
v

966
00:39:35,960 --> 00:39:38,000
[Music]

967
00:39:37,119 --> 00:39:39,119
r

968
00:39:38,000 --> 00:39:40,839
y

969
00:39:39,119 --> 00:39:42,880
then second r

970
00:39:40,839 --> 00:39:43,760
derives x

971
00:39:42,880 --> 00:39:48,240
okay

972
00:39:43,760 --> 00:39:48,240
so here this a is x

973
00:39:48,480 --> 00:39:53,920
and here

974
00:39:51,280 --> 00:39:53,920
is b

975
00:39:54,400 --> 00:39:58,240
and the u

976
00:39:55,760 --> 00:40:00,000
is empty

977
00:39:58,240 --> 00:40:02,720
and the y

978
00:40:00,000 --> 00:40:04,960
is empty

979
00:40:02,720 --> 00:40:04,960
okay

980
00:40:07,359 --> 00:40:10,800
so

981
00:40:09,040 --> 00:40:13,040
in this case

982
00:40:10,800 --> 00:40:15,440
we will get t

983
00:40:13,040 --> 00:40:17,359
derives

984
00:40:15,440 --> 00:40:19,359
empty

985
00:40:17,359 --> 00:40:20,880
r

986
00:40:19,359 --> 00:40:24,720
z

987
00:40:20,880 --> 00:40:26,800
and of course z eventually becomes xa

988
00:40:24,720 --> 00:40:29,839
and sorry

989
00:40:26,800 --> 00:40:31,599
the x here is not the x it's the this

990
00:40:29,839 --> 00:40:34,240
part

991
00:40:31,599 --> 00:40:35,839
so times a okay

992
00:40:34,240 --> 00:40:39,480
and then the

993
00:40:35,839 --> 00:40:39,480
first r here

994
00:40:39,680 --> 00:40:42,400
derives

995
00:40:43,359 --> 00:40:48,480
v

996
00:40:44,400 --> 00:40:48,480
which will become a plus

997
00:40:50,079 --> 00:40:54,640
r

998
00:40:51,200 --> 00:40:57,280
and y y is empty right

999
00:40:54,640 --> 00:40:59,760
and r here

1000
00:40:57,280 --> 00:41:01,920
derives

1001
00:40:59,760 --> 00:41:01,920
a

1002
00:41:03,680 --> 00:41:06,640
so

1003
00:41:04,839 --> 00:41:09,680
see

1004
00:41:06,640 --> 00:41:10,960
the fourth part here is

1005
00:41:09,680 --> 00:41:12,640
empty

1006
00:41:10,960 --> 00:41:15,280
and you can see that

1007
00:41:12,640 --> 00:41:17,440
we can repeat

1008
00:41:15,280 --> 00:41:17,440
v

1009
00:41:18,560 --> 00:41:24,560
indefinite times and the result in the

1010
00:41:21,200 --> 00:41:26,560
string is still in the language

1011
00:41:24,560 --> 00:41:27,359
okay

1012
00:41:26,560 --> 00:41:29,599
and

1013
00:41:27,359 --> 00:41:34,079
if you go with the

1014
00:41:29,599 --> 00:41:35,839
parser here you will have

1015
00:41:34,079 --> 00:41:38,079
second piece

1016
00:41:35,839 --> 00:41:42,640
as empty string

1017
00:41:38,079 --> 00:41:42,640
right if you choose r here and r here

1018
00:41:42,720 --> 00:41:46,319
so you will have

1019
00:41:44,720 --> 00:41:48,880
these parts as

1020
00:41:46,319 --> 00:41:50,160
u and the z

1021
00:41:48,880 --> 00:41:53,680
empty

1022
00:41:50,160 --> 00:41:56,480
because you have x as this one

1023
00:41:53,680 --> 00:41:57,599
and r

1024
00:41:56,480 --> 00:42:00,560
and

1025
00:41:57,599 --> 00:42:01,760
that will be y

1026
00:42:00,560 --> 00:42:03,359
right

1027
00:42:01,760 --> 00:42:05,920
so

1028
00:42:03,359 --> 00:42:10,319
you can see the situation that when your

1029
00:42:05,920 --> 00:42:11,520
position or the duplicated variables

1030
00:42:10,319 --> 00:42:13,440
are

1031
00:42:11,520 --> 00:42:16,560
you know uh

1032
00:42:13,440 --> 00:42:20,319
on the leftmost or on the right most

1033
00:42:16,560 --> 00:42:21,680
the second or fourth pieces will be

1034
00:42:20,319 --> 00:42:22,720
empty

1035
00:42:21,680 --> 00:42:24,079
okay

1036
00:42:22,720 --> 00:42:26,880
will be empty

1037
00:42:24,079 --> 00:42:28,720
okay so that's the that's why

1038
00:42:26,880 --> 00:42:30,240
in pumping layman for countless three

1039
00:42:28,720 --> 00:42:34,400
languages

1040
00:42:30,240 --> 00:42:35,119
we have the criteria that

1041
00:42:34,400 --> 00:42:38,560
b

1042
00:42:35,119 --> 00:42:39,599
y cannot both be

1043
00:42:38,560 --> 00:42:40,800
empty

1044
00:42:39,599 --> 00:42:43,200
they can

1045
00:42:40,800 --> 00:42:45,119
it is possible one of them is empty but

1046
00:42:43,200 --> 00:42:47,200
they cannot be both empty because you

1047
00:42:45,119 --> 00:42:48,400
always have some terminal strings

1048
00:42:47,200 --> 00:42:51,200
generated

1049
00:42:48,400 --> 00:42:52,160
along the way okay

1050
00:42:51,200 --> 00:42:57,160
okay

1051
00:42:52,160 --> 00:42:57,160
then let's go back to

1052
00:43:07,760 --> 00:43:10,760
here

1053
00:43:12,480 --> 00:43:17,200
then we know that

1054
00:43:15,040 --> 00:43:20,960
by using

1055
00:43:17,200 --> 00:43:22,560
pumping lemma for context-free languages

1056
00:43:20,960 --> 00:43:25,200
we can prove

1057
00:43:22,560 --> 00:43:27,440
actually we already proved

1058
00:43:25,200 --> 00:43:29,520
a language

1059
00:43:27,440 --> 00:43:29,520
b

1060
00:43:29,680 --> 00:43:32,560
a n

1061
00:43:31,280 --> 00:43:34,800
b n

1062
00:43:32,560 --> 00:43:36,480
c n

1063
00:43:34,800 --> 00:43:39,280
outside of

1064
00:43:36,480 --> 00:43:41,839
regular sorry contest-free languages

1065
00:43:39,280 --> 00:43:44,880
right

1066
00:43:41,839 --> 00:43:44,880
so we know

1067
00:43:45,680 --> 00:43:49,760
sadly

1068
00:43:46,880 --> 00:43:53,280
context-free languages are not

1069
00:43:49,760 --> 00:43:56,800
all possible languages

1070
00:43:53,280 --> 00:43:56,800
there are languages

1071
00:43:57,280 --> 00:44:02,480
not context free

1072
00:43:59,040 --> 00:44:04,720
and here is the concrete example

1073
00:44:02,480 --> 00:44:04,720
right

1074
00:44:06,839 --> 00:44:14,480
so we need to face the problem that uh

1075
00:44:11,440 --> 00:44:18,720
well pda country grammar

1076
00:44:14,480 --> 00:44:18,720
are not universal computational models

1077
00:44:18,880 --> 00:44:22,240
okay

1078
00:44:20,400 --> 00:44:24,640
so

1079
00:44:22,240 --> 00:44:26,560
that's it for now

1080
00:44:24,640 --> 00:44:29,680
we know that

1081
00:44:26,560 --> 00:44:29,680
there are something

1082
00:44:31,280 --> 00:44:34,319
here

1083
00:44:32,800 --> 00:44:38,160
and

1084
00:44:34,319 --> 00:44:40,319
probably many languages outside of

1085
00:44:38,160 --> 00:44:41,680
context three languages

1086
00:44:40,319 --> 00:44:44,800
that's

1087
00:44:41,680 --> 00:44:47,800
we can know so far

1088
00:44:44,800 --> 00:44:47,800
okay

