1
00:00:04,000 --> 00:00:06,399
hi

2
00:00:04,319 --> 00:00:07,440
uh last time we talked about the

3
00:00:06,399 --> 00:00:10,800
definition of

4
00:00:07,440 --> 00:00:13,840
finite time 10 and

5
00:00:10,800 --> 00:00:17,840
actually regular language

6
00:00:13,840 --> 00:00:22,160
we defined a format or specification

7
00:00:17,840 --> 00:00:25,840
of final automata and says that

8
00:00:22,160 --> 00:00:29,679
the length any language if you can find

9
00:00:25,840 --> 00:00:33,120
some finite automata to recognize it

10
00:00:29,679 --> 00:00:33,840
then we call that language regular

11
00:00:33,120 --> 00:00:36,559
language

12
00:00:33,840 --> 00:00:38,480
and i also mentioned that in this

13
00:00:36,559 --> 00:00:42,559
analogy

14
00:00:38,480 --> 00:00:46,879
we you know kind of consider

15
00:00:42,559 --> 00:00:50,800
languages as problems and

16
00:00:46,879 --> 00:00:53,760
strings as the problem instance

17
00:00:50,800 --> 00:00:54,480
of that kind of problem and someone

18
00:00:53,760 --> 00:00:59,520
might ask

19
00:00:54,480 --> 00:01:02,320
that why do we want to

20
00:00:59,520 --> 00:01:04,159
think of computation this way problem

21
00:01:02,320 --> 00:01:08,560
solving this way

22
00:01:04,159 --> 00:01:12,880
well the answer is well not

23
00:01:08,560 --> 00:01:17,119
everyone's answer my answer to this

24
00:01:12,880 --> 00:01:20,000
to this question is firstly

25
00:01:17,119 --> 00:01:20,000
consider that

26
00:01:24,840 --> 00:01:29,520
everything

27
00:01:26,320 --> 00:01:32,799
computation is basically

28
00:01:29,520 --> 00:01:32,799
uh we need to

29
00:01:33,200 --> 00:01:40,320
make it we need to

30
00:01:36,560 --> 00:01:43,920
symbolize the whole thing in order to

31
00:01:40,320 --> 00:01:48,240
do the operations the computations

32
00:01:43,920 --> 00:01:52,159
right actually everything

33
00:01:48,240 --> 00:01:54,799
we communicate with languages

34
00:01:52,159 --> 00:01:55,200
by languages i mean natural languages

35
00:01:54,799 --> 00:01:59,040
like

36
00:01:55,200 --> 00:02:03,280
i'm trying to speak uh english right now

37
00:01:59,040 --> 00:02:06,399
and i am a mandarin or chinese

38
00:02:03,280 --> 00:02:10,640
native speakers so

39
00:02:06,399 --> 00:02:14,480
i can communicate with either language

40
00:02:10,640 --> 00:02:14,480
without difficulty but

41
00:02:15,120 --> 00:02:22,480
the point is no matter

42
00:02:19,280 --> 00:02:26,720
we communicate with speaking or

43
00:02:22,480 --> 00:02:26,720
writings like currency

44
00:02:28,160 --> 00:02:33,280
i write something here so i draw online

45
00:02:31,200 --> 00:02:35,599
regular language and the regular

46
00:02:33,280 --> 00:02:38,959
language is actually

47
00:02:35,599 --> 00:02:42,080
a string of symbols right r e g

48
00:02:38,959 --> 00:02:45,280
u l a r a space

49
00:02:42,080 --> 00:02:48,400
l n g u a g e

50
00:02:45,280 --> 00:02:51,200
so everything is a string

51
00:02:48,400 --> 00:02:52,879
the problem is only what kind of

52
00:02:51,200 --> 00:02:56,480
alphabet

53
00:02:52,879 --> 00:03:00,319
the string belongs to okay

54
00:02:56,480 --> 00:03:03,519
so imagine that imagine that

55
00:03:00,319 --> 00:03:07,040
if you have a alphabet and

56
00:03:03,519 --> 00:03:10,640
from the alphabet you compose some

57
00:03:07,040 --> 00:03:15,200
string like one plus

58
00:03:10,640 --> 00:03:19,040
one equals two

59
00:03:15,200 --> 00:03:22,159
and you can also compose that 2

60
00:03:19,040 --> 00:03:25,360
plus 3

61
00:03:22,159 --> 00:03:28,480
equals 5 and

62
00:03:25,360 --> 00:03:31,680
you can compose that plus

63
00:03:28,480 --> 00:03:35,360
1 1 plus

64
00:03:31,680 --> 00:03:39,360
or something like 1 plus

65
00:03:35,360 --> 00:03:45,040
3 equals

66
00:03:39,360 --> 00:03:45,040
1 2 and go on

67
00:03:45,680 --> 00:03:52,080
and go on then

68
00:03:49,360 --> 00:03:53,760
if there is a machine maybe find

69
00:03:52,080 --> 00:03:57,280
automata maybe not

70
00:03:53,760 --> 00:04:01,120
anyway an abstract machine

71
00:03:57,280 --> 00:04:04,560
can correctly it's a

72
00:04:01,120 --> 00:04:08,400
it's just a showcase okay can correctly

73
00:04:04,560 --> 00:04:12,720
accept all correct

74
00:04:08,400 --> 00:04:15,840
addition for example accept this string

75
00:04:12,720 --> 00:04:19,759
accept this string not

76
00:04:15,840 --> 00:04:23,520
accept the string not accept this string

77
00:04:19,759 --> 00:04:26,560
okay so perhaps uh

78
00:04:23,520 --> 00:04:29,680
you have that machine and

79
00:04:26,560 --> 00:04:33,160
you give it like 20

80
00:04:29,680 --> 00:04:37,280
plus 1 1 equals

81
00:04:33,160 --> 00:04:41,600
31 and this machine accept

82
00:04:37,280 --> 00:04:44,960
or you give it something wrong like

83
00:04:41,600 --> 00:04:49,120
two plus one equal to five and

84
00:04:44,960 --> 00:04:52,400
another except or in

85
00:04:49,120 --> 00:04:56,320
uh in some wrong format

86
00:04:52,400 --> 00:04:59,919
like one plus

87
00:04:56,320 --> 00:05:04,479
1 plus another accept

88
00:04:59,919 --> 00:05:08,240
okay so in

89
00:05:04,479 --> 00:05:11,199
in some way we must consider that

90
00:05:08,240 --> 00:05:11,199
this machine and

91
00:05:12,400 --> 00:05:20,000
know how to do addition

92
00:05:16,160 --> 00:05:23,360
or we can say that the machine m solves

93
00:05:20,000 --> 00:05:26,960
the addition problem it knows how to do

94
00:05:23,360 --> 00:05:31,360
addition if you can accept

95
00:05:26,960 --> 00:05:36,880
arguments like list you probably can

96
00:05:31,360 --> 00:05:36,880
accept that accepted analogy

97
00:05:37,039 --> 00:05:43,600
i said languages are

98
00:05:40,080 --> 00:05:47,600
problems and strings

99
00:05:43,600 --> 00:05:51,039
are instances of that problems

100
00:05:47,600 --> 00:05:54,240
okay that's why we discuss

101
00:05:51,039 --> 00:05:57,520
computation this way as

102
00:05:54,240 --> 00:06:02,080
if we are only we will be

103
00:05:57,520 --> 00:06:02,080
discussing only string process

104
00:06:02,319 --> 00:06:08,720
in a way yes but

105
00:06:05,680 --> 00:06:09,600
by doing this we are actually thinking

106
00:06:08,720 --> 00:06:14,800
about

107
00:06:09,600 --> 00:06:14,800
something more fundamental more uh

108
00:06:15,520 --> 00:06:22,880
more uh we are talking about core

109
00:06:19,759 --> 00:06:26,960
properties character corrects the

110
00:06:22,880 --> 00:06:30,319
characteristics of computations

111
00:06:26,960 --> 00:06:32,639
okay so that's why we start from

112
00:06:30,319 --> 00:06:33,600
the simplest computational model final

113
00:06:32,639 --> 00:06:36,160
temper

114
00:06:33,600 --> 00:06:38,000
and talk about string processing but the

115
00:06:36,160 --> 00:06:41,280
string processing is not really

116
00:06:38,000 --> 00:06:46,840
stream processing we are using this way

117
00:06:41,280 --> 00:06:48,880
of processing to model computation

118
00:06:46,840 --> 00:06:51,199
itself

119
00:06:48,880 --> 00:06:51,199
so

120
00:06:58,800 --> 00:07:06,560
according to this concept

121
00:07:03,039 --> 00:07:07,120
the whole thing goes like uh firstly we

122
00:07:06,560 --> 00:07:10,160
define

123
00:07:07,120 --> 00:07:14,000
final automaton it's kind of

124
00:07:10,160 --> 00:07:17,840
it's a kind of machine right then

125
00:07:14,000 --> 00:07:17,840
since it's a kind of machine

126
00:07:18,479 --> 00:07:25,840
what kind of language can this machine

127
00:07:21,520 --> 00:07:29,360
process firstly we

128
00:07:25,840 --> 00:07:30,160
we define this kind of machine final

129
00:07:29,360 --> 00:07:33,759
automata

130
00:07:30,160 --> 00:07:36,560
can process regular languages

131
00:07:33,759 --> 00:07:37,599
so regular languages at least in our

132
00:07:36,560 --> 00:07:42,639
textbook

133
00:07:37,599 --> 00:07:45,680
is defined by finite automata

134
00:07:42,639 --> 00:07:48,720
if i give you one final automata

135
00:07:45,680 --> 00:07:52,800
it can recognize exactly one language

136
00:07:48,720 --> 00:07:56,000
right then

137
00:07:52,800 --> 00:07:59,680
on the other hand what language can be

138
00:07:56,000 --> 00:08:02,800
recognized by this kind of machine

139
00:07:59,680 --> 00:08:06,240
we define those language as

140
00:08:02,800 --> 00:08:09,360
regular language okay

141
00:08:06,240 --> 00:08:12,639
so regular language represents

142
00:08:09,360 --> 00:08:16,000
a set of problems

143
00:08:12,639 --> 00:08:19,599
which can be handled or solved

144
00:08:16,000 --> 00:08:19,599
by finite automata

145
00:08:20,000 --> 00:08:26,720
okay don't forget that languages

146
00:08:23,120 --> 00:08:31,120
are problems and final automata

147
00:08:26,720 --> 00:08:34,159
solves some problems maybe all but

148
00:08:31,120 --> 00:08:37,360
we we we leave that later

149
00:08:34,159 --> 00:08:41,440
but final automata can solve

150
00:08:37,360 --> 00:08:46,080
some problems and we want to discuss

151
00:08:41,440 --> 00:08:49,360
what kind of problems can find out

152
00:08:46,080 --> 00:08:51,760
not really this way but we are this we

153
00:08:49,360 --> 00:08:54,959
will be discussing the limitation

154
00:08:51,760 --> 00:08:58,800
the boundary actually of

155
00:08:54,959 --> 00:09:03,040
regular languages which are or which

156
00:08:58,800 --> 00:09:04,560
means those languages can be recognized

157
00:09:03,040 --> 00:09:07,760
by final auto

158
00:09:04,560 --> 00:09:09,279
in analogy those problems can be handled

159
00:09:07,760 --> 00:09:11,200
by

160
00:09:09,279 --> 00:09:13,040
computational machines like final

161
00:09:11,200 --> 00:09:16,800
automata

162
00:09:13,040 --> 00:09:16,800
okay so

163
00:09:17,200 --> 00:09:22,399
since we want to talk about or discuss

164
00:09:19,839 --> 00:09:25,600
the boundary of regular languages

165
00:09:22,399 --> 00:09:28,720
and regular sorry languages

166
00:09:25,600 --> 00:09:32,080
itself as we mentioned language

167
00:09:28,720 --> 00:09:36,320
in this course is just a set

168
00:09:32,080 --> 00:09:40,720
of strings so we call that languages

169
00:09:36,320 --> 00:09:44,800
then in order to facilitate

170
00:09:40,720 --> 00:09:48,240
our discussion on regular languages

171
00:09:44,800 --> 00:09:51,040
we want to introduce some operations

172
00:09:48,240 --> 00:09:53,519
and discuss the property of these

173
00:09:51,040 --> 00:09:57,519
operations

174
00:09:53,519 --> 00:09:59,440
so regular operations okay

175
00:09:57,519 --> 00:10:01,040
and don't be confused by regular the

176
00:09:59,440 --> 00:10:04,240
term we just

177
00:10:01,040 --> 00:10:08,480
okay we just talk uh just mention it as

178
00:10:04,240 --> 00:10:10,959
operations let a and b

179
00:10:08,480 --> 00:10:13,519
be languages and don't forget that

180
00:10:10,959 --> 00:10:17,360
languages

181
00:10:13,519 --> 00:10:20,959
are set that's it

182
00:10:17,360 --> 00:10:25,279
okay sets of strings

183
00:10:20,959 --> 00:10:32,079
sorry pretty difficult to

184
00:10:25,279 --> 00:10:35,680
write this way

185
00:10:32,079 --> 00:10:38,720
okay then

186
00:10:35,680 --> 00:10:41,440
as you may already know

187
00:10:38,720 --> 00:10:44,240
there are some operations for sets and

188
00:10:41,440 --> 00:10:47,600
there are some operations for strings

189
00:10:44,240 --> 00:10:48,720
right operations for sets um i guess

190
00:10:47,600 --> 00:10:52,079
must be introduced

191
00:10:48,720 --> 00:10:54,640
to you in math classes and

192
00:10:52,079 --> 00:10:56,640
operation for strings maybe programming

193
00:10:54,640 --> 00:11:00,560
language

194
00:10:56,640 --> 00:11:04,480
or course regarding programming right

195
00:11:00,560 --> 00:11:08,560
but more or less

196
00:11:04,480 --> 00:11:12,320
everyone knows something about it

197
00:11:08,560 --> 00:11:15,920
so since a and b are languages

198
00:11:12,320 --> 00:11:19,360
and sets of strings

199
00:11:15,920 --> 00:11:22,480
we want to introduce three operations

200
00:11:19,360 --> 00:11:26,000
based on sets and strings

201
00:11:22,480 --> 00:11:29,519
first one is union okay i think

202
00:11:26,000 --> 00:11:33,200
everybody knows this one union

203
00:11:29,519 --> 00:11:35,920
if you have two sets what is the union

204
00:11:33,200 --> 00:11:36,320
you just put them together and there is

205
00:11:35,920 --> 00:11:40,240
no

206
00:11:36,320 --> 00:11:43,120
duplicate elements no duplicate members

207
00:11:40,240 --> 00:11:44,560
okay that's unions so let's have an

208
00:11:43,120 --> 00:11:49,040
example here

209
00:11:44,560 --> 00:11:49,040
if a is

210
00:11:51,279 --> 00:11:54,880
1 sorry

211
00:11:55,279 --> 00:12:02,079
0 0 0 and 1 1

212
00:11:58,399 --> 00:12:06,000
and let's say b is

213
00:12:02,079 --> 00:12:10,240
1 1 0 0

214
00:12:06,000 --> 00:12:13,760
0 1 0 then what is the union of a b

215
00:12:10,240 --> 00:12:14,480
that would be since 1 y is duplicated

216
00:12:13,760 --> 00:12:18,639
member

217
00:12:14,480 --> 00:12:18,639
so we have 0 0

218
00:12:19,680 --> 00:12:27,680
sorry 0 0 0 0 0 and 0

219
00:12:22,880 --> 00:12:32,240
1 0 okay that's the union of a and b

220
00:12:27,680 --> 00:12:35,760
and don't forget that in mathematics

221
00:12:32,240 --> 00:12:39,200
in mathematics there is no order

222
00:12:35,760 --> 00:12:40,240
in the set okay so it doesn't matter if

223
00:12:39,200 --> 00:12:43,360
i write

224
00:12:40,240 --> 00:12:47,200
0 0 0 0 0 or

225
00:12:43,360 --> 00:12:47,760
i write 0 0 0 0 1 0 and 0 0 it doesn't

226
00:12:47,200 --> 00:12:50,079
matter

227
00:12:47,760 --> 00:12:51,680
okay that's very important because

228
00:12:50,079 --> 00:12:56,639
there's no order in

229
00:12:51,680 --> 00:13:00,639
sets of math and the next operation

230
00:12:56,639 --> 00:13:02,880
is concave concatenation

231
00:13:00,639 --> 00:13:02,880
well

232
00:13:03,680 --> 00:13:10,320
in a way it's a operation

233
00:13:06,720 --> 00:13:14,079
of strings right because if you have

234
00:13:10,320 --> 00:13:19,040
one string zero zero and the other

235
00:13:14,079 --> 00:13:22,480
zero one zero when we

236
00:13:19,040 --> 00:13:26,000
denotes this way if x is 0

237
00:13:22,480 --> 00:13:29,519
0 y is 0 1 0 when we

238
00:13:26,000 --> 00:13:32,880
write x and y that means

239
00:13:29,519 --> 00:13:36,560
you just connect the two strings 1 0

240
00:13:32,880 --> 00:13:40,399
0 0 1 0. that's it

241
00:13:36,560 --> 00:13:44,800
that's concretion okay but now

242
00:13:40,399 --> 00:13:47,040
our a and b are sets of strings

243
00:13:44,800 --> 00:13:48,000
not only strings they are state of

244
00:13:47,040 --> 00:13:53,440
strings

245
00:13:48,000 --> 00:13:56,480
so we define concatenation

246
00:13:53,440 --> 00:14:01,839
as everyone

247
00:13:56,480 --> 00:14:02,959
every string in a and every string in b

248
00:14:01,839 --> 00:14:06,320
pair together

249
00:14:02,959 --> 00:14:09,680
and connect the two strings

250
00:14:06,320 --> 00:14:13,600
and form a new set okay

251
00:14:09,680 --> 00:14:17,519
so for the same example a b here

252
00:14:13,600 --> 00:14:21,760
a b what would be

253
00:14:17,519 --> 00:14:24,800
the result of complaining concatenation

254
00:14:21,760 --> 00:14:28,560
it would be 0

255
00:14:24,800 --> 00:14:32,480
0 0 1 1

256
00:14:28,560 --> 00:14:35,519
okay 0 0 0

257
00:14:32,480 --> 00:14:39,760
0 0 0 0

258
00:14:35,519 --> 00:14:43,199
0 0 1 0 and then

259
00:14:39,760 --> 00:14:46,320
1 1 1 1 1 1

260
00:14:43,199 --> 00:14:49,440
zero zero one one zero

261
00:14:46,320 --> 00:14:53,199
one zero that would be the result

262
00:14:49,440 --> 00:14:53,199
of our a and b

263
00:14:54,800 --> 00:15:02,240
i i think it would be easy right

264
00:14:58,639 --> 00:15:04,880
but actually concatenation defined

265
00:15:02,240 --> 00:15:04,880
in this way

266
00:15:07,199 --> 00:15:16,480
in addition to operations of strings

267
00:15:11,040 --> 00:15:16,480
it's also an operation of sets

268
00:15:16,560 --> 00:15:20,959
what operation is called cartesian

269
00:15:19,440 --> 00:15:24,839
product

270
00:15:20,959 --> 00:15:26,160
all right cartesian products between two

271
00:15:24,839 --> 00:15:28,959
sets

272
00:15:26,160 --> 00:15:29,759
are pairing all the possible elements

273
00:15:28,959 --> 00:15:34,000
together

274
00:15:29,759 --> 00:15:36,959
with order by order i mean first one

275
00:15:34,000 --> 00:15:38,399
in the first set and the second one in

276
00:15:36,959 --> 00:15:41,120
the second set

277
00:15:38,399 --> 00:15:41,759
okay so you can see that we are we

278
00:15:41,120 --> 00:15:44,959
actually

279
00:15:41,759 --> 00:15:45,839
also did a cartesian product here

280
00:15:44,959 --> 00:15:48,320
because

281
00:15:45,839 --> 00:15:50,160
you see first elements in a and the

282
00:15:48,320 --> 00:15:53,680
second element in b

283
00:15:50,160 --> 00:15:57,279
first element in a second element in b

284
00:15:53,680 --> 00:16:01,519
and so on so forth like this okay

285
00:15:57,279 --> 00:16:01,519
so that would be cartesian product

286
00:16:03,440 --> 00:16:10,480
but in any way it should be a

287
00:16:07,600 --> 00:16:11,839
known operations it's not anything new

288
00:16:10,480 --> 00:16:15,040
here

289
00:16:11,839 --> 00:16:15,040
okay so

290
00:16:15,680 --> 00:16:19,040
next one is a

291
00:16:19,600 --> 00:16:22,880
probably new operations but actually

292
00:16:21,920 --> 00:16:28,000
it's not

293
00:16:22,880 --> 00:16:33,040
why what is star operation we can write

294
00:16:28,000 --> 00:16:36,959
definition this way okay

295
00:16:33,040 --> 00:16:40,959
but another way to introduce

296
00:16:36,959 --> 00:16:44,160
star operation is that star version

297
00:16:40,959 --> 00:16:44,959
if you have a string and the star

298
00:16:44,160 --> 00:16:48,560
operation

299
00:16:44,959 --> 00:16:51,759
is no matter what

300
00:16:48,560 --> 00:16:55,839
you put an empty string

301
00:16:51,759 --> 00:16:57,839
here okay no matter what empty string

302
00:16:55,839 --> 00:16:59,759
quite artificial but you put empty

303
00:16:57,839 --> 00:17:02,000
string there

304
00:16:59,759 --> 00:17:03,680
and don't forget that empty string means

305
00:17:02,000 --> 00:17:06,720
nothing no symbol

306
00:17:03,680 --> 00:17:10,480
and the empty string's length

307
00:17:06,720 --> 00:17:13,520
is zero the zero is the integer

308
00:17:10,480 --> 00:17:18,559
zero okay not symbol is integer

309
00:17:13,520 --> 00:17:22,959
then you union with a itself

310
00:17:18,559 --> 00:17:27,520
then your union with a

311
00:17:22,959 --> 00:17:31,360
concatenate with a

312
00:17:27,520 --> 00:17:35,440
sometimes we write a

313
00:17:31,360 --> 00:17:38,640
calculate it with a we write it like

314
00:17:35,440 --> 00:17:42,160
a square

315
00:17:38,640 --> 00:17:45,360
okay and also sometimes we write it like

316
00:17:42,160 --> 00:17:49,440
a times a and usually the times

317
00:17:45,360 --> 00:17:52,640
means cartesian product like i just

318
00:17:49,440 --> 00:17:55,840
said and then union let's say

319
00:17:52,640 --> 00:18:00,000
three eighths union

320
00:17:55,840 --> 00:18:03,440
four eight times together union

321
00:18:00,000 --> 00:18:07,520
five and

322
00:18:03,440 --> 00:18:11,919
two many many of them

323
00:18:07,520 --> 00:18:15,600
that's star operation okay

324
00:18:11,919 --> 00:18:20,160
and sometimes we just not sometimes

325
00:18:15,600 --> 00:18:20,160
we use to define this one

326
00:18:20,240 --> 00:18:27,280
a language contains only the

327
00:18:23,280 --> 00:18:30,559
empty string as

328
00:18:27,280 --> 00:18:33,600
a to the 0's power

329
00:18:30,559 --> 00:18:37,039
a a is any language

330
00:18:33,600 --> 00:18:38,559
any string any set of string and its 0th

331
00:18:37,039 --> 00:18:41,679
power

332
00:18:38,559 --> 00:18:45,440
defined as a language contains

333
00:18:41,679 --> 00:18:49,520
only empty string so

334
00:18:45,440 --> 00:18:52,559
for short notation

335
00:18:49,520 --> 00:18:55,679
we can write as oh sorry

336
00:18:52,559 --> 00:18:59,679
not sigma we can write as

337
00:18:55,679 --> 00:19:04,480
with union everything from

338
00:18:59,679 --> 00:19:04,480
i from zero to infinity

339
00:19:04,799 --> 00:19:12,799
hey sorry i

340
00:19:07,840 --> 00:19:12,799
like it okay so let's start operation

341
00:19:13,840 --> 00:19:17,840
so the definition of the three operation

342
00:19:15,919 --> 00:19:22,240
we are trying to talk about

343
00:19:17,840 --> 00:19:24,880
is defined okay and why we want to

344
00:19:22,240 --> 00:19:26,640
you know introduce some operation here

345
00:19:24,880 --> 00:19:30,880
because

346
00:19:26,640 --> 00:19:34,240
by using operation it may help us to

347
00:19:30,880 --> 00:19:38,480
discuss the border of

348
00:19:34,240 --> 00:19:41,600
regular languages and

349
00:19:38,480 --> 00:19:52,720
as mathematician not me i'm not and

350
00:19:41,600 --> 00:19:56,240
i'm not in sorry i'm not a mathematician

351
00:19:52,720 --> 00:20:00,960
i should say in mathematics

352
00:19:56,240 --> 00:20:05,200
they like to scholars they like to

353
00:20:00,960 --> 00:20:08,080
discuss closure properties

354
00:20:05,200 --> 00:20:08,480
why why why would they do that because

355
00:20:08,080 --> 00:20:11,039
uh

356
00:20:08,480 --> 00:20:11,840
by discussing closure properties we can

357
00:20:11,039 --> 00:20:16,320
find many

358
00:20:11,840 --> 00:20:20,480
interesting we can find many interesting

359
00:20:16,320 --> 00:20:24,000
things or new discoveries okay

360
00:20:20,480 --> 00:20:27,520
so for example

361
00:20:24,000 --> 00:20:31,039
uh when you define

362
00:20:27,520 --> 00:20:34,400
addition on integers

363
00:20:31,039 --> 00:20:38,799
so 1 plus 1 is 2

364
00:20:34,400 --> 00:20:41,840
and 2 is an integer so

365
00:20:38,799 --> 00:20:45,120
integer is closed right under the

366
00:20:41,840 --> 00:20:45,120
operation of addition

367
00:20:45,360 --> 00:20:53,919
our positive integer or natural numbers

368
00:20:49,600 --> 00:20:57,440
are closed under the operation

369
00:20:53,919 --> 00:21:01,039
of addition but it's not closed under

370
00:20:57,440 --> 00:21:04,010
the operation of minus like

371
00:21:01,039 --> 00:21:05,520
subtraction one minus two

372
00:21:04,010 --> 00:21:07,360
[Music]

373
00:21:05,520 --> 00:21:08,799
the answer cannot be found in natural

374
00:21:07,360 --> 00:21:12,240
numbers

375
00:21:08,799 --> 00:21:18,240
positive integers nope so we create

376
00:21:12,240 --> 00:21:21,360
negative integers to do uh the closure

377
00:21:18,240 --> 00:21:25,520
and follow the same thing we

378
00:21:21,360 --> 00:21:29,440
create uh like rational numbers

379
00:21:25,520 --> 00:21:34,080
real numbers and complex numbers

380
00:21:29,440 --> 00:21:34,080
right because there is no

381
00:21:34,240 --> 00:21:38,159
real numbers correspond to the quantity

382
00:21:37,360 --> 00:21:40,880
here

383
00:21:38,159 --> 00:21:42,720
so we create complex numbers and the

384
00:21:40,880 --> 00:21:58,080
complex number is closed

385
00:21:42,720 --> 00:22:00,480
under captioning not available

386
00:21:58,080 --> 00:22:00,480
anyway

387
00:22:01,280 --> 00:22:03,520
so

388
00:22:05,440 --> 00:22:13,120
through the operations

389
00:22:09,600 --> 00:22:16,240
we can expand our knowledge

390
00:22:13,120 --> 00:22:18,159
regarding particular sets

391
00:22:16,240 --> 00:22:20,000
and in this case we are talking about

392
00:22:18,159 --> 00:22:23,039
regular languages

393
00:22:20,000 --> 00:22:24,159
so first thing first thing here we want

394
00:22:23,039 --> 00:22:29,600
to

395
00:22:24,159 --> 00:22:33,280
prove that regular languages

396
00:22:29,600 --> 00:22:36,559
a set of languages okay

397
00:22:33,280 --> 00:22:41,360
and we call a set

398
00:22:36,559 --> 00:22:44,400
of languages class

399
00:22:41,360 --> 00:22:48,000
okay so class is nothing more

400
00:22:44,400 --> 00:22:51,280
than set only that

401
00:22:48,000 --> 00:22:54,159
this kind of set the member of

402
00:22:51,280 --> 00:22:54,799
this kind of set is also set then we

403
00:22:54,159 --> 00:22:57,679
call it

404
00:22:54,799 --> 00:22:59,440
class that's it you can also think of

405
00:22:57,679 --> 00:23:03,120
its

406
00:22:59,440 --> 00:23:06,480
set okay anyway so we are

407
00:23:03,120 --> 00:23:09,360
we now want to uh

408
00:23:06,480 --> 00:23:10,320
discuss that whether the class of

409
00:23:09,360 --> 00:23:14,080
regular languages

410
00:23:10,320 --> 00:23:18,320
is closed under the union operations

411
00:23:14,080 --> 00:23:21,520
okay if regular languages are closed

412
00:23:18,320 --> 00:23:24,720
under the union operation

413
00:23:21,520 --> 00:23:26,159
you see we can find any two regular

414
00:23:24,720 --> 00:23:28,640
languages and create

415
00:23:26,159 --> 00:23:30,240
new regular languages right because it's

416
00:23:28,640 --> 00:23:34,080
closed

417
00:23:30,240 --> 00:23:34,080
we don't need to worry about that

418
00:23:34,400 --> 00:23:38,320
i use two regular languages and after

419
00:23:37,280 --> 00:23:41,840
the union

420
00:23:38,320 --> 00:23:45,200
the result is not regular okay

421
00:23:41,840 --> 00:23:47,679
so we want to do the proof here

422
00:23:45,200 --> 00:23:49,440
and this this would be the first proof

423
00:23:47,679 --> 00:23:50,799
in our course it's very important

424
00:23:49,440 --> 00:23:53,919
because

425
00:23:50,799 --> 00:23:57,840
it's it's not complicated and it's

426
00:23:53,919 --> 00:24:01,039
in informative and also

427
00:23:57,840 --> 00:24:04,159
give us many things we will be used

428
00:24:01,039 --> 00:24:07,520
we will be using later and how to

429
00:24:04,159 --> 00:24:11,679
how do we do the proof

430
00:24:07,520 --> 00:24:14,880
we want to construct a new automaton

431
00:24:11,679 --> 00:24:18,720
simulating the two given automaton

432
00:24:14,880 --> 00:24:22,880
okay so that's the idea

433
00:24:18,720 --> 00:24:26,640
so let's go to

434
00:24:22,880 --> 00:24:29,360
the proof of the text textbook

435
00:24:26,640 --> 00:24:29,360
since there

436
00:24:30,799 --> 00:24:34,640
we want to prove that two

437
00:24:40,640 --> 00:24:45,279
two languages the union of two regular

438
00:24:43,440 --> 00:24:48,480
languages

439
00:24:45,279 --> 00:24:51,679
it's still a regular language and okay

440
00:24:48,480 --> 00:24:54,320
here i forgot that don't

441
00:24:51,679 --> 00:24:55,919
be confused that the three operations

442
00:24:54,320 --> 00:24:58,880
here

443
00:24:55,919 --> 00:24:59,520
they can be applied to any languages

444
00:24:58,880 --> 00:25:02,880
okay not

445
00:24:59,520 --> 00:25:05,520
really not regular languages they can

446
00:25:02,880 --> 00:25:07,360
actually for union they can be applied

447
00:25:05,520 --> 00:25:11,679
it can be applied to any

448
00:25:07,360 --> 00:25:11,679
sets right and

449
00:25:11,919 --> 00:25:18,000
so a and b here doesn't need to be

450
00:25:15,279 --> 00:25:19,360
regular languages don't they they don't

451
00:25:18,000 --> 00:25:21,840
be they don't need to be regular

452
00:25:19,360 --> 00:25:21,840
languages

453
00:25:21,919 --> 00:25:24,480
and for

454
00:25:26,840 --> 00:25:34,080
theorem

455
00:25:29,480 --> 00:25:37,919
1.25 what we want to prove is that

456
00:25:34,080 --> 00:25:41,840
if you have two regular languages

457
00:25:37,919 --> 00:25:44,080
after union the resultant language

458
00:25:41,840 --> 00:25:45,600
is still regular that's what we want to

459
00:25:44,080 --> 00:25:49,120
prove it doesn't mean that

460
00:25:45,600 --> 00:25:54,159
union can be only used to handle

461
00:25:49,120 --> 00:25:54,159
to process regular languages okay

462
00:25:54,720 --> 00:26:01,279
okay so how do we how do we want to

463
00:25:58,640 --> 00:26:01,279
prove that

464
00:26:03,039 --> 00:26:07,360
it's weird okay

465
00:26:08,480 --> 00:26:14,960
since we have two languages let's say

466
00:26:11,840 --> 00:26:17,520
a1 and a2

467
00:26:14,960 --> 00:26:18,720
and these two languages are regular

468
00:26:17,520 --> 00:26:21,600
languages

469
00:26:18,720 --> 00:26:22,799
by definition of regular language what

470
00:26:21,600 --> 00:26:26,159
is that

471
00:26:22,799 --> 00:26:30,080
that means a1 you can find

472
00:26:26,159 --> 00:26:33,120
some automata

473
00:26:30,080 --> 00:26:36,840
recognize a1 and

474
00:26:33,120 --> 00:26:40,080
and remember that a1 in this case

475
00:26:36,840 --> 00:26:44,240
a1 recognized only

476
00:26:40,080 --> 00:26:48,960
sorry m1 only recognized a1

477
00:26:44,240 --> 00:26:53,600
no other language only a1 but

478
00:26:48,960 --> 00:26:56,880
on the other hand a1

479
00:26:53,600 --> 00:27:00,240
can be recognized by

480
00:26:56,880 --> 00:27:04,159
other machines other

481
00:27:00,240 --> 00:27:07,919
final automata why because let's say

482
00:27:04,159 --> 00:27:11,679
that's that's say m1 recognize a1

483
00:27:07,919 --> 00:27:15,279
right m1 is the final automata right

484
00:27:11,679 --> 00:27:18,960
so let's say the five components of

485
00:27:15,279 --> 00:27:22,640
m1 are q1 sigma delta 1

486
00:27:18,960 --> 00:27:25,919
q 1 5 f 1 here and imagine that

487
00:27:22,640 --> 00:27:28,320
you add one more state

488
00:27:25,919 --> 00:27:30,320
which is useless which will be not will

489
00:27:28,320 --> 00:27:32,559
not be handled by

490
00:27:30,320 --> 00:27:33,360
will will not be touched during the

491
00:27:32,559 --> 00:27:36,559
operation

492
00:27:33,360 --> 00:27:39,760
of the machine

493
00:27:36,559 --> 00:27:42,799
you create and

494
00:27:39,760 --> 00:27:47,440
other final automata

495
00:27:42,799 --> 00:27:50,480
behave exactly like m1 but it's not n1

496
00:27:47,440 --> 00:27:56,080
and that new automata recognize a1 2

497
00:27:50,480 --> 00:27:59,279
right so m1 recognize only a1 but

498
00:27:56,080 --> 00:28:02,399
a1 may have more than one automata

499
00:27:59,279 --> 00:28:05,919
recognizing itself okay

500
00:28:02,399 --> 00:28:09,200
then let's say m2 recognize

501
00:28:05,919 --> 00:28:14,240
a2 and we have m2 here

502
00:28:09,200 --> 00:28:18,559
okay and for convenience in this proof

503
00:28:14,240 --> 00:28:22,399
we assume that the two language

504
00:28:18,559 --> 00:28:25,760
the alphabet for the two languages

505
00:28:22,399 --> 00:28:29,120
or the two uh final automata

506
00:28:25,760 --> 00:28:31,840
are exactly the same so we don't handle

507
00:28:29,120 --> 00:28:31,840
the different

508
00:28:32,159 --> 00:28:38,960
alphabet here if you have to

509
00:28:35,679 --> 00:28:42,080
if you have to explore

510
00:28:38,960 --> 00:28:46,080
the possibility for this kind of thing

511
00:28:42,080 --> 00:28:49,520
you can do that okay but it's very easy

512
00:28:46,080 --> 00:28:50,480
you just need to uh do a new alphabet

513
00:28:49,520 --> 00:28:53,840
which is this

514
00:28:50,480 --> 00:28:57,120
which is a union of the two alphabet

515
00:28:53,840 --> 00:28:58,880
and you you need to tweak the transition

516
00:28:57,120 --> 00:29:01,760
functions

517
00:28:58,880 --> 00:29:04,480
okay because delta 1 won't be able to

518
00:29:01,760 --> 00:29:06,880
handle sigma 2

519
00:29:04,480 --> 00:29:08,240
symbols in sigma 2 and the delta 2 won't

520
00:29:06,880 --> 00:29:11,520
be able to handle

521
00:29:08,240 --> 00:29:14,399
symbols in sigma 1.

522
00:29:11,520 --> 00:29:15,440
that that would be a you know tedious

523
00:29:14,399 --> 00:29:18,080
details

524
00:29:15,440 --> 00:29:19,520
which is not helpful for understanding

525
00:29:18,080 --> 00:29:22,080
the proof

526
00:29:19,520 --> 00:29:22,080
so we

527
00:29:23,039 --> 00:29:41,840
assume that the

528
00:29:26,880 --> 00:29:41,840
alphabet is the same

529
00:29:41,919 --> 00:29:49,120
okay okay

530
00:29:45,039 --> 00:29:55,840
now we really want to

531
00:29:49,120 --> 00:29:55,840
do the proof and how do we want to prove

532
00:29:56,159 --> 00:30:04,559
a one union a2

533
00:30:01,200 --> 00:30:07,600
this resultant flank uh

534
00:30:04,559 --> 00:30:09,840
language is still regular how do we do

535
00:30:07,600 --> 00:30:09,840
that

536
00:30:10,559 --> 00:30:14,320
we do that by using the definition what

537
00:30:12,960 --> 00:30:18,640
is the definition

538
00:30:14,320 --> 00:30:18,640
we say that a language is regular

539
00:30:18,799 --> 00:30:25,279
because some automata recognize it

540
00:30:22,080 --> 00:30:25,919
right so now we want we what we want to

541
00:30:25,279 --> 00:30:29,120
do

542
00:30:25,919 --> 00:30:33,679
is to construct a new

543
00:30:29,120 --> 00:30:38,640
final automaton based on

544
00:30:33,679 --> 00:30:38,640
n1 and m2 okay

545
00:30:38,799 --> 00:30:42,399
well in a way you can think of this kind

546
00:30:41,600 --> 00:30:45,279
of thing

547
00:30:42,399 --> 00:30:46,399
like uh you download some source code

548
00:30:45,279 --> 00:30:50,799
from github

549
00:30:46,399 --> 00:30:54,399
or bitpac bitbucket gillette and then

550
00:30:50,799 --> 00:30:57,919
you merge some

551
00:30:54,399 --> 00:31:01,039
source code you download it

552
00:30:57,919 --> 00:31:04,320
together to create your own program

553
00:31:01,039 --> 00:31:07,840
something like that okay so

554
00:31:04,320 --> 00:31:11,279
now what we have we download m1 m1

555
00:31:07,840 --> 00:31:14,559
is like this and also we download m2

556
00:31:11,279 --> 00:31:15,279
and the m2 is like this now we want to

557
00:31:14,559 --> 00:31:19,279
prove that

558
00:31:15,279 --> 00:31:22,799
a1 and a the union of a1 and a2

559
00:31:19,279 --> 00:31:26,880
is also regular we

560
00:31:22,799 --> 00:31:29,919
construct a new machine which recognize

561
00:31:26,880 --> 00:31:33,120
a1 the union of a1 and

562
00:31:29,919 --> 00:31:36,880
a2 okay so that is

563
00:31:33,120 --> 00:31:36,880
what we want to do here

564
00:31:38,159 --> 00:31:43,679
since m we want to cons the machine we

565
00:31:41,840 --> 00:31:44,840
want to the final time that we want to

566
00:31:43,679 --> 00:31:47,840
construct

567
00:31:44,840 --> 00:31:47,840
is

568
00:31:48,640 --> 00:31:55,440
is also has also uh

569
00:31:51,760 --> 00:31:58,559
is composed of five top five

570
00:31:55,440 --> 00:31:59,679
component we just need to describe each

571
00:31:58,559 --> 00:32:02,880
of them

572
00:31:59,679 --> 00:32:06,240
and for alphabet we are

573
00:32:02,880 --> 00:32:08,000
already described that we assume that

574
00:32:06,240 --> 00:32:10,159
they are the same

575
00:32:08,000 --> 00:32:11,120
if you don't want to do that as i said

576
00:32:10,159 --> 00:32:13,919
you do this

577
00:32:11,120 --> 00:32:15,279
and you need to tweak the transition

578
00:32:13,919 --> 00:32:19,039
functions

579
00:32:15,279 --> 00:32:22,720
okay and firstly uh

580
00:32:19,039 --> 00:32:26,240
except for sigma here we want to this

581
00:32:22,720 --> 00:32:29,039
we need to formally describe

582
00:32:26,240 --> 00:32:30,720
for the the four other components in

583
00:32:29,039 --> 00:32:33,840
detail

584
00:32:30,720 --> 00:32:34,880
okay okay so how do we construct a new

585
00:32:33,840 --> 00:32:39,039
final automata

586
00:32:34,880 --> 00:32:42,159
m according to m1 and m2

587
00:32:39,039 --> 00:32:45,840
okay let's consider this

588
00:32:42,159 --> 00:32:45,840
if you have m1 here

589
00:32:50,399 --> 00:32:58,559
if you have m1 here and the m2 here

590
00:32:55,039 --> 00:33:02,960
right then

591
00:32:58,559 --> 00:33:05,919
when something some string

592
00:33:02,960 --> 00:33:07,200
you want to determine if the string

593
00:33:05,919 --> 00:33:10,399
belongs to

594
00:33:07,200 --> 00:33:13,919
a1 or a2

595
00:33:10,399 --> 00:33:17,360
if you throw it into m1

596
00:33:13,919 --> 00:33:19,679
it will process like this

597
00:33:17,360 --> 00:33:19,679
right

598
00:33:21,120 --> 00:33:27,919
perhaps like q1 q

599
00:33:24,640 --> 00:33:32,880
3 q c 7

600
00:33:27,919 --> 00:33:36,960
q 2 and something

601
00:33:32,880 --> 00:33:40,720
and maybe accept

602
00:33:36,960 --> 00:33:43,840
okay then you throw it into q2

603
00:33:40,720 --> 00:33:46,640
m2 it will go

604
00:33:43,840 --> 00:33:48,480
through the same length of the

605
00:33:46,640 --> 00:33:52,159
computation process

606
00:33:48,480 --> 00:33:56,880
right so what

607
00:33:52,159 --> 00:34:00,640
our goal is try to

608
00:33:56,880 --> 00:34:03,440
our goal is to try to merge

609
00:34:00,640 --> 00:34:06,720
the two machines but not really merge we

610
00:34:03,440 --> 00:34:09,839
want to create a new machine

611
00:34:06,720 --> 00:34:11,119
and keep track of the response of the

612
00:34:09,839 --> 00:34:16,720
two machine

613
00:34:11,119 --> 00:34:21,520
at the same time imagine that

614
00:34:16,720 --> 00:34:24,800
if the m can do what

615
00:34:21,520 --> 00:34:28,560
the state of n the state of

616
00:34:24,800 --> 00:34:35,520
n processing the same string

617
00:34:28,560 --> 00:34:39,119
the state of m keep track

618
00:34:35,520 --> 00:34:42,240
m1 state and the m2 state

619
00:34:39,119 --> 00:34:46,000
then the state here

620
00:34:42,240 --> 00:34:47,440
representing these combinations

621
00:34:46,000 --> 00:34:49,040
well not combination it's actually

622
00:34:47,440 --> 00:34:53,359
permutation but

623
00:34:49,040 --> 00:34:53,839
well uh it's a tuple of m1 states and m2

624
00:34:53,359 --> 00:34:57,280
states

625
00:34:53,839 --> 00:35:03,839
okay so we want to do

626
00:34:57,280 --> 00:35:03,839
what we want to do is like this

627
00:35:04,160 --> 00:35:09,839
so we use one state of n to keep track

628
00:35:10,240 --> 00:35:17,359
the composite state of m1

629
00:35:13,520 --> 00:35:21,280
and m2 for example if you have

630
00:35:17,359 --> 00:35:25,200
m1 like three states let's say

631
00:35:21,280 --> 00:35:29,200
uh q1

632
00:35:25,200 --> 00:35:32,960
and the q2 and the q3 three state

633
00:35:29,200 --> 00:35:38,079
and m2 has two states

634
00:35:32,960 --> 00:35:42,079
p1 and the p2 okay just for example

635
00:35:38,079 --> 00:35:43,359
at any given moment how many pass the

636
00:35:42,079 --> 00:35:46,640
possibility of

637
00:35:43,359 --> 00:35:49,839
m1 and n2 you only have

638
00:35:46,640 --> 00:35:53,119
6 right so

639
00:35:49,839 --> 00:35:56,560
that would be q m1 is

640
00:35:53,119 --> 00:36:00,480
on q1 and m2 on p1

641
00:35:56,560 --> 00:36:05,280
m1 on q2 and m2 on p1

642
00:36:00,480 --> 00:36:08,960
m1 on q3 and m2 on qp

643
00:36:05,280 --> 00:36:12,160
p1 and the q1 p2

644
00:36:08,960 --> 00:36:16,880
q2 p2 q

645
00:36:12,160 --> 00:36:16,880
3 p 3 right

646
00:36:17,200 --> 00:36:23,280
so it's all the possibilities there's

647
00:36:21,200 --> 00:36:27,119
nothing more

648
00:36:23,280 --> 00:36:30,240
so we only need n

649
00:36:27,119 --> 00:36:33,680
to have six states

650
00:36:30,240 --> 00:36:37,280
to trace all the possibilities

651
00:36:33,680 --> 00:36:40,560
right then why is six because

652
00:36:37,280 --> 00:36:43,599
three times two that's it

653
00:36:40,560 --> 00:36:45,839
so firstly you need

654
00:36:43,599 --> 00:36:48,560
the multiplication of the number of the

655
00:36:45,839 --> 00:36:52,720
states of the two machines

656
00:36:48,560 --> 00:36:56,240
and secondly you need a naming system

657
00:36:52,720 --> 00:36:59,599
to name each state to name

658
00:36:56,240 --> 00:37:02,720
each state correspond to

659
00:36:59,599 --> 00:37:07,359
what combination of m1 and

660
00:37:02,720 --> 00:37:07,359
m2 okay

661
00:37:07,520 --> 00:37:12,160
and luckily we already have a set

662
00:37:10,640 --> 00:37:15,680
operation called

663
00:37:12,160 --> 00:37:20,160
cartesian product to provide

664
00:37:15,680 --> 00:37:20,160
us the two functionalities

665
00:37:20,880 --> 00:37:27,680
when we do a cartesian product of q1

666
00:37:24,800 --> 00:37:27,680
and q2

667
00:37:27,839 --> 00:37:32,000
we get the multiplication of the number

668
00:37:30,800 --> 00:37:35,520
of states

669
00:37:32,000 --> 00:37:39,200
and we also get something like

670
00:37:35,520 --> 00:37:44,320
q1 from okay q1

671
00:37:39,200 --> 00:37:48,160
and the q p1 from q2 and

672
00:37:44,320 --> 00:37:51,839
imagine that on the machine of m1

673
00:37:48,160 --> 00:37:55,119
each state is marked by

674
00:37:51,839 --> 00:37:58,640
q1 and the another states

675
00:37:55,119 --> 00:38:04,320
q2 and the nasdaq q3

676
00:37:58,640 --> 00:38:07,440
right and also for m2 like p1 and p2

677
00:38:04,320 --> 00:38:11,359
and we do a cartesian product here

678
00:38:07,440 --> 00:38:14,560
and you can we can consider

679
00:38:11,359 --> 00:38:20,400
this notation directly as

680
00:38:14,560 --> 00:38:24,320
a label attached to the state

681
00:38:20,400 --> 00:38:28,800
so for m we have a state

682
00:38:24,320 --> 00:38:32,560
like this named as q1

683
00:38:28,800 --> 00:38:35,839
comma q2 p1 okay

684
00:38:32,560 --> 00:38:39,359
and a state named like this

685
00:38:35,839 --> 00:38:42,800
a state name like this a state

686
00:38:39,359 --> 00:38:47,839
named like this okay

687
00:38:42,800 --> 00:38:47,839
so that's how we define it

688
00:38:49,760 --> 00:38:55,119
we say that we define

689
00:38:57,599 --> 00:39:01,920
we define the q here as the cartesian

690
00:39:01,280 --> 00:39:04,960
product

691
00:39:01,920 --> 00:39:08,240
of q1 and q2 and q

692
00:39:04,960 --> 00:39:11,520
here will be like r1 and

693
00:39:08,240 --> 00:39:14,640
r2 and r1 from q1 and r2 from

694
00:39:11,520 --> 00:39:18,640
q 2. that's it as

695
00:39:14,640 --> 00:39:22,480
the example i just give

696
00:39:18,640 --> 00:39:25,760
okay so that's the q of m

697
00:39:22,480 --> 00:39:25,760
then let's say

698
00:39:26,079 --> 00:39:33,520
for transition functions

699
00:39:29,680 --> 00:39:37,200
we just need to copy delta 1

700
00:39:33,520 --> 00:39:40,720
and delta 2 into our m

701
00:39:37,200 --> 00:39:44,160
exactly our m's delta okay

702
00:39:40,720 --> 00:39:46,560
so for each c

703
00:39:44,160 --> 00:39:48,000
we want to write this transition

704
00:39:46,560 --> 00:39:50,560
function

705
00:39:48,000 --> 00:39:51,599
and our transition function is a

706
00:39:50,560 --> 00:39:55,680
function from

707
00:39:51,599 --> 00:39:59,520
q m1 q times

708
00:39:55,680 --> 00:40:04,800
sigma mapping 2q right

709
00:39:59,520 --> 00:40:04,800
don't forget that and everyone here

710
00:40:04,960 --> 00:40:13,280
you can know that r1

711
00:40:08,319 --> 00:40:16,720
from q1 r2

712
00:40:13,280 --> 00:40:19,920
from q2 right

713
00:40:16,720 --> 00:40:24,480
when our transition function sees

714
00:40:19,920 --> 00:40:29,200
a state of within q

715
00:40:24,480 --> 00:40:33,440
with a symbol in a string

716
00:40:29,200 --> 00:40:36,800
where is the destination state

717
00:40:33,440 --> 00:40:40,000
in q we should go

718
00:40:36,800 --> 00:40:45,280
we just need to look up

719
00:40:40,000 --> 00:40:49,599
delta one and delta two so we feed

720
00:40:45,280 --> 00:40:54,400
r1 and the same the same symbol

721
00:40:49,599 --> 00:40:58,640
into delta one and don't forget that

722
00:40:54,400 --> 00:41:01,680
for delta 1 delta 1

723
00:40:58,640 --> 00:41:06,560
is a function making

724
00:41:01,680 --> 00:41:10,960
q1 times sigma to

725
00:41:06,560 --> 00:41:15,440
a state in q1 so the result

726
00:41:10,960 --> 00:41:18,800
of this one is something

727
00:41:15,440 --> 00:41:22,079
in q1 right the same

728
00:41:18,800 --> 00:41:26,319
goes to delta 2. so

729
00:41:22,079 --> 00:41:29,839
we feed r2 and also a to delta 2

730
00:41:26,319 --> 00:41:34,960
we will get some states

731
00:41:29,839 --> 00:41:38,560
in delta 2. now you can see that

732
00:41:34,960 --> 00:41:42,640
a states in delta one and a states

733
00:41:38,560 --> 00:41:46,000
in delta two the pair of these two state

734
00:41:42,640 --> 00:41:50,319
is exactly a state

735
00:41:46,000 --> 00:41:53,440
in queue right so we finished

736
00:41:50,319 --> 00:41:57,200
the transition function here

737
00:41:53,440 --> 00:42:00,800
see our program is composite

738
00:41:57,200 --> 00:42:00,800
of others programs

739
00:42:01,280 --> 00:42:09,359
and it is also the beauty of using

740
00:42:05,599 --> 00:42:14,319
cartesian product to produce

741
00:42:09,359 --> 00:42:14,319
the state of machine m okay

742
00:42:15,119 --> 00:42:20,079
follow the same idea then we know that

743
00:42:20,240 --> 00:42:26,720
which st which uh which state of

744
00:42:23,680 --> 00:42:31,040
our m should become

745
00:42:26,720 --> 00:42:33,760
uh set as star state it's easy

746
00:42:31,040 --> 00:42:34,640
that would be the pair of the star

747
00:42:33,760 --> 00:42:45,839
states

748
00:42:34,640 --> 00:42:45,839
of m1 and m2

749
00:42:47,359 --> 00:42:51,119
okay so

750
00:42:51,200 --> 00:42:59,440
we need to have the describe the last

751
00:42:54,960 --> 00:43:02,720
component which is the accept states

752
00:42:59,440 --> 00:43:05,040
and we just need to describe describe

753
00:43:02,720 --> 00:43:05,040
that

754
00:43:07,599 --> 00:43:11,119
all states in queue

755
00:43:11,520 --> 00:43:18,960
q is a cartesian product of q1

756
00:43:14,720 --> 00:43:22,720
and q2 right

757
00:43:18,960 --> 00:43:27,760
so all possible pairs are in q

758
00:43:22,720 --> 00:43:30,560
and we just need to check for any pair

759
00:43:27,760 --> 00:43:30,560
as long as

760
00:43:31,440 --> 00:43:34,800
first one is in

761
00:43:33,450 --> 00:43:38,839
[Music]

762
00:43:34,800 --> 00:43:42,079
the accept state of m1

763
00:43:38,839 --> 00:43:46,880
or second one

764
00:43:42,079 --> 00:43:46,880
is in the accept state of q2

765
00:43:48,480 --> 00:43:55,920
then we define these states

766
00:43:52,319 --> 00:44:00,480
one of our accept states

767
00:43:55,920 --> 00:44:03,839
okay so go back to what we have here

768
00:44:00,480 --> 00:44:07,200
for example if the string

769
00:44:03,839 --> 00:44:10,240
w fit into m1 and

770
00:44:07,200 --> 00:44:12,480
n2 and m1

771
00:44:10,240 --> 00:44:13,520
accept the string and to not accept the

772
00:44:12,480 --> 00:44:17,200
string

773
00:44:13,520 --> 00:44:21,119
for union we should accept the string

774
00:44:17,200 --> 00:44:26,240
right if both of them accept the string

775
00:44:21,119 --> 00:44:26,240
yeah we accept the string only no

776
00:44:29,359 --> 00:44:32,640
no acceptance for the two machines

777
00:44:31,680 --> 00:44:34,800
neither of them

778
00:44:32,640 --> 00:44:35,760
accepts a string we don't accept a

779
00:44:34,800 --> 00:44:39,359
string

780
00:44:35,760 --> 00:44:43,839
right so we just need to define

781
00:44:39,359 --> 00:44:48,480
the accept

782
00:44:43,839 --> 00:44:48,480
accept states of n as

783
00:44:49,440 --> 00:44:56,560
either one of them except the

784
00:44:53,280 --> 00:45:00,000
string or you can

785
00:44:56,560 --> 00:45:05,839
write the expression like

786
00:45:00,000 --> 00:45:05,839
this one sorry

787
00:45:06,800 --> 00:45:09,119
okay

788
00:45:10,480 --> 00:45:19,359
then we have finished the proof here

789
00:45:15,200 --> 00:45:22,240
see we define m1 as a final automaton

790
00:45:19,359 --> 00:45:24,400
and this is describe the five components

791
00:45:22,240 --> 00:45:26,560
the states of m1 is the collision

792
00:45:24,400 --> 00:45:29,599
product of m1 and m2

793
00:45:26,560 --> 00:45:31,839
and the alphabets we are we

794
00:45:29,599 --> 00:45:32,800
assume that they are the same for

795
00:45:31,839 --> 00:45:37,040
convenience

796
00:45:32,800 --> 00:45:37,040
and without loss of generality

797
00:45:37,359 --> 00:45:43,839
and for transition function we just

798
00:45:40,400 --> 00:45:46,960
create a new transition function as

799
00:45:43,839 --> 00:45:49,520
uh i should say uh look up

800
00:45:46,960 --> 00:45:51,680
of the two transition function delta one

801
00:45:49,520 --> 00:45:54,960
and delta two

802
00:45:51,680 --> 00:45:58,160
and combine them as the result of

803
00:45:54,960 --> 00:45:58,160
our transition function

804
00:45:58,839 --> 00:46:04,480
okay so you know in a way you can think

805
00:46:01,839 --> 00:46:07,760
of that you write the program here

806
00:46:04,480 --> 00:46:12,160
and you get your input here

807
00:46:07,760 --> 00:46:14,319
then you call others program and

808
00:46:12,160 --> 00:46:15,599
combine the final result as your own

809
00:46:14,319 --> 00:46:19,280
result

810
00:46:15,599 --> 00:46:22,720
and that's it okay then the start

811
00:46:19,280 --> 00:46:26,480
state is obviously

812
00:46:22,720 --> 00:46:30,000
this state and the final

813
00:46:26,480 --> 00:46:33,599
accept are that are those states

814
00:46:30,000 --> 00:46:36,800
which contains one

815
00:46:33,599 --> 00:46:42,800
at least one of the states of m1 or

816
00:46:36,800 --> 00:46:47,359
m2 as their accept states

817
00:46:42,800 --> 00:46:51,920
okay so

818
00:46:47,359 --> 00:46:55,359
we finished the proof of union

819
00:46:51,920 --> 00:46:59,760
but i have to give some notes here

820
00:46:55,359 --> 00:47:03,280
first this

821
00:46:59,760 --> 00:47:07,680
this proof is quite simple so

822
00:47:03,280 --> 00:47:09,680
we don't or in the textbook

823
00:47:07,680 --> 00:47:12,240
the authors don't provide the

824
00:47:09,680 --> 00:47:16,720
correctness proof

825
00:47:12,240 --> 00:47:18,560
to the construction of this machine okay

826
00:47:16,720 --> 00:47:19,839
because the construction of this machine

827
00:47:18,560 --> 00:47:23,839
is you know

828
00:47:19,839 --> 00:47:25,119
quite intuitive so we i think most of us

829
00:47:23,839 --> 00:47:28,640
can believe that

830
00:47:25,119 --> 00:47:31,680
this machine really recognize a1

831
00:47:28,640 --> 00:47:35,359
union with a2

832
00:47:31,680 --> 00:47:38,640
but for some more complicated

833
00:47:35,359 --> 00:47:41,280
operations we need to

834
00:47:38,640 --> 00:47:42,160
prove the construction the machine

835
00:47:41,280 --> 00:47:46,640
constructed

836
00:47:42,160 --> 00:47:46,640
by the construction pro process

837
00:47:46,800 --> 00:47:54,720
really can

838
00:47:50,480 --> 00:47:57,599
do what you want it to do

839
00:47:54,720 --> 00:47:58,240
okay we will see that kind of proof

840
00:47:57,599 --> 00:48:02,000
later

841
00:47:58,240 --> 00:48:02,400
but we don't have that here in a formal

842
00:48:02,000 --> 00:48:05,520
way

843
00:48:02,400 --> 00:48:08,160
we should have that here okay

844
00:48:05,520 --> 00:48:10,319
because the proof of theorem in

845
00:48:08,160 --> 00:48:13,520
mathematics

846
00:48:10,319 --> 00:48:16,880
is in some absolute sense

847
00:48:13,520 --> 00:48:17,280
you have to absolutely convince people

848
00:48:16,880 --> 00:48:19,839
that

849
00:48:17,280 --> 00:48:21,599
it is correct otherwise you cannot say

850
00:48:19,839 --> 00:48:25,520
it is correct

851
00:48:21,599 --> 00:48:25,520
that's the mathematical theorems

852
00:48:25,599 --> 00:48:30,640
the second note here will be

853
00:48:30,880 --> 00:48:37,040
that this proof

854
00:48:34,000 --> 00:48:40,559
is easily extend

855
00:48:37,040 --> 00:48:43,280
to intersection okay

856
00:48:40,559 --> 00:48:43,280
intersection

857
00:48:43,839 --> 00:48:49,440
how do we change the proof into proof

858
00:48:46,880 --> 00:48:50,079
the cultural property of intersection of

859
00:48:49,440 --> 00:48:54,240
two

860
00:48:50,079 --> 00:48:57,280
regular languages we only need to change

861
00:48:54,240 --> 00:48:59,920
this word to a

862
00:48:57,280 --> 00:48:59,920
and d

863
00:49:00,839 --> 00:49:07,200
okay so see

864
00:49:04,000 --> 00:49:09,520
if both machines accept the same string

865
00:49:07,200 --> 00:49:10,400
that string is in the intersection of

866
00:49:09,520 --> 00:49:13,440
the two

867
00:49:10,400 --> 00:49:13,440
regular languages

868
00:49:13,680 --> 00:49:19,440
so we construct another

869
00:49:16,720 --> 00:49:21,200
machine another final automaton to do

870
00:49:19,440 --> 00:49:24,400
the job

871
00:49:21,200 --> 00:49:27,520
okay so it's very easy and

872
00:49:24,400 --> 00:49:31,839
when you change to end

873
00:49:27,520 --> 00:49:31,839
that would be this

874
00:49:31,920 --> 00:49:38,160
okay so you see this is

875
00:49:35,359 --> 00:49:38,160
intersection

876
00:49:38,400 --> 00:49:42,800
and this one is union

877
00:49:43,200 --> 00:49:46,480
which is also over

878
00:49:47,040 --> 00:49:52,160
okay so that's the second note and the

879
00:49:50,400 --> 00:49:55,359
third note is

880
00:49:52,160 --> 00:49:57,520
you see we proved that

881
00:49:55,359 --> 00:49:58,480
the union of two regular languages is

882
00:49:57,520 --> 00:50:03,359
regular is

883
00:49:58,480 --> 00:50:06,480
a regular languages yeah so

884
00:50:03,359 --> 00:50:06,800
the closure property goes to the union

885
00:50:06,480 --> 00:50:09,920
of

886
00:50:06,800 --> 00:50:13,680
two regular languages can it

887
00:50:09,920 --> 00:50:15,920
extend to like union

888
00:50:13,680 --> 00:50:17,599
another regular language and the union

889
00:50:15,920 --> 00:50:22,960
another regular language

890
00:50:17,599 --> 00:50:26,640
and union infinite regular language

891
00:50:22,960 --> 00:50:30,400
for this proof the answer is no

892
00:50:26,640 --> 00:50:33,599
why because you see

893
00:50:30,400 --> 00:50:38,079
when we construct a new machine here

894
00:50:33,599 --> 00:50:43,440
we do a cartesian product so the number

895
00:50:38,079 --> 00:50:46,319
of the states will be the number

896
00:50:43,440 --> 00:50:46,319
of the two

897
00:50:46,800 --> 00:50:52,880
uh the multiplication of the two sets

898
00:50:49,839 --> 00:50:55,839
so if you in a way

899
00:50:52,880 --> 00:50:55,839
if you add more

900
00:50:55,920 --> 00:51:03,040
machines you cannot

901
00:50:59,920 --> 00:51:03,040
bunk the number

902
00:51:03,119 --> 00:51:09,920
finite why do we need to do that

903
00:51:06,480 --> 00:51:11,359
because the first definition of final

904
00:51:09,920 --> 00:51:14,400
automatic is that

905
00:51:11,359 --> 00:51:15,119
the states not the number of states is

906
00:51:14,400 --> 00:51:19,599
finite

907
00:51:15,119 --> 00:51:24,000
because q is a finite set of states

908
00:51:19,599 --> 00:51:27,520
okay so we cannot extend this proof

909
00:51:24,000 --> 00:51:27,520
to that kind of

910
00:51:27,839 --> 00:51:31,760
to the union of infinite regular

911
00:51:30,079 --> 00:51:34,800
languages

912
00:51:31,760 --> 00:51:34,800
but we can do that

913
00:51:35,680 --> 00:51:37,839
to

914
00:51:38,880 --> 00:51:44,640
finite regular languages

915
00:51:42,319 --> 00:51:44,640
sorry

916
00:51:45,920 --> 00:51:52,720
because when you wait when we do this

917
00:51:49,920 --> 00:51:56,240
the cartesian product of finite

918
00:51:52,720 --> 00:51:59,599
finite finite numbers will be finite

919
00:51:56,240 --> 00:52:02,319
so there's no problem here okay

920
00:51:59,599 --> 00:52:02,319
okay so

921
00:52:03,760 --> 00:52:07,200
we proved uh

922
00:52:07,599 --> 00:52:15,440
the first regular operations

923
00:52:11,440 --> 00:52:19,839
union so next time we want to prove

924
00:52:15,440 --> 00:52:19,839
concluding okay

