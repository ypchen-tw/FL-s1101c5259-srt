1
00:00:03,679 --> 00:00:07,839
let's go back to the goal of this course

2
00:00:08,080 --> 00:00:12,559
we talked about that the goal of this

3
00:00:11,759 --> 00:00:16,160
course

4
00:00:12,559 --> 00:00:20,480
is to discuss the limitations

5
00:00:16,160 --> 00:00:23,519
the capability of computations and

6
00:00:20,480 --> 00:00:27,760
the analogy we draw on

7
00:00:23,519 --> 00:00:27,760
the models is that we use

8
00:00:27,840 --> 00:00:34,480
languages we consider languages as

9
00:00:31,199 --> 00:00:38,559
problems and the strings

10
00:00:34,480 --> 00:00:42,239
in the language as problem instance

11
00:00:38,559 --> 00:00:44,160
in some problem and we use the

12
00:00:42,239 --> 00:00:48,640
computational model

13
00:00:44,160 --> 00:00:52,079
to handle or to solve the problem

14
00:00:48,640 --> 00:00:55,760
by accepting or not

15
00:00:52,079 --> 00:00:59,039
accepting strings that means

16
00:00:55,760 --> 00:01:02,399
if you have a problem and

17
00:00:59,039 --> 00:01:03,039
of which the answer is yes or no you can

18
00:01:02,399 --> 00:01:06,799
use

19
00:01:03,039 --> 00:01:09,840
you can directly connect to such a model

20
00:01:06,799 --> 00:01:13,040
so for example

21
00:01:09,840 --> 00:01:16,799
as i gave that

22
00:01:13,040 --> 00:01:19,920
if there is a dfa

23
00:01:16,799 --> 00:01:23,119
which can appropriately

24
00:01:19,920 --> 00:01:26,720
answer all the valid

25
00:01:23,119 --> 00:01:27,200
addition strings equations and we will

26
00:01:26,720 --> 00:01:30,320
think

27
00:01:27,200 --> 00:01:33,759
okay this kind of model can do addition

28
00:01:30,320 --> 00:01:37,280
or for that matter multiplication

29
00:01:33,759 --> 00:01:40,320
subtraction division same uh

30
00:01:37,280 --> 00:01:43,920
something like that so

31
00:01:40,320 --> 00:01:47,600
we already know that we just proved

32
00:01:43,920 --> 00:01:51,439
the equivalence of the four basic

33
00:01:47,600 --> 00:01:54,720
conditional models dfa and fa gnfa and

34
00:01:51,439 --> 00:01:58,240
regular expression

35
00:01:54,720 --> 00:02:01,040
if just if

36
00:01:58,240 --> 00:02:03,600
regular languages are all possible

37
00:02:01,040 --> 00:02:07,200
languages

38
00:02:03,600 --> 00:02:08,239
then we are we and we will be very happy

39
00:02:07,200 --> 00:02:11,039
about it but

40
00:02:08,239 --> 00:02:13,040
right because our dfa can solve all

41
00:02:11,039 --> 00:02:16,959
possible problems

42
00:02:13,040 --> 00:02:19,760
under such assumption or under the

43
00:02:16,959 --> 00:02:21,280
analogy we draw between problems and the

44
00:02:19,760 --> 00:02:25,280
languages

45
00:02:21,280 --> 00:02:29,599
right in this case you might think

46
00:02:25,280 --> 00:02:29,599
that's not possible because dfa

47
00:02:30,319 --> 00:02:34,160
determines the finite automata are

48
00:02:33,200 --> 00:02:37,840
obviously

49
00:02:34,160 --> 00:02:37,840
too simple

50
00:02:37,920 --> 00:02:42,640
so regular languages cannot be all

51
00:02:40,480 --> 00:02:46,080
possible languages

52
00:02:42,640 --> 00:02:49,040
well that's not wrong because we are

53
00:02:46,080 --> 00:02:51,280
as the title of this section non-regular

54
00:02:49,040 --> 00:02:56,000
languages

55
00:02:51,280 --> 00:02:56,000
implies that there are languages outside

56
00:02:56,480 --> 00:03:03,200
of regular languages right

57
00:03:00,000 --> 00:03:06,560
but the problem is how do you prove that

58
00:03:03,200 --> 00:03:10,000
such language exists

59
00:03:06,560 --> 00:03:12,959
right let's consider the example here

60
00:03:10,000 --> 00:03:13,680
for example there is a language b here

61
00:03:12,959 --> 00:03:19,280
which

62
00:03:13,680 --> 00:03:22,400
is defined as

63
00:03:19,280 --> 00:03:26,480
the same number of 0 and 1 and the 0

64
00:03:22,400 --> 00:03:29,680
is before ones okay

65
00:03:26,480 --> 00:03:31,360
so what are all the strings in the

66
00:03:29,680 --> 00:03:34,560
language

67
00:03:31,360 --> 00:03:38,159
is they are like epsilon when

68
00:03:34,560 --> 00:03:41,599
n equals 0 right then

69
00:03:38,159 --> 00:03:44,640
0 1 0 0

70
00:03:41,599 --> 00:03:49,840
1 1 0 0 0

71
00:03:44,640 --> 00:03:53,360
1 1 1 etc etc

72
00:03:49,840 --> 00:03:56,560
okay it's pretty easy to

73
00:03:53,360 --> 00:03:57,200
figure out or what what what kind of

74
00:03:56,560 --> 00:04:00,879
strings

75
00:03:57,200 --> 00:04:02,000
in this language let's consider this

76
00:04:00,879 --> 00:04:05,280
language that

77
00:04:02,000 --> 00:04:09,360
if you want to prove this language

78
00:04:05,280 --> 00:04:12,959
to be regular by definition we need to

79
00:04:09,360 --> 00:04:15,360
design a dfa to accept

80
00:04:12,959 --> 00:04:16,000
all the strings all the strings in the

81
00:04:15,360 --> 00:04:19,440
language

82
00:04:16,000 --> 00:04:22,479
and not accept all other strings

83
00:04:19,440 --> 00:04:25,919
right so

84
00:04:22,479 --> 00:04:29,280
what will will you do you might think

85
00:04:25,919 --> 00:04:31,759
okay i use some

86
00:04:29,280 --> 00:04:31,759
state

87
00:04:32,400 --> 00:04:36,320
and when it reads zero

88
00:04:37,040 --> 00:04:41,040
and it goes to more states so we use the

89
00:04:39,680 --> 00:04:45,280
states to count

90
00:04:41,040 --> 00:04:49,759
basically to count how many zeros

91
00:04:45,280 --> 00:04:52,639
and doing one bag right

92
00:04:49,759 --> 00:04:52,639
something like that

93
00:04:53,440 --> 00:04:58,320
but the problem is that how many states

94
00:04:55,919 --> 00:04:58,320
you need

95
00:04:59,680 --> 00:05:06,639
obviously you will quickly find that

96
00:05:03,120 --> 00:05:08,960
you will never have enough states for

97
00:05:06,639 --> 00:05:08,960
this

98
00:05:09,199 --> 00:05:14,960
right for example you say okay i have 1

99
00:05:12,000 --> 00:05:14,960
million state here

100
00:05:15,360 --> 00:05:22,960
i use 1 million state here fine

101
00:05:19,440 --> 00:05:26,160
but what if you have 0 like

102
00:05:22,960 --> 00:05:29,520
2 million and the 1 2 million

103
00:05:26,160 --> 00:05:32,479
such string you cannot handle by

104
00:05:29,520 --> 00:05:33,039
using only 1 million states even though

105
00:05:32,479 --> 00:05:36,320
it's

106
00:05:33,039 --> 00:05:37,520
the amount is huge but and of course

107
00:05:36,320 --> 00:05:41,440
it's finite

108
00:05:37,520 --> 00:05:44,320
and you will find that

109
00:05:41,440 --> 00:05:44,320
finite state

110
00:05:44,800 --> 00:05:50,000
don't seem to be able to handle such

111
00:05:47,520 --> 00:05:50,000
language

112
00:05:50,840 --> 00:05:57,759
and after a while you might think

113
00:05:53,759 --> 00:06:01,600
okay it might not be possible to desire

114
00:05:57,759 --> 00:06:05,360
a dfa to recognize this language

115
00:06:01,600 --> 00:06:08,639
so the language probably is not

116
00:06:05,360 --> 00:06:08,639
a regular language

117
00:06:08,960 --> 00:06:12,880
well that's correct but the arguments

118
00:06:11,520 --> 00:06:16,479
cannot

119
00:06:12,880 --> 00:06:20,080
cannot we cannot use such

120
00:06:16,479 --> 00:06:23,039
arguments to prove the existence of

121
00:06:20,080 --> 00:06:23,600
non-regular language or to prove the

122
00:06:23,039 --> 00:06:26,960
language

123
00:06:23,600 --> 00:06:30,000
b here is not regular

124
00:06:26,960 --> 00:06:33,120
because it it may be a you know

125
00:06:30,000 --> 00:06:36,160
a way of thinking but it's not

126
00:06:33,120 --> 00:06:40,000
valid mathematical argument

127
00:06:36,160 --> 00:06:40,720
over this proof we need something

128
00:06:40,000 --> 00:06:45,199
stronger

129
00:06:40,720 --> 00:06:48,479
we need something valid in logic

130
00:06:45,199 --> 00:06:54,160
so here we

131
00:06:48,479 --> 00:06:54,160
introduce pumping lemma

132
00:06:55,520 --> 00:07:02,400
we can use pumping lemma to prove

133
00:06:58,560 --> 00:07:06,479
some language to be non-regular

134
00:07:02,400 --> 00:07:10,720
okay we firstly we will uh

135
00:07:06,479 --> 00:07:14,479
introduce uh what is pompilema and

136
00:07:10,720 --> 00:07:17,360
present well close to a proof

137
00:07:14,479 --> 00:07:19,919
to prove that pumping nema is correct

138
00:07:17,360 --> 00:07:23,199
then we will use the pump element

139
00:07:19,919 --> 00:07:25,759
to prove some language to be non-regular

140
00:07:23,199 --> 00:07:27,599
and don't rem don't forget that pumping

141
00:07:25,759 --> 00:07:31,280
lemma is a

142
00:07:27,599 --> 00:07:34,960
necessary condition that means every

143
00:07:31,280 --> 00:07:38,319
regular language has such property

144
00:07:34,960 --> 00:07:39,039
so if some language does not have such a

145
00:07:38,319 --> 00:07:42,400
property

146
00:07:39,039 --> 00:07:45,440
it's not regular but

147
00:07:42,400 --> 00:07:48,639
the reverse is not valid that means

148
00:07:45,440 --> 00:07:49,440
if you can prove some language has the

149
00:07:48,639 --> 00:07:52,720
property

150
00:07:49,440 --> 00:07:56,080
described by the pumping lima

151
00:07:52,720 --> 00:07:59,599
that doesn't mean such a language

152
00:07:56,080 --> 00:08:04,639
is regular okay so

153
00:07:59,599 --> 00:08:07,280
it's a single direction criteria

154
00:08:04,639 --> 00:08:12,080
don't forget that that's very important

155
00:08:07,280 --> 00:08:16,080
okay so what is pumping lima

156
00:08:12,080 --> 00:08:19,440
hominema describes if a

157
00:08:16,080 --> 00:08:23,120
language a is a regular language

158
00:08:19,440 --> 00:08:27,360
then there is a number p

159
00:08:23,120 --> 00:08:29,840
we call it pumping length

160
00:08:27,360 --> 00:08:30,560
and the piece is basically a p is not

161
00:08:29,840 --> 00:08:34,399
unique

162
00:08:30,560 --> 00:08:36,640
okay but you got the number p

163
00:08:34,399 --> 00:08:36,640
and

164
00:08:37,680 --> 00:08:44,800
for the strings in a

165
00:08:41,760 --> 00:08:47,920
any strings

166
00:08:44,800 --> 00:08:51,680
in a longer

167
00:08:47,920 --> 00:08:51,680
or equal to p

168
00:08:52,720 --> 00:09:01,040
then such a string as long as it's

169
00:08:56,720 --> 00:09:04,640
long enough may be divided

170
00:09:01,040 --> 00:09:08,000
into three pieces okay keyword here

171
00:09:04,640 --> 00:09:11,200
is maybe divided so you

172
00:09:08,000 --> 00:09:14,720
don't know how to divide it but you know

173
00:09:11,200 --> 00:09:17,839
there is at least a way to divide

174
00:09:14,720 --> 00:09:21,200
s here into

175
00:09:17,839 --> 00:09:27,440
three pieces let's say x

176
00:09:21,200 --> 00:09:27,440
y z satisfying the three conditions here

177
00:09:27,839 --> 00:09:34,160
let's see second condition first

178
00:09:30,880 --> 00:09:39,760
the middle part the second part

179
00:09:34,160 --> 00:09:43,360
of the piece cannot be empty string

180
00:09:39,760 --> 00:09:46,880
and the first

181
00:09:43,360 --> 00:09:50,160
two parts together shorter

182
00:09:46,880 --> 00:09:53,680
or equal to p and

183
00:09:50,160 --> 00:09:56,320
under these conditions we

184
00:09:53,680 --> 00:09:56,320
know that

185
00:09:57,040 --> 00:10:03,440
you can either pull

186
00:10:00,399 --> 00:10:06,640
out the middle part or

187
00:10:03,440 --> 00:10:10,880
repeat the middle part

188
00:10:06,640 --> 00:10:15,760
for any possible

189
00:10:10,880 --> 00:10:19,519
times the resultant string

190
00:10:15,760 --> 00:10:22,880
will always be

191
00:10:19,519 --> 00:10:28,560
in a will always be in

192
00:10:22,880 --> 00:10:31,760
a2 okay so it's kind of

193
00:10:28,560 --> 00:10:34,000
complicated complicated statement but

194
00:10:31,760 --> 00:10:35,600
it's not that complicated actually so

195
00:10:34,000 --> 00:10:38,720
let's do it again

196
00:10:35,600 --> 00:10:42,240
so you have a language you have a

197
00:10:38,720 --> 00:10:46,000
regular language then

198
00:10:42,240 --> 00:10:49,360
if there must be a number p

199
00:10:46,000 --> 00:10:52,880
we call it pumping length where

200
00:10:49,360 --> 00:10:56,160
any string in a

201
00:10:52,880 --> 00:11:00,160
at least longer than p or

202
00:10:56,160 --> 00:11:03,839
equal the dense is equal to p

203
00:11:00,160 --> 00:11:06,320
such a string may be divided into three

204
00:11:03,839 --> 00:11:06,320
pieces

205
00:11:06,399 --> 00:11:14,160
satisfying these three conditions

206
00:11:11,040 --> 00:11:15,120
and according to the condition here you

207
00:11:14,160 --> 00:11:19,440
can understand

208
00:11:15,120 --> 00:11:20,000
why the middle piece cannot be empty

209
00:11:19,440 --> 00:11:23,279
string

210
00:11:20,000 --> 00:11:24,480
right because if the middle string can

211
00:11:23,279 --> 00:11:28,560
be empty string

212
00:11:24,480 --> 00:11:29,440
then there's it's nonsense to describe

213
00:11:28,560 --> 00:11:33,440
such a

214
00:11:29,440 --> 00:11:36,399
lemma because if y is empty

215
00:11:33,440 --> 00:11:36,959
string then it doesn't really matter

216
00:11:36,399 --> 00:11:42,160
right

217
00:11:36,959 --> 00:11:46,160
so y cannot be empty

218
00:11:42,160 --> 00:11:46,959
and pampilema tells us that any regular

219
00:11:46,160 --> 00:11:51,360
language

220
00:11:46,959 --> 00:11:54,480
have such properties

221
00:11:51,360 --> 00:11:56,639
okay have such properties so

222
00:11:54,480 --> 00:11:58,160
that means any regular languages you

223
00:11:56,639 --> 00:12:02,399
know there is a

224
00:11:58,160 --> 00:12:05,440
number p and any strings

225
00:12:02,399 --> 00:12:08,480
any strings in this language

226
00:12:05,440 --> 00:12:11,279
any strings in this language

227
00:12:08,480 --> 00:12:12,639
as long as it's long enough how long it

228
00:12:11,279 --> 00:12:15,839
is

229
00:12:12,639 --> 00:12:19,120
longer than or equal to p then

230
00:12:15,839 --> 00:12:22,160
the string there is a way to

231
00:12:19,120 --> 00:12:22,639
there is at least a way to divide such a

232
00:12:22,160 --> 00:12:26,240
string

233
00:12:22,639 --> 00:12:28,800
into p three pieces satisfying the three

234
00:12:26,240 --> 00:12:28,800
conditions

235
00:12:29,360 --> 00:12:37,680
okay so why regular language has

236
00:12:35,120 --> 00:12:39,680
why any regular language has such a

237
00:12:37,680 --> 00:12:42,160
property

238
00:12:39,680 --> 00:12:45,279
it's actually quite easy if you think of

239
00:12:42,160 --> 00:12:49,440
the definition of regular languages

240
00:12:45,279 --> 00:12:52,560
okay how do we define regular language

241
00:12:49,440 --> 00:12:55,760
we use dfa

242
00:12:52,560 --> 00:12:57,040
right and don't forget that the most one

243
00:12:55,760 --> 00:13:00,639
of the most important

244
00:12:57,040 --> 00:13:04,560
property of dfa is that there is only

245
00:13:00,639 --> 00:13:08,800
a finite number of states

246
00:13:04,560 --> 00:13:12,800
okay so imagine that

247
00:13:08,800 --> 00:13:12,800
for dfan here

248
00:13:13,760 --> 00:13:18,000
there is that's a

249
00:13:18,839 --> 00:13:24,959
uh

250
00:13:21,440 --> 00:13:28,160
end state okay there is totally

251
00:13:24,959 --> 00:13:31,200
n state then

252
00:13:28,160 --> 00:13:36,240
if you try to process a string

253
00:13:31,200 --> 00:13:36,240
for example length n right

254
00:13:36,320 --> 00:13:40,560
this string sorry

255
00:13:40,639 --> 00:13:48,240
this string s has

256
00:13:44,000 --> 00:13:52,800
length n then how many states

257
00:13:48,240 --> 00:13:56,720
will be stepped upon

258
00:13:52,800 --> 00:13:56,720
totally n plus one right

259
00:13:57,680 --> 00:14:04,639
so you have only end state

260
00:14:01,440 --> 00:14:08,560
and processing this string

261
00:14:04,639 --> 00:14:10,720
you need n plus one state

262
00:14:08,560 --> 00:14:12,720
so it's pretty straightforward that

263
00:14:10,720 --> 00:14:15,120
there must be duplicate

264
00:14:12,720 --> 00:14:16,959
states during the processing of the

265
00:14:15,120 --> 00:14:19,199
string

266
00:14:16,959 --> 00:14:19,199
right

267
00:14:20,320 --> 00:14:24,720
so the most straightforward thinking

268
00:14:22,720 --> 00:14:28,079
regarding

269
00:14:24,720 --> 00:14:28,079
pumping lemma is that

270
00:14:28,480 --> 00:14:35,040
given a dfa which

271
00:14:31,920 --> 00:14:38,160
represents a regular language right

272
00:14:35,040 --> 00:14:42,320
and for that dfa

273
00:14:38,160 --> 00:14:45,680
it has only a finite number

274
00:14:42,320 --> 00:14:50,000
of states

275
00:14:45,680 --> 00:14:53,440
and if there are strings

276
00:14:50,000 --> 00:14:56,880
longer or equal to

277
00:14:53,440 --> 00:15:01,040
the number of states in that

278
00:14:56,880 --> 00:15:04,480
language for that dfa to process

279
00:15:01,040 --> 00:15:08,639
such strings it requires

280
00:15:04,480 --> 00:15:08,639
duplicate states

281
00:15:09,920 --> 00:15:16,240
during the pro string processing

282
00:15:13,040 --> 00:15:20,880
so to visualize such a relationship

283
00:15:16,240 --> 00:15:23,519
you can think of a processing

284
00:15:20,880 --> 00:15:25,120
a string processing maybe like this

285
00:15:23,519 --> 00:15:29,440
start from

286
00:15:25,120 --> 00:15:32,560
q1 and after process

287
00:15:29,440 --> 00:15:33,279
the string the first part of string it

288
00:15:32,560 --> 00:15:36,720
reaches

289
00:15:33,279 --> 00:15:39,040
some state and then

290
00:15:36,720 --> 00:15:40,560
after processing the second part of the

291
00:15:39,040 --> 00:15:44,000
string it reach

292
00:15:40,560 --> 00:15:47,040
the duplicate states for example then

293
00:15:44,000 --> 00:15:52,079
final part of the string

294
00:15:47,040 --> 00:15:56,240
go to the state accepted

295
00:15:52,079 --> 00:16:00,720
okay so if a string

296
00:15:56,240 --> 00:16:00,720
is accepted in this fashion

297
00:16:00,880 --> 00:16:07,839
then you know that string

298
00:16:04,240 --> 00:16:11,680
xz must be accepted by

299
00:16:07,839 --> 00:16:14,880
exactly the same dfa right

300
00:16:11,680 --> 00:16:19,279
and the string x y

301
00:16:14,880 --> 00:16:22,560
y z must be

302
00:16:19,279 --> 00:16:26,800
accepted too right because you just

303
00:16:22,560 --> 00:16:29,560
go through this past again

304
00:16:26,800 --> 00:16:31,519
then you can go through this page

305
00:16:29,560 --> 00:16:35,519
indefinitely

306
00:16:31,519 --> 00:16:38,720
indefinite times so that's why

307
00:16:35,519 --> 00:16:41,839
for x

308
00:16:38,720 --> 00:16:45,839
y i z

309
00:16:41,839 --> 00:16:49,120
it must be in the language

310
00:16:45,839 --> 00:16:51,839
for i for each possible i

311
00:16:49,120 --> 00:16:51,839
right

312
00:16:53,440 --> 00:16:57,680
so that's why we have

313
00:16:57,759 --> 00:17:04,640
these conditions and

314
00:17:01,279 --> 00:17:08,400
that's why it is called pumping lemma

315
00:17:04,640 --> 00:17:12,160
because you pump

316
00:17:08,400 --> 00:17:12,160
you pump the second part

317
00:17:12,799 --> 00:17:16,880
you pump white into the string you pump

318
00:17:15,600 --> 00:17:21,679
the second wire

319
00:17:16,880 --> 00:17:25,439
third y fourth y you pump y

320
00:17:21,679 --> 00:17:28,480
into the string and the resultant string

321
00:17:25,439 --> 00:17:32,480
is still in that language

322
00:17:28,480 --> 00:17:35,840
it must be in because you just

323
00:17:32,480 --> 00:17:36,720
go back to the same states and for dfa

324
00:17:35,840 --> 00:17:40,720
don't forget that's

325
00:17:36,720 --> 00:17:43,760
dfa deterministic final automata

326
00:17:40,720 --> 00:17:47,520
so every state every step

327
00:17:43,760 --> 00:17:48,080
goes to some deterministic deterministic

328
00:17:47,520 --> 00:17:52,480
step

329
00:17:48,080 --> 00:17:56,160
step okay

330
00:17:52,480 --> 00:17:59,039
and why we have the third condition

331
00:17:56,160 --> 00:18:01,840
because the as long as the string is

332
00:17:59,039 --> 00:18:06,400
long enough

333
00:18:01,840 --> 00:18:09,919
the duplicate states must

334
00:18:06,400 --> 00:18:10,559
there are as long as the string is

335
00:18:09,919 --> 00:18:13,600
longer

336
00:18:10,559 --> 00:18:16,720
or equal to the number of the states

337
00:18:13,600 --> 00:18:17,520
there must be a duplicate state there it

338
00:18:16,720 --> 00:18:21,600
might be

339
00:18:17,520 --> 00:18:25,679
you know other place elsewhere

340
00:18:21,600 --> 00:18:29,840
but for the first duplication

341
00:18:25,679 --> 00:18:33,360
it must happen within

342
00:18:29,840 --> 00:18:36,640
the length of p

343
00:18:33,360 --> 00:18:40,480
which might be your the number of the

344
00:18:36,640 --> 00:18:40,480
states of that dfa

345
00:18:40,720 --> 00:18:47,840
okay so that's why we have

346
00:18:45,120 --> 00:18:48,720
that's exactly why we have uh pumping

347
00:18:47,840 --> 00:18:51,760
lemma

348
00:18:48,720 --> 00:18:55,280
we have pumping lemma for regular

349
00:18:51,760 --> 00:18:56,000
languages because any any regular

350
00:18:55,280 --> 00:18:59,520
language

351
00:18:56,000 --> 00:19:00,799
you can find some dfa and you just pick

352
00:18:59,520 --> 00:19:03,840
one dfa

353
00:19:00,799 --> 00:19:06,880
and the number of the states of that dfa

354
00:19:03,840 --> 00:19:08,480
becomes the pumping becomes the pumping

355
00:19:06,880 --> 00:19:12,000
length

356
00:19:08,480 --> 00:19:14,799
and you can know that

357
00:19:12,000 --> 00:19:14,799
any string

358
00:19:15,360 --> 00:19:20,480
equal the length of that string equal to

359
00:19:18,000 --> 00:19:23,679
p or

360
00:19:20,480 --> 00:19:26,240
greater than p such a string may be

361
00:19:23,679 --> 00:19:32,160
divided into three pieces

362
00:19:26,240 --> 00:19:32,160
which three sorry which three pieces

363
00:19:33,440 --> 00:19:38,960
from start state to the duplicate states

364
00:19:36,720 --> 00:19:40,640
from duplicate states back to the

365
00:19:38,960 --> 00:19:45,039
duplicate states

366
00:19:40,640 --> 00:19:45,039
and goes to the accept state

367
00:19:45,120 --> 00:19:50,720
okay so if the start state

368
00:19:48,799 --> 00:19:52,799
is the duplicate state then you don't

369
00:19:50,720 --> 00:19:56,400
have the first part

370
00:19:52,799 --> 00:19:59,520
if thus if the

371
00:19:56,400 --> 00:20:00,720
duplicate state is the accept state you

372
00:19:59,520 --> 00:20:03,440
don't have the

373
00:20:00,720 --> 00:20:03,440
third part

374
00:20:04,159 --> 00:20:10,640
but you you always need to have

375
00:20:08,320 --> 00:20:12,559
the second part otherwise it doesn't

376
00:20:10,640 --> 00:20:17,280
make sense

377
00:20:12,559 --> 00:20:17,280
okay so

378
00:20:17,760 --> 00:20:24,240
regular language has such a property

379
00:20:22,000 --> 00:20:24,240
okay

380
00:20:28,159 --> 00:20:34,880
and we can only use this

381
00:20:31,600 --> 00:20:37,120
lemma to prove some languages to be

382
00:20:34,880 --> 00:20:40,080
non-regular

383
00:20:37,120 --> 00:20:40,720
because if you prove that okay i have a

384
00:20:40,080 --> 00:20:44,480
language

385
00:20:40,720 --> 00:20:47,600
i let such a language have this property

386
00:20:44,480 --> 00:20:48,559
we cannot conclude that that language is

387
00:20:47,600 --> 00:20:53,200
regular

388
00:20:48,559 --> 00:20:56,240
because non-regular probably have

389
00:20:53,200 --> 00:20:59,520
have this property too

390
00:20:56,240 --> 00:21:03,039
so we can only use to disprove

391
00:20:59,520 --> 00:21:06,240
the regularity of a language okay

392
00:21:03,039 --> 00:21:09,760
then how to use it how to use it

393
00:21:06,240 --> 00:21:13,280
we need to do a contradiction because we

394
00:21:09,760 --> 00:21:13,280
want to prove a language

395
00:21:15,600 --> 00:21:22,880
has no such property

396
00:21:19,840 --> 00:21:23,679
we usually assume that language for

397
00:21:22,880 --> 00:21:28,640
example

398
00:21:23,679 --> 00:21:28,640
b here to be regular

399
00:21:28,720 --> 00:21:34,960
since b is regular right since b is

400
00:21:32,480 --> 00:21:34,960
regular

401
00:21:36,000 --> 00:21:44,880
we need to go back to the pump element

402
00:21:40,240 --> 00:21:50,080
we need to say that b has no

403
00:21:44,880 --> 00:21:53,520
such properties and how

404
00:21:50,080 --> 00:21:56,640
so we we need to prove that not

405
00:21:53,520 --> 00:21:59,919
every string in that language

406
00:21:56,640 --> 00:22:05,200
of length at least p

407
00:21:59,919 --> 00:22:08,159
has these property

408
00:22:05,200 --> 00:22:10,000
since the lemma describes any string in

409
00:22:08,159 --> 00:22:13,120
the language of length at least

410
00:22:10,000 --> 00:22:16,799
p has the following property we need to

411
00:22:13,120 --> 00:22:20,000
pick some special case

412
00:22:16,799 --> 00:22:23,120
okay because any string is a for

413
00:22:20,000 --> 00:22:26,559
all relationship we need

414
00:22:23,120 --> 00:22:29,520
to give a counter example

415
00:22:26,559 --> 00:22:31,280
but the difficult part is that the

416
00:22:29,520 --> 00:22:36,000
string

417
00:22:31,280 --> 00:22:40,080
may be divided into three pieces

418
00:22:36,000 --> 00:22:43,280
so there exists some way to divide it

419
00:22:40,080 --> 00:22:43,280
and how do you

420
00:22:43,360 --> 00:22:47,840
how do you contradict such

421
00:22:48,000 --> 00:22:54,559
situation you must prove that

422
00:22:51,280 --> 00:22:58,080
there is no way

423
00:22:54,559 --> 00:23:00,880
to divide the string into three pieces

424
00:22:58,080 --> 00:23:01,600
with the following conditions you must

425
00:23:00,880 --> 00:23:04,880
prove that

426
00:23:01,600 --> 00:23:05,520
that's you know slightly well actually

427
00:23:04,880 --> 00:23:09,039
sometimes

428
00:23:05,520 --> 00:23:13,600
quite difficult you have to prove

429
00:23:09,039 --> 00:23:17,600
there is no way to divide that string

430
00:23:13,600 --> 00:23:17,600
satisfying the three conditions

431
00:23:18,320 --> 00:23:25,440
okay so what we usually do

432
00:23:22,240 --> 00:23:25,440
is to

433
00:23:25,840 --> 00:23:34,000
assume that one

434
00:23:29,120 --> 00:23:38,080
or two conditions are satisfied

435
00:23:34,000 --> 00:23:41,200
in that case there is no way to satisfy

436
00:23:38,080 --> 00:23:44,320
this condition okay

437
00:23:41,200 --> 00:23:47,120
and if you want to prove something

438
00:23:44,320 --> 00:23:50,720
if you want to prove there is no way to

439
00:23:47,120 --> 00:23:53,760
satisfy the first condition well

440
00:23:50,720 --> 00:23:56,880
first condition is for all

441
00:23:53,760 --> 00:24:00,880
stuff for each i

442
00:23:56,880 --> 00:24:04,080
for all so you need to pick some

443
00:24:00,880 --> 00:24:07,600
counter example here to prove that

444
00:24:04,080 --> 00:24:10,960
there's no way okay

445
00:24:07,600 --> 00:24:14,400
so let's

446
00:24:10,960 --> 00:24:18,720
uh see the example of the language b

447
00:24:14,400 --> 00:24:22,720
in the beginning of this section okay

448
00:24:18,720 --> 00:24:26,720
so let me be the language we just

449
00:24:22,720 --> 00:24:30,840
talked about okay here

450
00:24:26,720 --> 00:24:33,919
we want to use pumping lemma to prove b

451
00:24:30,840 --> 00:24:37,600
here is not regular

452
00:24:33,919 --> 00:24:41,279
by contradiction so firstly we assume

453
00:24:37,600 --> 00:24:44,640
b is regular okay we assume b is like

454
00:24:41,279 --> 00:24:49,279
regular and since b is regular

455
00:24:44,640 --> 00:24:52,480
there is a pumping pumping length here

456
00:24:49,279 --> 00:24:55,440
that say p we don't know what p is

457
00:24:52,480 --> 00:24:58,080
but you know there is a number p playing

458
00:24:55,440 --> 00:25:01,200
such a row

459
00:24:58,080 --> 00:25:04,799
then by pumping them up

460
00:25:01,200 --> 00:25:08,880
any languages longer than or equal to p

461
00:25:04,799 --> 00:25:12,000
has that property now we need to choose

462
00:25:08,880 --> 00:25:15,760
a counter example say that this

463
00:25:12,000 --> 00:25:17,039
string doesn't satisfy those properties

464
00:25:15,760 --> 00:25:20,080
those conditions

465
00:25:17,039 --> 00:25:24,159
okay so

466
00:25:20,080 --> 00:25:27,600
which string should we pick here

467
00:25:24,159 --> 00:25:31,039
select here as the contour example

468
00:25:27,600 --> 00:25:34,720
choose zero p

469
00:25:31,039 --> 00:25:37,919
one p what is zero p one p

470
00:25:34,720 --> 00:25:41,039
that means the string is

471
00:25:37,919 --> 00:25:44,960
zero you have zero

472
00:25:41,039 --> 00:25:48,400
and you have p zeros

473
00:25:44,960 --> 00:25:51,200
and then p ones okay

474
00:25:48,400 --> 00:25:53,200
so we choose this string and how long it

475
00:25:51,200 --> 00:25:58,559
is

476
00:25:53,200 --> 00:26:02,159
so one zero p 1 p the length will be 2p

477
00:25:58,559 --> 00:26:02,159
and of course 2p

478
00:26:03,440 --> 00:26:10,559
greater than or equal to p because

479
00:26:06,720 --> 00:26:13,679
without the loss of generality p is not

480
00:26:10,559 --> 00:26:16,720
0 and also not

481
00:26:13,679 --> 00:26:17,919
negative right it must be greater than 1

482
00:26:16,720 --> 00:26:20,240
or something because

483
00:26:17,919 --> 00:26:22,640
you know basically it's the number of

484
00:26:20,240 --> 00:26:22,640
states

485
00:26:22,840 --> 00:26:28,960
so if

486
00:26:25,679 --> 00:26:33,440
b is really regular such

487
00:26:28,960 --> 00:26:36,840
such string s must be divided by

488
00:26:33,440 --> 00:26:38,159
uh in some way to satisfy the three

489
00:26:36,840 --> 00:26:42,799
conditions

490
00:26:38,159 --> 00:26:43,440
right so by pumping they might guarantee

491
00:26:42,799 --> 00:26:46,960
that

492
00:26:43,440 --> 00:26:50,640
there is a way to divide

493
00:26:46,960 --> 00:26:53,279
s into three pieces

494
00:26:50,640 --> 00:26:54,240
but we want to show it's not possible

495
00:26:53,279 --> 00:26:58,960
there is no

496
00:26:54,240 --> 00:27:02,559
way to do that so we need to

497
00:26:58,960 --> 00:27:02,559
how do we prove that

498
00:27:04,840 --> 00:27:09,520
firstly

499
00:27:06,159 --> 00:27:12,640
we can we know that the length

500
00:27:09,520 --> 00:27:15,679
of y the second part right

501
00:27:12,640 --> 00:27:19,520
cannot be zero

502
00:27:15,679 --> 00:27:24,480
that means y cannot be empty string

503
00:27:19,520 --> 00:27:27,919
so consider string as here

504
00:27:24,480 --> 00:27:31,039
where can y go if you if there is

505
00:27:27,919 --> 00:27:34,480
some way to divide it s

506
00:27:31,039 --> 00:27:37,919
and the middle pieces the second pieces

507
00:27:34,480 --> 00:27:40,799
is not empty so there is only

508
00:27:37,919 --> 00:27:41,360
three possibilities right we don't know

509
00:27:40,799 --> 00:27:44,399
how long

510
00:27:41,360 --> 00:27:47,440
y is but we know it's not zero

511
00:27:44,399 --> 00:27:50,720
and given that

512
00:27:47,440 --> 00:27:54,960
situation we know that y is

513
00:27:50,720 --> 00:27:54,960
either in this region

514
00:27:55,120 --> 00:28:02,480
or in this region

515
00:27:58,320 --> 00:28:04,640
or in this region right

516
00:28:02,480 --> 00:28:07,120
there is no other possibilities the

517
00:28:04,640 --> 00:28:11,520
three possibilities

518
00:28:07,120 --> 00:28:15,200
are everything

519
00:28:11,520 --> 00:28:19,120
you have a noun empty y so either y

520
00:28:15,200 --> 00:28:23,120
contains only zero

521
00:28:19,120 --> 00:28:26,240
or y contains only one

522
00:28:23,120 --> 00:28:30,000
or y contains both

523
00:28:26,240 --> 00:28:33,279
zero and ones

524
00:28:30,000 --> 00:28:37,760
right all possibilities are here

525
00:28:33,279 --> 00:28:41,200
let's say if y contains only zeros

526
00:28:37,760 --> 00:28:45,039
then apparently let's say

527
00:28:41,200 --> 00:28:48,720
string x z

528
00:28:45,039 --> 00:28:52,159
we make i we make i here

529
00:28:48,720 --> 00:28:55,039
zero xd is not

530
00:28:52,159 --> 00:28:55,440
in the language right because you have

531
00:28:55,039 --> 00:28:59,279
more

532
00:28:55,440 --> 00:29:03,200
one more ones than zeros

533
00:28:59,279 --> 00:29:06,720
or let's say this result

534
00:29:03,200 --> 00:29:10,080
x y y z

535
00:29:06,720 --> 00:29:13,279
not in b either because

536
00:29:10,080 --> 00:29:14,480
you have more zeros than ones then the

537
00:29:13,279 --> 00:29:18,159
resultant string

538
00:29:14,480 --> 00:29:21,440
is not in b okay so it's not

539
00:29:18,159 --> 00:29:24,640
possible that y contains only

540
00:29:21,440 --> 00:29:28,080
zeros and the same

541
00:29:24,640 --> 00:29:29,200
argument goes to content only containing

542
00:29:28,080 --> 00:29:31,760
only once

543
00:29:29,200 --> 00:29:32,399
right saying exactly same arguments

544
00:29:31,760 --> 00:29:35,520
because

545
00:29:32,399 --> 00:29:36,159
if you get rid of y then you have fewer

546
00:29:35,520 --> 00:29:38,799
ones

547
00:29:36,159 --> 00:29:39,760
if you duplicate y then you have more

548
00:29:38,799 --> 00:29:42,720
ones

549
00:29:39,760 --> 00:29:43,120
then either way the resultant string is

550
00:29:42,720 --> 00:29:46,320
not

551
00:29:43,120 --> 00:29:50,000
in the original language

552
00:29:46,320 --> 00:29:55,840
so it leaves the final possibility that

553
00:29:50,000 --> 00:29:55,840
you have y sorry the y have

554
00:29:56,640 --> 00:30:03,919
the symbols y have only

555
00:30:00,799 --> 00:30:04,880
uh not only zero or one it both contain

556
00:30:03,919 --> 00:30:09,679
both

557
00:30:04,880 --> 00:30:12,880
so both zeros and ones

558
00:30:09,679 --> 00:30:16,159
so in this case you know that

559
00:30:12,880 --> 00:30:19,600
it is possible xz is still in b

560
00:30:16,159 --> 00:30:23,120
right if y has same number of

561
00:30:19,600 --> 00:30:26,559
zeros and ones but the string

562
00:30:23,120 --> 00:30:30,399
x y y z here

563
00:30:26,559 --> 00:30:31,520
is not in b although it may contain the

564
00:30:30,399 --> 00:30:34,559
same number of

565
00:30:31,520 --> 00:30:37,760
zeros and ones the four the form

566
00:30:34,559 --> 00:30:40,880
the format is invalid

567
00:30:37,760 --> 00:30:44,640
why because you will have 0 0

568
00:30:40,880 --> 00:30:48,399
0 sum 0 1 1

569
00:30:44,640 --> 00:30:51,840
and then what 0 0 0

570
00:30:48,399 --> 00:30:55,039
and then 1

571
00:30:51,840 --> 00:30:55,440
because you repeat y and y is something

572
00:30:55,039 --> 00:30:59,039
like

573
00:30:55,440 --> 00:31:01,840
0 0 1 1 1.

574
00:30:59,039 --> 00:31:02,960
so you repeat this part of the string

575
00:31:01,840 --> 00:31:06,720
again

576
00:31:02,960 --> 00:31:08,399
and 0 here one here you have something

577
00:31:06,720 --> 00:31:12,000
like

578
00:31:08,399 --> 00:31:15,039
x y y z

579
00:31:12,000 --> 00:31:19,120
will be like this and this string

580
00:31:15,039 --> 00:31:22,720
is not in b

581
00:31:19,120 --> 00:31:27,600
okay then we know that

582
00:31:22,720 --> 00:31:27,600
there is no way absolutely no way

583
00:31:27,679 --> 00:31:30,880
to divide

584
00:31:30,960 --> 00:31:36,720
zero p one p this counter example we

585
00:31:34,320 --> 00:31:40,720
choose

586
00:31:36,720 --> 00:31:43,760
satisfying the three required conditions

587
00:31:40,720 --> 00:31:47,360
by the pumping lemma so

588
00:31:43,760 --> 00:31:51,519
that's a contradiction and

589
00:31:47,360 --> 00:31:55,039
what's wrong with it the

590
00:31:51,519 --> 00:31:58,080
error source comes from we assume that

591
00:31:55,039 --> 00:32:00,640
b is regular okay

592
00:31:58,080 --> 00:32:02,080
so the conclusion is that b is not

593
00:32:00,640 --> 00:32:05,679
regular

594
00:32:02,080 --> 00:32:10,159
because if b is regular

595
00:32:05,679 --> 00:32:10,159
we will have contradiction

596
00:32:10,399 --> 00:32:16,960
okay as long as long as we assume that

597
00:32:13,760 --> 00:32:20,559
b is regular the contradiction

598
00:32:16,960 --> 00:32:23,679
is unavoidable so b is not regular

599
00:32:20,559 --> 00:32:27,120
so that's how we use pumping lemma and

600
00:32:23,679 --> 00:32:30,960
you can go through

601
00:32:27,120 --> 00:32:36,159
you can go through the process

602
00:32:30,960 --> 00:32:36,159
like here that's like described here

603
00:32:36,320 --> 00:32:42,640
we assume some language is regular

604
00:32:40,080 --> 00:32:43,760
and we know by pumping lemma there is a

605
00:32:42,640 --> 00:32:46,799
p here

606
00:32:43,760 --> 00:32:50,559
and for any string

607
00:32:46,799 --> 00:32:54,080
as long as it's long enough it will be

608
00:32:50,559 --> 00:32:57,840
it can be must be pumped

609
00:32:54,080 --> 00:32:58,640
so we found we try to find a particular

610
00:32:57,840 --> 00:33:02,000
string

611
00:32:58,640 --> 00:33:04,880
as the counter example

612
00:33:02,000 --> 00:33:06,159
and the only requirement for this

613
00:33:04,880 --> 00:33:09,200
counter example is that

614
00:33:06,159 --> 00:33:12,159
it's long enough and

615
00:33:09,200 --> 00:33:12,960
usually it's you know kind of difficult

616
00:33:12,159 --> 00:33:16,080
to

617
00:33:12,960 --> 00:33:18,240
think of figure out a good counter

618
00:33:16,080 --> 00:33:21,519
example for you to

619
00:33:18,240 --> 00:33:23,600
finish the whole proof it's the

620
00:33:21,519 --> 00:33:24,720
difficult part one of the difficult

621
00:33:23,600 --> 00:33:28,240
parts

622
00:33:24,720 --> 00:33:32,080
anyway after you pick an appropriate

623
00:33:28,240 --> 00:33:32,080
counter example we need to

624
00:33:32,240 --> 00:33:35,840
describe that such

625
00:33:36,159 --> 00:33:42,159
string cannot be pumped as described

626
00:33:39,760 --> 00:33:42,799
then we know the contradiction is

627
00:33:42,159 --> 00:33:46,480
obtained

628
00:33:42,799 --> 00:33:49,840
then that language is not regular

629
00:33:46,480 --> 00:33:53,840
okay so let's go back

630
00:33:49,840 --> 00:33:53,840
to this example

631
00:33:54,159 --> 00:33:57,279
and remember that there are three

632
00:33:56,240 --> 00:34:00,480
conditions

633
00:33:57,279 --> 00:34:03,360
okay so by

634
00:34:00,480 --> 00:34:04,840
appropriately use the conditions we can

635
00:34:03,360 --> 00:34:08,320
make the proof

636
00:34:04,840 --> 00:34:11,359
slightly simpler

637
00:34:08,320 --> 00:34:13,520
so let's assume b

638
00:34:11,359 --> 00:34:16,320
is regular here let's assume b is

639
00:34:13,520 --> 00:34:16,320
regular here

640
00:34:18,240 --> 00:34:25,839
we choose the

641
00:34:21,679 --> 00:34:29,359
counter example candidate zero p one p

642
00:34:25,839 --> 00:34:32,639
so it's the same that we have p zeros

643
00:34:29,359 --> 00:34:37,200
and the p ones right

644
00:34:32,639 --> 00:34:41,520
and we know that the third condition

645
00:34:37,200 --> 00:34:41,520
would be x y

646
00:34:42,399 --> 00:34:46,720
shorter or equal to p because we explain

647
00:34:45,760 --> 00:34:50,399
that

648
00:34:46,720 --> 00:34:53,679
in the first duplicate states must be

649
00:34:50,399 --> 00:34:56,399
happened you know when

650
00:34:53,679 --> 00:34:58,880
the string the length of the string is

651
00:34:56,399 --> 00:35:02,079
close to p

652
00:34:58,880 --> 00:35:05,680
since we

653
00:35:02,079 --> 00:35:08,720
need to satisfy the third condition here

654
00:35:05,680 --> 00:35:12,480
that means y can

655
00:35:08,720 --> 00:35:17,040
only in our example here

656
00:35:12,480 --> 00:35:21,280
y can only exist

657
00:35:17,040 --> 00:35:24,400
in this part right

658
00:35:21,280 --> 00:35:27,440
y can only exist in this part

659
00:35:24,400 --> 00:35:30,880
we don't even need to analyze the

660
00:35:27,440 --> 00:35:34,560
three the three possibilities

661
00:35:30,880 --> 00:35:37,760
we just need to use y

662
00:35:34,560 --> 00:35:41,760
noun zero sorry non-empty

663
00:35:37,760 --> 00:35:46,320
and x y within

664
00:35:41,760 --> 00:35:49,839
the first p simple symbols so y must be

665
00:35:46,320 --> 00:35:54,400
here and then you know that

666
00:35:49,839 --> 00:35:57,040
y contains only zeros if

667
00:35:54,400 --> 00:35:58,000
we need to satisfy the three condition

668
00:35:57,040 --> 00:36:00,880
the second one

669
00:35:58,000 --> 00:36:00,880
the third one

670
00:36:01,040 --> 00:36:03,760
under the

671
00:36:04,079 --> 00:36:09,839
condition that three

672
00:36:07,440 --> 00:36:11,760
the second and third condition are

673
00:36:09,839 --> 00:36:16,560
satisfied

674
00:36:11,760 --> 00:36:16,560
there is no way to divide

675
00:36:18,160 --> 00:36:26,000
s into three pieces also satisfying

676
00:36:22,480 --> 00:36:30,240
the first condition because

677
00:36:26,000 --> 00:36:33,520
given that y is within

678
00:36:30,240 --> 00:36:33,520
the part of zeros

679
00:36:34,320 --> 00:36:41,040
any string

680
00:36:37,520 --> 00:36:45,280
for i on equal to

681
00:36:41,040 --> 00:36:45,280
1 is not in b

682
00:36:52,839 --> 00:36:55,839
right

683
00:36:59,760 --> 00:37:03,119
so we have proof that

684
00:37:03,200 --> 00:37:10,000
b here

685
00:37:06,800 --> 00:37:14,560
b here is not

686
00:37:10,000 --> 00:37:17,839
a regular language okay

687
00:37:14,560 --> 00:37:21,200
since b

688
00:37:17,839 --> 00:37:24,880
is not a regular language

689
00:37:21,200 --> 00:37:28,480
that means well it uh

690
00:37:24,880 --> 00:37:31,440
it indicates that uh

691
00:37:28,480 --> 00:37:32,720
the the existence of non-regular

692
00:37:31,440 --> 00:37:36,240
language

693
00:37:32,720 --> 00:37:40,240
simply tells us that

694
00:37:36,240 --> 00:37:43,680
let's say if you have alphabet

695
00:37:40,240 --> 00:37:47,119
right then we use

696
00:37:43,680 --> 00:37:50,720
sigma star to represent

697
00:37:47,119 --> 00:37:54,560
all possible strings composed

698
00:37:50,720 --> 00:37:54,560
by sigma

699
00:37:55,119 --> 00:38:02,720
so sigma star is a set

700
00:37:58,640 --> 00:38:02,720
of strings and

701
00:38:03,520 --> 00:38:07,520
it is the state set of all possible

702
00:38:06,960 --> 00:38:11,760
strings

703
00:38:07,520 --> 00:38:15,839
composed by sigma and what is language

704
00:38:11,760 --> 00:38:18,880
all possible language are

705
00:38:15,839 --> 00:38:22,720
all possible subset of

706
00:38:18,880 --> 00:38:26,240
sigma star right so in a way

707
00:38:22,720 --> 00:38:27,359
we can you know denote all possible

708
00:38:26,240 --> 00:38:30,640
strings like

709
00:38:27,359 --> 00:38:33,599
two to the sigma star or some

710
00:38:30,640 --> 00:38:35,280
textbook use this notation or this

711
00:38:33,599 --> 00:38:40,400
notation

712
00:38:35,280 --> 00:38:40,400
okay then

713
00:38:41,920 --> 00:38:49,119
we we was hope we were hoping that

714
00:38:46,880 --> 00:38:50,960
regular languages are all possible

715
00:38:49,119 --> 00:38:54,960
languages

716
00:38:50,960 --> 00:38:55,280
because in that case we can use dfa to

717
00:38:54,960 --> 00:38:59,040
do

718
00:38:55,280 --> 00:38:59,839
any possible problems right but now we

719
00:38:59,040 --> 00:39:03,440
know that's

720
00:38:59,839 --> 00:39:06,960
okay at least this language

721
00:39:03,440 --> 00:39:12,400
is not regular that means

722
00:39:06,960 --> 00:39:15,599
if we have if we have all possible

723
00:39:12,400 --> 00:39:18,640
language here regular language

724
00:39:15,599 --> 00:39:22,560
is just some of them because

725
00:39:18,640 --> 00:39:25,760
at least b is outside

726
00:39:22,560 --> 00:39:25,760
of regular language

727
00:39:26,839 --> 00:39:32,720
right so

728
00:39:29,520 --> 00:39:35,839
it goes back to

729
00:39:32,720 --> 00:39:40,839
uh the need to discuss

730
00:39:35,839 --> 00:39:43,119
the closure property of regular

731
00:39:40,839 --> 00:39:46,240
languages

732
00:39:43,119 --> 00:39:47,359
we have discussed crucial property of

733
00:39:46,240 --> 00:39:51,040
regular language

734
00:39:47,359 --> 00:39:54,160
on three operations right

735
00:39:51,040 --> 00:39:57,920
uh first one is union

736
00:39:54,160 --> 00:39:59,119
we prove that the class of regular

737
00:39:57,920 --> 00:40:02,400
languages

738
00:39:59,119 --> 00:40:05,119
is closed under the union

739
00:40:02,400 --> 00:40:06,400
operation and also concatenation

740
00:40:05,119 --> 00:40:10,079
concatenation

741
00:40:06,400 --> 00:40:13,680
and also the star operation

742
00:40:10,079 --> 00:40:16,079
so now we know that sadly

743
00:40:13,680 --> 00:40:17,119
regular languages are not all possible

744
00:40:16,079 --> 00:40:21,119
languages

745
00:40:17,119 --> 00:40:24,560
see if let's say if regular languages

746
00:40:21,119 --> 00:40:26,720
are all possible languages

747
00:40:24,560 --> 00:40:28,319
then you don't need to you know really

748
00:40:26,720 --> 00:40:32,160
talk about

749
00:40:28,319 --> 00:40:35,359
closure property because all possible

750
00:40:32,160 --> 00:40:39,599
set operations all possible

751
00:40:35,359 --> 00:40:42,720
string operations are closed

752
00:40:39,599 --> 00:40:46,720
right regular languages will be closed

753
00:40:42,720 --> 00:40:47,680
under all those common or specific

754
00:40:46,720 --> 00:40:50,800
whatever

755
00:40:47,680 --> 00:40:54,160
operations because all

756
00:40:50,800 --> 00:40:56,880
languages are regular but

757
00:40:54,160 --> 00:40:57,839
now we know that it's not indicate it's

758
00:40:56,880 --> 00:41:01,440
not the case

759
00:40:57,839 --> 00:41:04,480
because at least one language here

760
00:41:01,440 --> 00:41:08,720
is outside of regular language so

761
00:41:04,480 --> 00:41:13,200
regular language the class of like

762
00:41:08,720 --> 00:41:16,560
the cause of regular language is not all

763
00:41:13,200 --> 00:41:20,000
then we need to discuss okay so

764
00:41:16,560 --> 00:41:24,079
what operations we all have

765
00:41:20,000 --> 00:41:28,960
closure properties on regular languages

766
00:41:24,079 --> 00:41:28,960
after knowing that we know we we can

767
00:41:29,520 --> 00:41:32,960
more appropriately handle regular

768
00:41:31,760 --> 00:41:35,440
languages

769
00:41:32,960 --> 00:41:36,240
because we know that okay you have two

770
00:41:35,440 --> 00:41:39,359
or three

771
00:41:36,240 --> 00:41:41,440
regular languages and go through which

772
00:41:39,359 --> 00:41:42,480
operations you still get regular

773
00:41:41,440 --> 00:41:45,920
languages

774
00:41:42,480 --> 00:41:49,839
you still get something that a dfa

775
00:41:45,920 --> 00:41:49,839
or nfa can recognize

776
00:41:50,000 --> 00:41:53,440
okay so

777
00:41:54,000 --> 00:42:04,000
we will be discussing closure property

778
00:41:58,720 --> 00:42:04,000
next time you

