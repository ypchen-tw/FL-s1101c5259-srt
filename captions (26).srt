1
00:00:00,960 --> 00:00:07,759
in chapter 3 we introduced and defined

2
00:00:04,160 --> 00:00:09,360
two machines and then in chapter 4

3
00:00:07,759 --> 00:00:10,960
we

4
00:00:09,360 --> 00:00:14,080
mainly discussed

5
00:00:10,960 --> 00:00:14,880
decidability of languages

6
00:00:14,080 --> 00:00:18,160
right

7
00:00:14,880 --> 00:00:19,439
and also we introduced the

8
00:00:18,160 --> 00:00:22,080
relationship

9
00:00:19,439 --> 00:00:24,480
among classes of languages

10
00:00:22,080 --> 00:00:25,880
and as as shown

11
00:00:24,480 --> 00:00:29,439
in figure

12
00:00:25,880 --> 00:00:30,800
4.10 and that's probably about what we

13
00:00:29,439 --> 00:00:33,200
were talking

14
00:00:30,800 --> 00:00:34,160
in this semester will be covered by this

15
00:00:33,200 --> 00:00:35,440
course

16
00:00:34,160 --> 00:00:36,880
there are

17
00:00:35,440 --> 00:00:40,480
actually more

18
00:00:36,880 --> 00:00:43,600
uh classes of languages and their higher

19
00:00:40,480 --> 00:00:47,200
hierarchy is more complicated but we

20
00:00:43,600 --> 00:00:50,239
will not cover that in the semester

21
00:00:47,200 --> 00:00:52,000
and in this chapter chapter 5 we will be

22
00:00:50,239 --> 00:00:54,000
talking about

23
00:00:52,000 --> 00:00:55,440
reducibility

24
00:00:54,000 --> 00:00:57,760
and

25
00:00:55,440 --> 00:01:00,559
let me put it first

26
00:00:57,760 --> 00:01:02,800
when we talk about reducibility

27
00:01:00,559 --> 00:01:05,040
we are not talking about

28
00:01:02,800 --> 00:01:07,280
solving problems

29
00:01:05,040 --> 00:01:11,280
we will not

30
00:01:07,280 --> 00:01:13,920
propose solutions to problems

31
00:01:11,280 --> 00:01:16,479
or in train machine terminology

32
00:01:13,920 --> 00:01:21,040
we will not propose decider or

33
00:01:16,479 --> 00:01:21,040
recognizer two languages

34
00:01:21,280 --> 00:01:28,159
and what is reducibility reducibility is

35
00:01:24,320 --> 00:01:31,280
about using a solution

36
00:01:28,159 --> 00:01:31,280
to some problem

37
00:01:31,520 --> 00:01:35,280
to solve

38
00:01:33,360 --> 00:01:36,640
another problem

39
00:01:35,280 --> 00:01:37,520
okay

40
00:01:36,640 --> 00:01:40,560
so

41
00:01:37,520 --> 00:01:42,880
let's see the description here

42
00:01:40,560 --> 00:01:46,560
if problem a

43
00:01:42,880 --> 00:01:46,560
reduces to problem b

44
00:01:46,880 --> 00:01:52,799
we can use solution to b

45
00:01:50,479 --> 00:01:56,079
to solve a

46
00:01:52,799 --> 00:01:57,840
okay so imagine that you have a problem

47
00:01:56,079 --> 00:02:00,159
a

48
00:01:57,840 --> 00:02:04,560
and you have a problem b

49
00:02:00,159 --> 00:02:06,560
and you already know some solution to b

50
00:02:04,560 --> 00:02:07,360
that means you can solve b you have a

51
00:02:06,560 --> 00:02:11,039
way

52
00:02:07,360 --> 00:02:12,560
a procedure or something else to solve b

53
00:02:11,039 --> 00:02:15,760
and

54
00:02:12,560 --> 00:02:18,400
if you can use that solution to solve a

55
00:02:15,760 --> 00:02:18,400
we said

56
00:02:18,720 --> 00:02:23,760
we will say that

57
00:02:21,280 --> 00:02:26,319
problem a reduces

58
00:02:23,760 --> 00:02:27,440
to problem b

59
00:02:26,319 --> 00:02:29,680
okay

60
00:02:27,440 --> 00:02:31,760
and most importantly

61
00:02:29,680 --> 00:02:34,319
reducibility says

62
00:02:31,760 --> 00:02:39,280
nothing

63
00:02:34,319 --> 00:02:39,280
about solving a or b alone

64
00:02:39,599 --> 00:02:42,879
okay that's very important

65
00:02:41,760 --> 00:02:44,959
because

66
00:02:42,879 --> 00:02:46,879
if you

67
00:02:44,959 --> 00:02:49,519
want to solve

68
00:02:46,879 --> 00:02:51,519
let's say a or b alone

69
00:02:49,519 --> 00:02:53,599
you'll miss the point of root of

70
00:02:51,519 --> 00:02:56,560
reducibility

71
00:02:53,599 --> 00:02:56,560
and also that

72
00:02:59,120 --> 00:03:05,920
don't

73
00:03:01,440 --> 00:03:05,920
don't consider the word reduce

74
00:03:06,959 --> 00:03:10,720
make problem a

75
00:03:09,200 --> 00:03:11,440
easier

76
00:03:10,720 --> 00:03:13,280
no

77
00:03:11,440 --> 00:03:15,840
it's not like that

78
00:03:13,280 --> 00:03:18,800
okay if you look up in the dictionary

79
00:03:15,840 --> 00:03:21,280
reduce may have some

80
00:03:18,800 --> 00:03:24,720
you know make it smaller or some meaning

81
00:03:21,280 --> 00:03:26,560
similar to that but

82
00:03:24,720 --> 00:03:29,840
i suggest you

83
00:03:26,560 --> 00:03:33,680
not to think about the word reduce

84
00:03:29,840 --> 00:03:37,519
or reduction or deductible reducibility

85
00:03:33,680 --> 00:03:39,760
in this chapter that way

86
00:03:37,519 --> 00:03:40,879
you should consider reduce in this

87
00:03:39,760 --> 00:03:43,760
chapter

88
00:03:40,879 --> 00:03:43,760
just like

89
00:03:44,000 --> 00:03:48,000
change to transform to

90
00:03:46,240 --> 00:03:50,159
[Music]

91
00:03:48,000 --> 00:03:52,799
another way to describe that or

92
00:03:50,159 --> 00:03:56,080
something like that okay

93
00:03:52,799 --> 00:04:00,000
there is nothing regarding making the

94
00:03:56,080 --> 00:04:03,840
problem easier because we will never be

95
00:04:00,000 --> 00:04:06,560
able to make a problem easier

96
00:04:03,840 --> 00:04:09,200
that's the key point of the

97
00:04:06,560 --> 00:04:11,200
in this room in this chapter

98
00:04:09,200 --> 00:04:12,720
so

99
00:04:11,200 --> 00:04:13,920
again

100
00:04:12,720 --> 00:04:15,840
let's say

101
00:04:13,920 --> 00:04:18,000
if problem a

102
00:04:15,840 --> 00:04:21,440
reduces to problem b

103
00:04:18,000 --> 00:04:22,880
that means we can use solution

104
00:04:21,440 --> 00:04:25,040
to b

105
00:04:22,880 --> 00:04:26,720
to solve a

106
00:04:25,040 --> 00:04:30,880
and

107
00:04:26,720 --> 00:04:33,360
we are not uh inventing

108
00:04:30,880 --> 00:04:34,160
some way to solve a alone

109
00:04:33,360 --> 00:04:36,560
and

110
00:04:34,160 --> 00:04:38,960
the solution to be

111
00:04:36,560 --> 00:04:41,840
is not is it's

112
00:04:38,960 --> 00:04:45,600
it is not proposed

113
00:04:41,840 --> 00:04:49,759
here either okay

114
00:04:45,600 --> 00:04:54,880
so when a is reducible to b

115
00:04:49,759 --> 00:04:57,840
okay that means a can be reduced to b

116
00:04:54,880 --> 00:04:57,840
we know that

117
00:04:58,479 --> 00:05:04,320
solving a

118
00:05:00,000 --> 00:05:04,320
cannot be harder than solving b

119
00:05:04,560 --> 00:05:07,120
because

120
00:05:05,520 --> 00:05:08,840
solution to b

121
00:05:07,120 --> 00:05:10,560
gives a solution to

122
00:05:08,840 --> 00:05:11,600
a

123
00:05:10,560 --> 00:05:14,240
right

124
00:05:11,600 --> 00:05:15,680
so the difficulty imagine that the

125
00:05:14,240 --> 00:05:17,120
difficulty

126
00:05:15,680 --> 00:05:20,400
to

127
00:05:17,120 --> 00:05:23,280
solving a

128
00:05:20,400 --> 00:05:25,680
is is at most

129
00:05:23,280 --> 00:05:28,000
the difficulty to solving b

130
00:05:25,680 --> 00:05:29,520
because you can use the solution to b to

131
00:05:28,000 --> 00:05:31,680
solve a right

132
00:05:29,520 --> 00:05:34,160
so in this sense

133
00:05:31,680 --> 00:05:35,280
we can say that

134
00:05:34,160 --> 00:05:39,840
if

135
00:05:35,280 --> 00:05:39,840
a is reducible to b

136
00:05:40,560 --> 00:05:43,199
we know that

137
00:05:43,680 --> 00:05:50,880
if you already know that b is decidable

138
00:05:48,000 --> 00:05:53,520
since b is decidable and you can use the

139
00:05:50,880 --> 00:05:54,320
solution to be to solve a

140
00:05:53,520 --> 00:05:56,720
so

141
00:05:54,320 --> 00:05:58,479
a is decidable

142
00:05:56,720 --> 00:06:01,680
or

143
00:05:58,479 --> 00:06:04,960
in the reverse direction

144
00:06:01,680 --> 00:06:07,840
if you already know that a is

145
00:06:04,960 --> 00:06:07,840
undecidable

146
00:06:08,080 --> 00:06:12,319
and somehow solving b can solve a

147
00:06:11,120 --> 00:06:16,800
you know that

148
00:06:12,319 --> 00:06:16,800
b must be undecidable too

149
00:06:16,960 --> 00:06:22,240
okay so a

150
00:06:18,880 --> 00:06:26,319
is reducible to b you know solving a

151
00:06:22,240 --> 00:06:29,039
cannot be harder than solving b

152
00:06:26,319 --> 00:06:30,479
by this sense we can in

153
00:06:29,039 --> 00:06:33,360
we can

154
00:06:30,479 --> 00:06:34,479
say that if you already know a b is

155
00:06:33,360 --> 00:06:36,720
decidable

156
00:06:34,479 --> 00:06:38,479
then you know a is decidable on the

157
00:06:36,720 --> 00:06:41,680
other hand if

158
00:06:38,479 --> 00:06:45,880
a is already undecidable

159
00:06:41,680 --> 00:06:45,880
then b must be undecidable

160
00:06:53,039 --> 00:06:57,599
so

161
00:06:54,080 --> 00:07:00,560
according to this kind of

162
00:06:57,599 --> 00:07:02,639
according to this way of thinking

163
00:07:00,560 --> 00:07:04,160
we can start to prove

164
00:07:02,639 --> 00:07:06,880
other

165
00:07:04,160 --> 00:07:08,880
undecidable languages now

166
00:07:06,880 --> 00:07:12,319
see we have now

167
00:07:08,880 --> 00:07:14,960
one oh well actually more than one

168
00:07:12,319 --> 00:07:17,120
because unrecognizable languages are

169
00:07:14,960 --> 00:07:19,280
undecidable because they are harder than

170
00:07:17,120 --> 00:07:22,400
design undecidable right

171
00:07:19,280 --> 00:07:25,919
but for recognizable

172
00:07:22,400 --> 00:07:28,080
decidable we have only one atm

173
00:07:25,919 --> 00:07:28,080
so

174
00:07:28,400 --> 00:07:31,840
if you can find

175
00:07:32,720 --> 00:07:36,000
some

176
00:07:34,080 --> 00:07:37,680
language

177
00:07:36,000 --> 00:07:39,039
which is which

178
00:07:37,680 --> 00:07:42,080
of which

179
00:07:39,039 --> 00:07:45,680
the solution to which the solution can

180
00:07:42,080 --> 00:07:48,639
be used to solve atn

181
00:07:45,680 --> 00:07:52,800
then we already know atm is undecidable

182
00:07:48,639 --> 00:07:53,680
so that's language is undecidable

183
00:07:52,800 --> 00:07:55,199
again

184
00:07:53,680 --> 00:07:56,639
if you find

185
00:07:55,199 --> 00:07:58,479
some language

186
00:07:56,639 --> 00:08:03,120
to which the solution

187
00:07:58,479 --> 00:08:06,639
can be used to solve atm

188
00:08:03,120 --> 00:08:08,720
and we already know atm is undecidable

189
00:08:06,639 --> 00:08:11,039
we can prove that

190
00:08:08,720 --> 00:08:14,080
the language we are talking about right

191
00:08:11,039 --> 00:08:16,639
now is undecidable too

192
00:08:14,080 --> 00:08:17,919
okay so that's what we want to do

193
00:08:16,639 --> 00:08:19,840
okay

194
00:08:17,919 --> 00:08:22,000
so

195
00:08:19,840 --> 00:08:22,800
the first language you want to prove is

196
00:08:22,000 --> 00:08:25,039
that

197
00:08:22,800 --> 00:08:28,400
hot tm is

198
00:08:25,039 --> 00:08:30,960
hot tm is undecidable

199
00:08:28,400 --> 00:08:34,000
okay so what is whole tm here by the

200
00:08:30,960 --> 00:08:36,399
definition used in the textbook we can

201
00:08:34,000 --> 00:08:39,680
say that hot tm

202
00:08:36,399 --> 00:08:41,760
is that you have a tool machine and the

203
00:08:39,680 --> 00:08:43,919
input for that turing machine

204
00:08:41,760 --> 00:08:45,040
and the tuning machine holds on the

205
00:08:43,919 --> 00:08:45,920
input

206
00:08:45,040 --> 00:08:48,480
okay

207
00:08:45,920 --> 00:08:49,279
then what is the holding configuration

208
00:08:48,480 --> 00:08:50,560
it

209
00:08:49,279 --> 00:08:53,120
holding con

210
00:08:50,560 --> 00:08:55,360
configurations include

211
00:08:53,120 --> 00:08:57,360
accepting configuration and rejecting

212
00:08:55,360 --> 00:08:58,240
configuration right

213
00:08:57,360 --> 00:08:59,920
so

214
00:08:58,240 --> 00:09:01,440
m either

215
00:08:59,920 --> 00:09:04,000
accepts

216
00:09:01,440 --> 00:09:07,120
w or rejects w

217
00:09:04,000 --> 00:09:09,519
we both we call the uh we call both the

218
00:09:07,120 --> 00:09:12,240
situation hot

219
00:09:09,519 --> 00:09:14,480
and hot here means

220
00:09:12,240 --> 00:09:14,480
if

221
00:09:14,560 --> 00:09:18,399
if a turing machine holds um

222
00:09:18,480 --> 00:09:21,519
input w

223
00:09:19,680 --> 00:09:22,880
all these kind of string is in the

224
00:09:21,519 --> 00:09:25,200
language

225
00:09:22,880 --> 00:09:26,720
and we want to prove that whole tien is

226
00:09:25,200 --> 00:09:27,920
undecidable

227
00:09:26,720 --> 00:09:32,320
means

228
00:09:27,920 --> 00:09:33,760
there can be no decider for hot tm

229
00:09:32,320 --> 00:09:35,839
okay

230
00:09:33,760 --> 00:09:38,880
so according to what we are talking

231
00:09:35,839 --> 00:09:38,880
about uh

232
00:09:38,959 --> 00:09:43,519
here

233
00:09:40,880 --> 00:09:46,320
if a is revisible to b

234
00:09:43,519 --> 00:09:47,839
and you know a is undecidable b is

235
00:09:46,320 --> 00:09:50,560
undecidable

236
00:09:47,839 --> 00:09:53,040
so we want to prove that

237
00:09:50,560 --> 00:09:55,839
we want to prove that

238
00:09:53,040 --> 00:09:57,680
whole tn is undecidable

239
00:09:55,839 --> 00:09:59,120
since we want to prove pro tm is

240
00:09:57,680 --> 00:10:02,160
undecidable

241
00:09:59,120 --> 00:10:06,240
we want we want to use the solution to

242
00:10:02,160 --> 00:10:07,600
hold tn to construct the solution to atm

243
00:10:06,240 --> 00:10:09,680
right

244
00:10:07,600 --> 00:10:13,279
so

245
00:10:09,680 --> 00:10:16,959
assume that there is a decider r

246
00:10:13,279 --> 00:10:21,839
for hot tn exist

247
00:10:16,959 --> 00:10:23,200
that is the solution to hot tm

248
00:10:21,839 --> 00:10:28,640
okay

249
00:10:23,200 --> 00:10:28,640
so solution oh sorry solution to hot tn

250
00:10:29,680 --> 00:10:35,680
we use solution to

251
00:10:32,640 --> 00:10:39,360
hot tien which is the

252
00:10:35,680 --> 00:10:43,360
assumed to be exist to exist

253
00:10:39,360 --> 00:10:45,680
decider r besides otn

254
00:10:43,360 --> 00:10:49,200
so based on the solution here we

255
00:10:45,680 --> 00:10:51,360
construct turing machine s

256
00:10:49,200 --> 00:10:53,839
and what are we doing

257
00:10:51,360 --> 00:10:54,640
on input mw

258
00:10:53,839 --> 00:10:56,800
where

259
00:10:54,640 --> 00:10:57,920
m is a turing machine and a w is a

260
00:10:56,800 --> 00:11:00,399
string

261
00:10:57,920 --> 00:11:02,480
for the two machine as input

262
00:11:00,399 --> 00:11:06,320
we run r

263
00:11:02,480 --> 00:11:08,880
because r exists right we arm we run r

264
00:11:06,320 --> 00:11:12,079
on input mw

265
00:11:08,880 --> 00:11:14,640
if r rejects

266
00:11:12,079 --> 00:11:15,680
that means

267
00:11:14,640 --> 00:11:17,760
and

268
00:11:15,680 --> 00:11:18,800
wrong on w

269
00:11:17,760 --> 00:11:21,040
will

270
00:11:18,800 --> 00:11:22,320
what enters some

271
00:11:21,040 --> 00:11:24,320
uh some

272
00:11:22,320 --> 00:11:27,040
some condition in which

273
00:11:24,320 --> 00:11:28,800
and runs forever

274
00:11:27,040 --> 00:11:31,839
right maybe loops

275
00:11:28,800 --> 00:11:34,399
uh maybe infinite loop or you know going

276
00:11:31,839 --> 00:11:36,880
somewhere not repeatedly but

277
00:11:34,399 --> 00:11:37,760
never ends never stops

278
00:11:36,880 --> 00:11:39,760
so

279
00:11:37,760 --> 00:11:42,480
we know

280
00:11:39,760 --> 00:11:43,360
m on w will never stops

281
00:11:42,480 --> 00:11:46,880
so

282
00:11:43,360 --> 00:11:48,320
hold tn the decider r for whole t n

283
00:11:46,880 --> 00:11:49,200
tells us this

284
00:11:48,320 --> 00:11:51,839
so

285
00:11:49,200 --> 00:11:55,519
s just need to reject

286
00:11:51,839 --> 00:11:57,519
so what x what our s reject

287
00:11:55,519 --> 00:11:59,440
s reject

288
00:11:57,519 --> 00:12:00,399
the input here

289
00:11:59,440 --> 00:12:02,399
because

290
00:12:00,399 --> 00:12:05,440
m will not accept w

291
00:12:02,399 --> 00:12:06,560
and also we know that m will run forever

292
00:12:05,440 --> 00:12:08,800
right

293
00:12:06,560 --> 00:12:11,839
if r accepts

294
00:12:08,800 --> 00:12:12,880
then we know that eventually m on w will

295
00:12:11,839 --> 00:12:16,320
hold

296
00:12:12,880 --> 00:12:16,710
will hold right so we

297
00:12:16,320 --> 00:12:17,920
can

298
00:12:16,710 --> 00:12:21,680
[Music]

299
00:12:17,920 --> 00:12:23,120
simulate m on w safely because we know

300
00:12:21,680 --> 00:12:24,560
it will stop

301
00:12:23,120 --> 00:12:27,519
it will stop

302
00:12:24,560 --> 00:12:29,040
until it holds

303
00:12:27,519 --> 00:12:32,880
and

304
00:12:29,040 --> 00:12:36,240
since m on w will hold

305
00:12:32,880 --> 00:12:39,440
if m accept w

306
00:12:36,240 --> 00:12:40,399
s accept its own input which is the pair

307
00:12:39,440 --> 00:12:43,760
here

308
00:12:40,399 --> 00:12:46,320
or and reject

309
00:12:43,760 --> 00:12:49,760
s reject its input

310
00:12:46,320 --> 00:12:50,959
mw pair as a string

311
00:12:49,760 --> 00:12:54,560
right

312
00:12:50,959 --> 00:12:56,560
so for the turing machine here you can

313
00:12:54,560 --> 00:12:58,639
know that as

314
00:12:56,560 --> 00:12:59,519
the true machine s we just constructed

315
00:12:58,639 --> 00:13:02,880
here

316
00:12:59,519 --> 00:13:05,839
can decide atm

317
00:13:02,880 --> 00:13:09,279
it's atm's decider okay so we

318
00:13:05,839 --> 00:13:10,480
successfully use the solution to b which

319
00:13:09,279 --> 00:13:12,959
is r

320
00:13:10,480 --> 00:13:17,200
as whole tm decider

321
00:13:12,959 --> 00:13:17,200
to construct solution to a

322
00:13:18,480 --> 00:13:24,639
and clearly if

323
00:13:22,079 --> 00:13:26,240
clearly

324
00:13:24,639 --> 00:13:28,880
we know that

325
00:13:26,240 --> 00:13:31,839
atm's decider

326
00:13:28,880 --> 00:13:33,279
cannot exist

327
00:13:31,839 --> 00:13:34,480
right

328
00:13:33,279 --> 00:13:37,920
so

329
00:13:34,480 --> 00:13:40,800
the construction comes from assuming r

330
00:13:37,920 --> 00:13:44,000
exists which is whole tm decider

331
00:13:40,800 --> 00:13:44,000
so hot tm

332
00:13:44,320 --> 00:13:47,959
must be undecidable

333
00:13:48,480 --> 00:13:50,800
okay

334
00:13:51,360 --> 00:13:57,120
so in the concept

335
00:13:53,920 --> 00:13:58,079
we previous we we just described that we

336
00:13:57,120 --> 00:13:59,519
use

337
00:13:58,079 --> 00:14:02,880
the

338
00:13:59,519 --> 00:14:04,480
solution to hold tn to solve

339
00:14:02,880 --> 00:14:08,000
atn

340
00:14:04,480 --> 00:14:11,360
and we know that atn cannot be solved so

341
00:14:08,000 --> 00:14:14,639
otm is undecidable

342
00:14:11,360 --> 00:14:16,639
but for the proof here what we use is

343
00:14:14,639 --> 00:14:18,959
proved by contradiction

344
00:14:16,639 --> 00:14:22,880
and the constructive contradiction

345
00:14:18,959 --> 00:14:26,000
raised in the assumption

346
00:14:22,880 --> 00:14:27,040
of the existence of whole tm's decider

347
00:14:26,000 --> 00:14:30,000
okay

348
00:14:27,040 --> 00:14:33,519
so if whole tms decider exists then we

349
00:14:30,000 --> 00:14:38,240
can construct atm decider but we already

350
00:14:33,519 --> 00:14:41,360
proved that atm cannot have a decider so

351
00:14:38,240 --> 00:14:43,120
host hold decider for whole tm cannot

352
00:14:41,360 --> 00:14:45,600
exist

353
00:14:43,120 --> 00:14:47,040
so we proved that

354
00:14:45,600 --> 00:14:50,240
hot tm

355
00:14:47,040 --> 00:14:50,240
is undecidable

356
00:14:50,480 --> 00:14:54,320
okay

357
00:14:51,680 --> 00:14:56,079
so the concept is

358
00:14:54,320 --> 00:14:58,480
here

359
00:14:56,079 --> 00:15:03,360
although the proof technique we

360
00:14:58,480 --> 00:15:03,360
we were using is proof by contradiction

361
00:15:03,839 --> 00:15:07,120
okay let's practice more

362
00:15:06,160 --> 00:15:09,760
so

363
00:15:07,120 --> 00:15:11,440
we can also prove that e t n is

364
00:15:09,760 --> 00:15:13,199
undecidable

365
00:15:11,440 --> 00:15:16,320
okay

366
00:15:13,199 --> 00:15:19,120
so the whole thing repeat again just

367
00:15:16,320 --> 00:15:21,360
different construction

368
00:15:19,120 --> 00:15:25,279
we assume that

369
00:15:21,360 --> 00:15:28,160
etn decider r exists

370
00:15:25,279 --> 00:15:30,000
so we use the solution to etn which is

371
00:15:28,160 --> 00:15:31,600
the decider r

372
00:15:30,000 --> 00:15:33,440
for etn

373
00:15:31,600 --> 00:15:35,759
to solve

374
00:15:33,440 --> 00:15:39,120
atn

375
00:15:35,759 --> 00:15:42,320
so we reduce atm to etn

376
00:15:39,120 --> 00:15:43,279
and we already know atm is undecidable

377
00:15:42,320 --> 00:15:45,199
so

378
00:15:43,279 --> 00:15:47,920
etm must be

379
00:15:45,199 --> 00:15:50,959
undecidable that's the

380
00:15:47,920 --> 00:15:52,639
concept okay so

381
00:15:50,959 --> 00:15:54,880
again

382
00:15:52,639 --> 00:15:56,160
assuming that

383
00:15:54,880 --> 00:15:57,440
assuming that

384
00:15:56,160 --> 00:15:58,800
etm

385
00:15:57,440 --> 00:16:00,880
decider

386
00:15:58,800 --> 00:16:02,800
r

387
00:16:00,880 --> 00:16:05,040
exists

388
00:16:02,800 --> 00:16:08,680
okay that's the solution

389
00:16:05,040 --> 00:16:08,680
to etn

390
00:16:20,320 --> 00:16:25,600
now we use that solution to to solve atm

391
00:16:24,320 --> 00:16:28,079
okay

392
00:16:25,600 --> 00:16:29,680
how do we do that firstly

393
00:16:28,079 --> 00:16:33,519
we

394
00:16:29,680 --> 00:16:33,519
design a turing machine m1

395
00:16:33,600 --> 00:16:38,079
okay

396
00:16:34,800 --> 00:16:40,480
so m1 input x

397
00:16:38,079 --> 00:16:43,199
and we put

398
00:16:40,480 --> 00:16:43,199
a blank

399
00:16:43,759 --> 00:16:47,040
here

400
00:16:45,440 --> 00:16:50,240
a blank here

401
00:16:47,040 --> 00:16:54,800
and also a blank here

402
00:16:50,240 --> 00:16:56,480
so m1 and here sorry and the m1 is a

403
00:16:54,800 --> 00:16:57,920
is a is an

404
00:16:56,480 --> 00:16:59,360
incomplete

405
00:16:57,920 --> 00:17:01,680
program

406
00:16:59,360 --> 00:17:02,720
it's a program with

407
00:17:01,680 --> 00:17:07,120
some

408
00:17:02,720 --> 00:17:09,280
blank for you to fill in after fill in

409
00:17:07,120 --> 00:17:11,120
you will you will get

410
00:17:09,280 --> 00:17:13,199
a complete program

411
00:17:11,120 --> 00:17:16,480
but before that it's not a complete

412
00:17:13,199 --> 00:17:19,600
program it cannot run along okay and

413
00:17:16,480 --> 00:17:20,720
we've seen this construction before

414
00:17:19,600 --> 00:17:22,400
for

415
00:17:20,720 --> 00:17:24,959
proving every

416
00:17:22,400 --> 00:17:27,679
context free language to be decidable

417
00:17:24,959 --> 00:17:29,919
right we have some

418
00:17:27,679 --> 00:17:29,919
uh

419
00:17:31,039 --> 00:17:35,039
some incomplete program for you to fill

420
00:17:33,200 --> 00:17:36,320
in some blank

421
00:17:35,039 --> 00:17:37,840
okay

422
00:17:36,320 --> 00:17:39,919
so anyway

423
00:17:37,840 --> 00:17:41,520
for the input of

424
00:17:39,919 --> 00:17:43,280
m1

425
00:17:41,520 --> 00:17:46,080
it will be

426
00:17:43,280 --> 00:17:50,480
it will compare the input string with

427
00:17:46,080 --> 00:17:53,120
with some particular string let's say w

428
00:17:50,480 --> 00:17:56,000
if they are not then reject

429
00:17:53,120 --> 00:17:57,840
they are not identical then reject

430
00:17:56,000 --> 00:18:00,799
so

431
00:17:57,840 --> 00:18:03,280
you can see that for all possible

432
00:18:00,799 --> 00:18:05,679
strings

433
00:18:03,280 --> 00:18:09,360
for all possible strings

434
00:18:05,679 --> 00:18:12,400
as long as x is not some particular

435
00:18:09,360 --> 00:18:15,760
string that will be filled in

436
00:18:12,400 --> 00:18:20,640
will be rejected so the only string that

437
00:18:15,760 --> 00:18:23,840
may be accepted by m1 is some

438
00:18:20,640 --> 00:18:27,200
input is some string w which hasn't been

439
00:18:23,840 --> 00:18:29,760
written into the program okay anyway

440
00:18:27,200 --> 00:18:32,799
so if x is w

441
00:18:29,760 --> 00:18:34,240
then we will run m which will be filled

442
00:18:32,799 --> 00:18:36,559
in

443
00:18:34,240 --> 00:18:39,919
on w

444
00:18:36,559 --> 00:18:41,840
since in this case uh condition m and x

445
00:18:39,919 --> 00:18:44,559
and w is the same string so it doesn't

446
00:18:41,840 --> 00:18:47,600
matter to write which one

447
00:18:44,559 --> 00:18:49,919
and if x if accept

448
00:18:47,600 --> 00:18:51,440
sorry

449
00:18:49,919 --> 00:18:55,160
if m

450
00:18:51,440 --> 00:18:55,160
accept w

451
00:18:58,640 --> 00:19:04,799
then m1 accepts its input

452
00:19:02,559 --> 00:19:06,240
which is also w here

453
00:19:04,799 --> 00:19:07,360
right

454
00:19:06,240 --> 00:19:09,760
but

455
00:19:07,360 --> 00:19:10,400
m and w

456
00:19:09,760 --> 00:19:12,400
are

457
00:19:10,400 --> 00:19:15,679
blank for now

458
00:19:12,400 --> 00:19:16,480
we don't know what they are right now

459
00:19:15,679 --> 00:19:18,799
okay

460
00:19:16,480 --> 00:19:20,799
then we construct

461
00:19:18,799 --> 00:19:22,240
tuning machine s here

462
00:19:20,799 --> 00:19:24,880
okay

463
00:19:22,240 --> 00:19:27,840
so as here it it is

464
00:19:24,880 --> 00:19:29,120
supposed to be the decider for atm

465
00:19:27,840 --> 00:19:32,880
so on

466
00:19:29,120 --> 00:19:36,960
mw where m is a turing machine program

467
00:19:32,880 --> 00:19:36,960
as w is a input string

468
00:19:37,440 --> 00:19:41,039
we

469
00:19:39,520 --> 00:19:42,480
put m

470
00:19:41,039 --> 00:19:44,320
and w

471
00:19:42,480 --> 00:19:46,000
into

472
00:19:44,320 --> 00:19:47,200
m1 okay

473
00:19:46,000 --> 00:19:50,080
so

474
00:19:47,200 --> 00:19:55,840
after we have m and w

475
00:19:50,080 --> 00:19:57,840
we filled in m and w into m1 so now m1

476
00:19:55,840 --> 00:19:59,120
is a complete program

477
00:19:57,840 --> 00:20:01,120
right

478
00:19:59,120 --> 00:20:05,679
then

479
00:20:01,120 --> 00:20:07,840
we use m1 as the input to

480
00:20:05,679 --> 00:20:07,840
r

481
00:20:08,880 --> 00:20:15,120
okay we use that m1

482
00:20:11,280 --> 00:20:16,159
as the input and fit it into r and we

483
00:20:15,120 --> 00:20:16,960
draw

484
00:20:16,159 --> 00:20:17,840
r

485
00:20:16,960 --> 00:20:23,600
and

486
00:20:17,840 --> 00:20:23,600
what is r r is the decider for etn

487
00:20:24,320 --> 00:20:28,000
okay

488
00:20:25,360 --> 00:20:29,600
since r is the decider for etn and what

489
00:20:28,000 --> 00:20:33,440
is m1

490
00:20:29,600 --> 00:20:36,480
so let's say now we have m and w

491
00:20:33,440 --> 00:20:38,400
so what will m1

492
00:20:36,480 --> 00:20:40,400
do

493
00:20:38,400 --> 00:20:42,400
m1 will reject

494
00:20:40,400 --> 00:20:46,320
all strings

495
00:20:42,400 --> 00:20:49,200
m1 will reject all strings

496
00:20:46,320 --> 00:20:51,120
not equal to w

497
00:20:49,200 --> 00:20:54,000
right

498
00:20:51,120 --> 00:20:54,000
and you see

499
00:20:54,880 --> 00:20:58,720
if w is

500
00:20:57,039 --> 00:21:03,840
m1's input

501
00:20:58,720 --> 00:21:03,840
m1 will simulate m on w

502
00:21:04,320 --> 00:21:08,480
so

503
00:21:05,600 --> 00:21:08,480
when you do

504
00:21:08,640 --> 00:21:15,840
wrong and on input w you will get three

505
00:21:13,200 --> 00:21:17,679
possible

506
00:21:15,840 --> 00:21:20,080
right

507
00:21:17,679 --> 00:21:20,080
one

508
00:21:21,039 --> 00:21:25,520
runs forever

509
00:21:23,200 --> 00:21:25,520
right

510
00:21:25,840 --> 00:21:29,600
or infinite loop if you will

511
00:21:28,559 --> 00:21:30,960
two

512
00:21:29,600 --> 00:21:33,679
and

513
00:21:30,960 --> 00:21:33,679
accept

514
00:21:34,240 --> 00:21:36,880
w

515
00:21:35,600 --> 00:21:40,320
three

516
00:21:36,880 --> 00:21:40,320
and reject

517
00:21:41,679 --> 00:21:44,679
sorry

518
00:21:47,760 --> 00:21:52,080
w

519
00:21:50,159 --> 00:21:53,039
now

520
00:21:52,080 --> 00:21:54,799
if

521
00:21:53,039 --> 00:21:59,520
m runs forever

522
00:21:54,799 --> 00:22:01,039
m1 runs forever then m1 will not accept

523
00:21:59,520 --> 00:22:02,320
w right

524
00:22:01,039 --> 00:22:03,760
or

525
00:22:02,320 --> 00:22:08,159
in that case

526
00:22:03,760 --> 00:22:11,200
x because x is w in this case so you see

527
00:22:08,159 --> 00:22:14,400
m1 definitely rejects

528
00:22:11,200 --> 00:22:15,440
all strings except for w

529
00:22:14,400 --> 00:22:19,840
and

530
00:22:15,440 --> 00:22:23,360
if the input is exactly w then m1 will

531
00:22:19,840 --> 00:22:24,720
run m on input w

532
00:22:23,360 --> 00:22:29,840
and when

533
00:22:24,720 --> 00:22:33,360
m1 run m on input w and it runs forever

534
00:22:29,840 --> 00:22:34,960
and one will run forever and will not we

535
00:22:33,360 --> 00:22:39,440
accept w

536
00:22:34,960 --> 00:22:42,000
so in this case l of m1

537
00:22:39,440 --> 00:22:44,240
is empty set

538
00:22:42,000 --> 00:22:45,200
right because it already rejects any

539
00:22:44,240 --> 00:22:46,720
string

540
00:22:45,200 --> 00:22:50,000
other than w

541
00:22:46,720 --> 00:22:52,640
and for w it will run n

542
00:22:50,000 --> 00:22:55,919
and if m

543
00:22:52,640 --> 00:22:58,880
on the input w runs forever then of

544
00:22:55,919 --> 00:23:02,400
course m1 will not accept any string so

545
00:22:58,880 --> 00:23:04,000
the language recognized by m1 is empty

546
00:23:02,400 --> 00:23:06,320
set

547
00:23:04,000 --> 00:23:06,320
or

548
00:23:07,039 --> 00:23:13,440
m reject w

549
00:23:10,320 --> 00:23:14,640
and since our description does not

550
00:23:13,440 --> 00:23:15,520
contain

551
00:23:14,640 --> 00:23:16,880
a

552
00:23:15,520 --> 00:23:20,840
you know

553
00:23:16,880 --> 00:23:25,840
halt situation it does not reject

554
00:23:20,840 --> 00:23:27,440
so and uh we also it does not accept

555
00:23:25,840 --> 00:23:29,120
that string

556
00:23:27,440 --> 00:23:32,880
so in this case

557
00:23:29,120 --> 00:23:33,919
l of m1 is still

558
00:23:32,880 --> 00:23:38,960
empty

559
00:23:33,919 --> 00:23:40,320
empty set why because m1 does not

560
00:23:38,960 --> 00:23:43,360
accept stop

561
00:23:40,320 --> 00:23:46,559
accept any string in this case

562
00:23:43,360 --> 00:23:48,240
it's undefined here right

563
00:23:46,559 --> 00:23:53,200
only that

564
00:23:48,240 --> 00:23:56,400
if m does accepts w then m1 accepts its

565
00:23:53,200 --> 00:23:58,080
input string which is w2 right

566
00:23:56,400 --> 00:24:01,279
so in this case

567
00:23:58,080 --> 00:24:01,279
ll of m

568
00:24:01,440 --> 00:24:06,400
is

569
00:24:03,039 --> 00:24:08,720
a language contains only one string

570
00:24:06,400 --> 00:24:14,159
which is w

571
00:24:08,720 --> 00:24:14,159
and therefore it's not empty set

572
00:24:15,039 --> 00:24:20,240
right

573
00:24:16,240 --> 00:24:21,360
so back to the step two here when we run

574
00:24:20,240 --> 00:24:24,720
r

575
00:24:21,360 --> 00:24:27,679
on input m input m1

576
00:24:24,720 --> 00:24:28,960
r will let us know

577
00:24:27,679 --> 00:24:33,200
it's

578
00:24:28,960 --> 00:24:34,159
this case over this case

579
00:24:33,200 --> 00:24:37,360
right

580
00:24:34,159 --> 00:24:38,480
so if r accepts

581
00:24:37,360 --> 00:24:40,480
and

582
00:24:38,480 --> 00:24:43,679
don't forget that what is r

583
00:24:40,480 --> 00:24:48,720
r is the h etm decider

584
00:24:43,679 --> 00:24:49,919
so when r accepts m1 that means

585
00:24:48,720 --> 00:24:51,520
l of

586
00:24:49,919 --> 00:24:55,279
m1

587
00:24:51,520 --> 00:24:56,640
is mt set

588
00:24:55,279 --> 00:24:58,720
right

589
00:24:56,640 --> 00:25:00,400
and we know that

590
00:24:58,720 --> 00:25:03,200
either this case

591
00:25:00,400 --> 00:25:05,039
or this case

592
00:25:03,200 --> 00:25:06,720
means and

593
00:25:05,039 --> 00:25:09,520
will not

594
00:25:06,720 --> 00:25:09,520
accept

595
00:25:10,480 --> 00:25:13,840
w

596
00:25:11,600 --> 00:25:19,120
right

597
00:25:13,840 --> 00:25:21,919
we as a atm designer we need to reject

598
00:25:19,120 --> 00:25:25,039
our input here

599
00:25:21,919 --> 00:25:27,120
on the other hand if r

600
00:25:25,039 --> 00:25:30,559
rejects

601
00:25:27,120 --> 00:25:32,559
that means and l of m one

602
00:25:30,559 --> 00:25:34,799
is not

603
00:25:32,559 --> 00:25:36,400
empty set

604
00:25:34,799 --> 00:25:37,679
then we know

605
00:25:36,400 --> 00:25:41,120
c

606
00:25:37,679 --> 00:25:43,039
m accepts w

607
00:25:41,120 --> 00:25:45,600
so as

608
00:25:43,039 --> 00:25:46,640
the atm designer

609
00:25:45,600 --> 00:25:49,520
s

610
00:25:46,640 --> 00:25:54,360
accepts its own

611
00:25:49,520 --> 00:25:54,360
input which is mw pair

612
00:25:59,440 --> 00:26:01,679
so

613
00:26:02,480 --> 00:26:06,720
with help

614
00:26:03,840 --> 00:26:06,720
of m1

615
00:26:07,200 --> 00:26:13,440
we

616
00:26:08,840 --> 00:26:16,880
construct atm decider as

617
00:26:13,440 --> 00:26:16,880
this to machine

618
00:26:20,240 --> 00:26:25,840
so for the reduction

619
00:26:23,520 --> 00:26:29,360
we use

620
00:26:25,840 --> 00:26:29,360
the solution to etm

621
00:26:29,840 --> 00:26:33,440
to solve

622
00:26:31,840 --> 00:26:37,360
atn

623
00:26:33,440 --> 00:26:39,600
since we know atm is undecidable

624
00:26:37,360 --> 00:26:42,559
etm is undecidable

625
00:26:39,600 --> 00:26:44,400
and we actually finish the proof by

626
00:26:42,559 --> 00:26:45,840
contradiction

627
00:26:44,400 --> 00:26:47,919
how to

628
00:26:45,840 --> 00:26:50,080
obtain the contradiction

629
00:26:47,919 --> 00:26:54,320
because we assume that

630
00:26:50,080 --> 00:26:54,320
etm's decider r exists

631
00:26:54,960 --> 00:26:57,679
and then

632
00:26:56,559 --> 00:27:00,640
we

633
00:26:57,679 --> 00:27:02,720
by using r we construct

634
00:27:00,640 --> 00:27:05,200
atm decider s

635
00:27:02,720 --> 00:27:06,559
and the construction of

636
00:27:05,200 --> 00:27:08,159
s here

637
00:27:06,559 --> 00:27:11,279
has no

638
00:27:08,159 --> 00:27:13,200
particular technical difficulty right

639
00:27:11,279 --> 00:27:16,799
everything we can do

640
00:27:13,200 --> 00:27:17,760
within the capability of turing machine

641
00:27:16,799 --> 00:27:18,880
so

642
00:27:17,760 --> 00:27:22,320
that means

643
00:27:18,880 --> 00:27:25,520
we successfully construct

644
00:27:22,320 --> 00:27:25,520
atms decider

645
00:27:26,000 --> 00:27:28,399
but

646
00:27:26,799 --> 00:27:32,840
we already know that

647
00:27:28,399 --> 00:27:36,320
a decider for atn cannot

648
00:27:32,840 --> 00:27:38,320
exist so we know that the contradiction

649
00:27:36,320 --> 00:27:40,799
comes from the assumption of the

650
00:27:38,320 --> 00:27:42,799
existence of

651
00:27:40,799 --> 00:27:45,279
decider for etn

652
00:27:42,799 --> 00:27:46,480
so etm decider cannot

653
00:27:45,279 --> 00:27:51,520
exist

654
00:27:46,480 --> 00:27:52,880
so we know that etm must be undecidable

655
00:27:51,520 --> 00:27:54,080
okay

656
00:27:52,880 --> 00:27:56,159
so

657
00:27:54,080 --> 00:28:01,039
we proved this theorem

658
00:27:56,159 --> 00:28:03,600
we proved that etm is undecidable

659
00:28:01,039 --> 00:28:04,640
okay

660
00:28:03,600 --> 00:28:06,640
okay

661
00:28:04,640 --> 00:28:09,919
next one

662
00:28:06,640 --> 00:28:12,640
we want to prove that a regular tm is

663
00:28:09,919 --> 00:28:14,799
undecided undecidable too

664
00:28:12,640 --> 00:28:18,240
with the same proof

665
00:28:14,799 --> 00:28:20,799
structure so what is regular tm as the

666
00:28:18,240 --> 00:28:22,080
naming convention

667
00:28:20,799 --> 00:28:27,360
regular

668
00:28:22,080 --> 00:28:27,360
tn means that all the turing machine

669
00:28:28,559 --> 00:28:33,120
of which the language

670
00:28:30,640 --> 00:28:35,360
is a regular language

671
00:28:33,120 --> 00:28:37,200
okay

672
00:28:35,360 --> 00:28:40,080
since we have introduced the

673
00:28:37,200 --> 00:28:42,840
relationship among classes of languages

674
00:28:40,080 --> 00:28:44,720
we know that a regular is

675
00:28:42,840 --> 00:28:47,840
within

676
00:28:44,720 --> 00:28:50,880
the capability of turing machine right

677
00:28:47,840 --> 00:28:52,240
so there must be turing machines

678
00:28:50,880 --> 00:28:54,480
recognizing

679
00:28:52,240 --> 00:28:57,120
regular languages

680
00:28:54,480 --> 00:28:59,919
so if we define that all the turing

681
00:28:57,120 --> 00:29:02,640
machines that recognize regular

682
00:28:59,919 --> 00:29:05,919
languages is in the set

683
00:29:02,640 --> 00:29:08,720
is it possible for us to write to design

684
00:29:05,919 --> 00:29:12,399
a turing machine

685
00:29:08,720 --> 00:29:13,600
for the input as a turing machine to

686
00:29:12,399 --> 00:29:16,399
determine

687
00:29:13,600 --> 00:29:19,679
whether or not the given to a machine

688
00:29:16,399 --> 00:29:22,480
recognizing a regular language

689
00:29:19,679 --> 00:29:24,720
okay so now we want to prove that

690
00:29:22,480 --> 00:29:27,520
it is impossible

691
00:29:24,720 --> 00:29:31,200
it is impossible for us to write

692
00:29:27,520 --> 00:29:33,520
to design artillery machine to determine

693
00:29:31,200 --> 00:29:37,440
whether or not a given turing machine

694
00:29:33,520 --> 00:29:39,440
recognizing a regular language okay

695
00:29:37,440 --> 00:29:42,720
so

696
00:29:39,440 --> 00:29:44,720
we want to uh use the same

697
00:29:42,720 --> 00:29:46,000
proof structure so

698
00:29:44,720 --> 00:29:48,080
uh

699
00:29:46,000 --> 00:29:54,279
assume that

700
00:29:48,080 --> 00:29:54,279
there is a decider r for regular tn

701
00:29:54,720 --> 00:30:01,039
we want to use

702
00:29:56,559 --> 00:30:01,039
r the solution to problem b

703
00:30:02,000 --> 00:30:07,440
to solve problem a

704
00:30:05,600 --> 00:30:09,919
and we already know that atm is

705
00:30:07,440 --> 00:30:12,080
undecidable therefore

706
00:30:09,919 --> 00:30:13,120
regular tm is undecidable that's what we

707
00:30:12,080 --> 00:30:14,960
want to do

708
00:30:13,120 --> 00:30:18,159
and the whole proof

709
00:30:14,960 --> 00:30:19,840
is much like the one for etn so let's

710
00:30:18,159 --> 00:30:21,120
just

711
00:30:19,840 --> 00:30:25,760
prove it

712
00:30:21,120 --> 00:30:27,520
so we assume that r is the

713
00:30:25,760 --> 00:30:29,840
solution to regular tm which is the

714
00:30:27,520 --> 00:30:30,880
decider for this language

715
00:30:29,840 --> 00:30:32,480
and then

716
00:30:30,880 --> 00:30:33,360
we construct

717
00:30:32,480 --> 00:30:38,640
s

718
00:30:33,360 --> 00:30:41,600
as atm's decider so the input for s is

719
00:30:38,640 --> 00:30:42,799
a turing machine and

720
00:30:41,600 --> 00:30:45,600
a string

721
00:30:42,799 --> 00:30:47,840
as the input of that turing machine

722
00:30:45,600 --> 00:30:49,279
and we construct

723
00:30:47,840 --> 00:30:53,679
m2 here

724
00:30:49,279 --> 00:30:56,159
the row of m2 is like the row of m1 in

725
00:30:53,679 --> 00:30:58,480
the proof of etn

726
00:30:56,159 --> 00:30:59,519
this undesirability of edm

727
00:30:58,480 --> 00:31:02,640
so

728
00:30:59,519 --> 00:31:04,559
m2 on its own input

729
00:31:02,640 --> 00:31:06,799
it firstly check

730
00:31:04,559 --> 00:31:09,919
if the input

731
00:31:06,799 --> 00:31:11,840
if the input has the form of

732
00:31:09,919 --> 00:31:14,240
this

733
00:31:11,840 --> 00:31:15,120
if so accept

734
00:31:14,240 --> 00:31:16,640
okay

735
00:31:15,120 --> 00:31:18,640
so let's see

736
00:31:16,640 --> 00:31:20,480
for step one

737
00:31:18,640 --> 00:31:23,039
no matter what

738
00:31:20,480 --> 00:31:25,200
m or w is

739
00:31:23,039 --> 00:31:27,519
no matter what the pair is

740
00:31:25,200 --> 00:31:31,360
n2 always

741
00:31:27,519 --> 00:31:33,840
out of all possible strings

742
00:31:31,360 --> 00:31:35,279
and to always

743
00:31:33,840 --> 00:31:36,880
accept

744
00:31:35,279 --> 00:31:39,840
accept string

745
00:31:36,880 --> 00:31:42,080
like this one

746
00:31:39,840 --> 00:31:42,080
okay

747
00:31:43,039 --> 00:31:50,159
this language

748
00:31:45,120 --> 00:31:53,120
the strings in this language will always

749
00:31:50,159 --> 00:31:54,480
be accepted by m2 okay

750
00:31:53,120 --> 00:31:57,200
then

751
00:31:54,480 --> 00:31:58,320
outside the language outside of the

752
00:31:57,200 --> 00:32:00,720
language

753
00:31:58,320 --> 00:32:03,039
m2 will run m

754
00:32:00,720 --> 00:32:04,640
on w

755
00:32:03,039 --> 00:32:07,679
then to see

756
00:32:04,640 --> 00:32:12,080
if m accepts w

757
00:32:07,679 --> 00:32:14,320
m2 will accept its own input what is its

758
00:32:12,080 --> 00:32:15,600
own input we don't know we just know

759
00:32:14,320 --> 00:32:19,519
that here

760
00:32:15,600 --> 00:32:23,039
the input may be any string outside of

761
00:32:19,519 --> 00:32:23,039
that language right

762
00:32:23,679 --> 00:32:26,559
now

763
00:32:24,799 --> 00:32:27,360
you can find

764
00:32:26,559 --> 00:32:29,120
we

765
00:32:27,360 --> 00:32:31,360
actually use

766
00:32:29,120 --> 00:32:32,720
n on w

767
00:32:31,360 --> 00:32:33,679
as a switch

768
00:32:32,720 --> 00:32:35,600
okay

769
00:32:33,679 --> 00:32:38,399
if m

770
00:32:35,600 --> 00:32:42,000
accept w

771
00:32:38,399 --> 00:32:45,039
then what will our m2 recognize what

772
00:32:42,000 --> 00:32:46,320
language will our m2 recognize

773
00:32:45,039 --> 00:32:47,120
no matter

774
00:32:46,320 --> 00:32:48,640
m

775
00:32:47,120 --> 00:32:49,840
accept w or

776
00:32:48,640 --> 00:32:54,080
or not

777
00:32:49,840 --> 00:32:56,559
m2 always accepts all strings

778
00:32:54,080 --> 00:32:57,840
in

779
00:32:56,559 --> 00:32:59,760
this

780
00:32:57,840 --> 00:33:01,600
language right

781
00:32:59,760 --> 00:33:03,760
if and

782
00:33:01,600 --> 00:33:05,919
accept w

783
00:33:03,760 --> 00:33:08,320
and to well

784
00:33:05,919 --> 00:33:12,080
accept string from

785
00:33:08,320 --> 00:33:16,240
will also accept string from outside of

786
00:33:12,080 --> 00:33:20,000
the language that is l of m2

787
00:33:16,240 --> 00:33:20,960
is all possible strings

788
00:33:20,000 --> 00:33:24,760
right

789
00:33:20,960 --> 00:33:24,760
because it will

790
00:33:28,720 --> 00:33:32,799
also accept string outside of the

791
00:33:31,120 --> 00:33:33,919
language

792
00:33:32,799 --> 00:33:36,640
if n

793
00:33:33,919 --> 00:33:36,640
does not

794
00:33:36,880 --> 00:33:43,519
does not accept w

795
00:33:40,080 --> 00:33:46,320
then m2 recognize

796
00:33:43,519 --> 00:33:46,320
this language

797
00:33:47,279 --> 00:33:50,240
then m2

798
00:33:50,480 --> 00:33:54,880
recognized only the strings in this

799
00:33:53,679 --> 00:33:58,640
language

800
00:33:54,880 --> 00:34:00,000
that is it recognize this language

801
00:33:58,640 --> 00:34:01,279
right

802
00:34:00,000 --> 00:34:03,440
so

803
00:34:01,279 --> 00:34:07,360
it becomes a switch

804
00:34:03,440 --> 00:34:10,480
to switch the behavior of m2 as

805
00:34:07,360 --> 00:34:12,159
this language recognizing this or this

806
00:34:10,480 --> 00:34:14,399
language

807
00:34:12,159 --> 00:34:14,399
so

808
00:34:15,040 --> 00:34:17,280
if

809
00:34:16,240 --> 00:34:20,000
m

810
00:34:17,280 --> 00:34:21,760
accept w

811
00:34:20,000 --> 00:34:24,000
and to well

812
00:34:21,760 --> 00:34:26,720
when m2 will recognize

813
00:34:24,000 --> 00:34:28,879
will recognize a regular language which

814
00:34:26,720 --> 00:34:30,720
is sigma star

815
00:34:28,879 --> 00:34:35,760
if m does not

816
00:34:30,720 --> 00:34:39,359
accept w either rejects or runs forever

817
00:34:35,760 --> 00:34:40,639
m2 will recognize this language which is

818
00:34:39,359 --> 00:34:42,879
not

819
00:34:40,639 --> 00:34:46,839
a regular language

820
00:34:42,879 --> 00:34:51,040
so we just need to put the source code

821
00:34:46,839 --> 00:34:53,520
m2 as the input of the decider for

822
00:34:51,040 --> 00:34:55,440
regular tm which

823
00:34:53,520 --> 00:34:57,040
we assume

824
00:34:55,440 --> 00:34:58,160
its existence

825
00:34:57,040 --> 00:34:59,680
right

826
00:34:58,160 --> 00:35:04,079
so if

827
00:34:59,680 --> 00:35:05,200
regular tms decider accept that means

828
00:35:04,079 --> 00:35:06,640
it is

829
00:35:05,200 --> 00:35:10,079
this case

830
00:35:06,640 --> 00:35:13,599
then we know m accept w so

831
00:35:10,079 --> 00:35:14,800
atm decider accept accept what

832
00:35:13,599 --> 00:35:16,880
the

833
00:35:14,800 --> 00:35:19,040
machine string pair

834
00:35:16,880 --> 00:35:20,880
if r rejects

835
00:35:19,040 --> 00:35:22,160
then we reject

836
00:35:20,880 --> 00:35:24,160
okay

837
00:35:22,160 --> 00:35:26,240
so s here

838
00:35:24,160 --> 00:35:28,880
is the

839
00:35:26,240 --> 00:35:32,000
atms decider

840
00:35:28,880 --> 00:35:34,240
and we use solution to regular tm to

841
00:35:32,000 --> 00:35:36,079
solve

842
00:35:34,240 --> 00:35:38,400
atm

843
00:35:36,079 --> 00:35:42,000
however we know that

844
00:35:38,400 --> 00:35:44,400
atm's decider cannot exist so regular

845
00:35:42,000 --> 00:35:46,960
tms decider cannot exist

846
00:35:44,400 --> 00:35:51,119
so we conclude that

847
00:35:46,960 --> 00:35:54,640
regular tn is undecidable because

848
00:35:51,119 --> 00:35:59,839
if the decider of regular tm exists

849
00:35:54,640 --> 00:35:59,839
there will be definitely a contradiction

850
00:35:59,920 --> 00:36:02,160
okay

851
00:36:02,560 --> 00:36:06,160
then

852
00:36:03,680 --> 00:36:08,480
did you see

853
00:36:06,160 --> 00:36:08,480
or

854
00:36:09,680 --> 00:36:16,320
do you see

855
00:36:10,839 --> 00:36:17,359
the similarity of these two proof

856
00:36:16,320 --> 00:36:19,440
that is

857
00:36:17,359 --> 00:36:24,440
we use a machine

858
00:36:19,440 --> 00:36:24,440
and we design a switch

859
00:36:26,560 --> 00:36:31,440
to switch the machine's behavior

860
00:36:29,440 --> 00:36:33,359
then we assume

861
00:36:31,440 --> 00:36:35,359
some language

862
00:36:33,359 --> 00:36:38,400
is decidable

863
00:36:35,359 --> 00:36:41,280
then that's decider can help us

864
00:36:38,400 --> 00:36:43,520
to decide atm

865
00:36:41,280 --> 00:36:43,520
okay

866
00:36:43,599 --> 00:36:50,320
so by abstracting such

867
00:36:46,400 --> 00:36:51,200
this kind of proof we can

868
00:36:50,320 --> 00:36:53,359
prove

869
00:36:51,200 --> 00:36:56,079
rice theorem

870
00:36:53,359 --> 00:36:59,760
that is we can prove

871
00:36:56,079 --> 00:37:02,480
all together a lot of languages to be

872
00:36:59,760 --> 00:37:05,200
undecidable at the same time

873
00:37:02,480 --> 00:37:09,599
we want to prove that

874
00:37:05,200 --> 00:37:11,040
the previous proof structure can also be

875
00:37:09,599 --> 00:37:13,280
used to do

876
00:37:11,040 --> 00:37:16,400
similar things

877
00:37:13,280 --> 00:37:18,320
to prove the undecidability of many

878
00:37:16,400 --> 00:37:19,280
languages

879
00:37:18,320 --> 00:37:20,400
okay

880
00:37:19,280 --> 00:37:24,000
so

881
00:37:20,400 --> 00:37:27,200
let's define the first so that p

882
00:37:24,000 --> 00:37:30,720
be any non-trivial property of the

883
00:37:27,200 --> 00:37:31,760
language of a turing machine

884
00:37:30,720 --> 00:37:34,640
okay

885
00:37:31,760 --> 00:37:38,640
and the property just

886
00:37:34,640 --> 00:37:41,480
you know just uh it's just a language

887
00:37:38,640 --> 00:37:44,000
property is just a language

888
00:37:41,480 --> 00:37:45,839
consisting of turing machine

889
00:37:44,000 --> 00:37:48,160
descriptions

890
00:37:45,839 --> 00:37:49,760
and you can see that etn

891
00:37:48,160 --> 00:37:51,520
or regular tm

892
00:37:49,760 --> 00:37:53,040
this kind of language

893
00:37:51,520 --> 00:37:54,640
the string of

894
00:37:53,040 --> 00:37:57,280
in the language

895
00:37:54,640 --> 00:37:59,520
is turing machine descriptions or you

896
00:37:57,280 --> 00:38:01,200
can consider them as you know programs

897
00:37:59,520 --> 00:38:02,640
like java programs the program doesn't

898
00:38:01,200 --> 00:38:06,079
matter

899
00:38:02,640 --> 00:38:10,240
so property is just a set of programs

900
00:38:06,079 --> 00:38:12,480
you can think of consider it as that

901
00:38:10,240 --> 00:38:15,760
and

902
00:38:12,480 --> 00:38:18,880
if such a language

903
00:38:15,760 --> 00:38:21,280
fulfills satisfies two conditions

904
00:38:18,880 --> 00:38:24,000
first non-trivial

905
00:38:21,280 --> 00:38:26,000
what is non-trivial

906
00:38:24,000 --> 00:38:28,720
it is very easy that

907
00:38:26,000 --> 00:38:32,640
as long as it contains

908
00:38:28,720 --> 00:38:35,200
it contains some but not all turing

909
00:38:32,640 --> 00:38:40,000
machine descriptions that's what we call

910
00:38:35,200 --> 00:38:41,599
con uh noun trivial so if you have a

911
00:38:40,000 --> 00:38:44,880
property

912
00:38:41,599 --> 00:38:47,520
contains no machines which is empty set

913
00:38:44,880 --> 00:38:49,599
right then that's trivial

914
00:38:47,520 --> 00:38:52,880
it's trivial tribute right

915
00:38:49,599 --> 00:38:55,280
and the other cases of trivial is that

916
00:38:52,880 --> 00:38:58,160
you define

917
00:38:55,280 --> 00:38:59,440
a set of two machine description

918
00:38:58,160 --> 00:39:02,720
contains

919
00:38:59,440 --> 00:39:04,800
all possible turing machines then that's

920
00:39:02,720 --> 00:39:06,720
also trivial because you have all two

921
00:39:04,800 --> 00:39:09,200
machines there's no

922
00:39:06,720 --> 00:39:12,480
problem to decide whether or not a given

923
00:39:09,200 --> 00:39:15,680
tier machine is in the set because it is

924
00:39:12,480 --> 00:39:18,320
right and the previous case is that is

925
00:39:15,680 --> 00:39:19,280
the machine it not said no it's not

926
00:39:18,320 --> 00:39:22,320
because

927
00:39:19,280 --> 00:39:24,320
your set is empty so either empty or

928
00:39:22,320 --> 00:39:26,480
contains all possible two machines they

929
00:39:24,320 --> 00:39:29,520
are trivial otherwise

930
00:39:26,480 --> 00:39:32,560
as long as

931
00:39:29,520 --> 00:39:34,320
the property we are talking about

932
00:39:32,560 --> 00:39:35,680
is non-empty

933
00:39:34,320 --> 00:39:38,320
and also

934
00:39:35,680 --> 00:39:42,720
not all two machines then it's

935
00:39:38,320 --> 00:39:45,200
non-trivial okay so that contains uh

936
00:39:42,720 --> 00:39:48,000
there will be a lot of

937
00:39:45,200 --> 00:39:51,680
uh properties non-trivial right

938
00:39:48,000 --> 00:39:54,800
and the second one is that the property

939
00:39:51,680 --> 00:39:58,400
must be determined by

940
00:39:54,800 --> 00:40:01,200
the language recognized

941
00:39:58,400 --> 00:40:02,320
of that turing machine

942
00:40:01,200 --> 00:40:05,520
okay

943
00:40:02,320 --> 00:40:07,760
and as long as

944
00:40:05,520 --> 00:40:10,880
as long as two

945
00:40:07,760 --> 00:40:12,160
turing machine recognizing the same

946
00:40:10,880 --> 00:40:13,839
language

947
00:40:12,160 --> 00:40:14,960
they must be

948
00:40:13,839 --> 00:40:17,200
in

949
00:40:14,960 --> 00:40:21,280
the property together

950
00:40:17,200 --> 00:40:24,800
or out of the property together

951
00:40:21,280 --> 00:40:27,200
okay in the property together out or out

952
00:40:24,800 --> 00:40:31,760
of property together so let's look at

953
00:40:27,200 --> 00:40:31,760
the previous example so regular tm

954
00:40:33,200 --> 00:40:39,440
does the language of regular tm that's

955
00:40:36,319 --> 00:40:40,240
regular tn fulfill the two condition

956
00:40:39,440 --> 00:40:41,359
yes

957
00:40:40,240 --> 00:40:44,240
it is

958
00:40:41,359 --> 00:40:46,640
why because firstly

959
00:40:44,240 --> 00:40:47,839
firstly

960
00:40:46,640 --> 00:40:49,440
there is

961
00:40:47,839 --> 00:40:51,359
actually there are

962
00:40:49,440 --> 00:40:53,920
turing machines

963
00:40:51,359 --> 00:40:56,720
recognizing regular languages right

964
00:40:53,920 --> 00:41:00,640
that's no problem so it contains

965
00:40:56,720 --> 00:41:02,800
two machines it it is non-empty

966
00:41:00,640 --> 00:41:06,000
on the other hand

967
00:41:02,800 --> 00:41:07,359
thus regular tn contains all possible

968
00:41:06,000 --> 00:41:08,720
two machines

969
00:41:07,359 --> 00:41:11,119
of course not

970
00:41:08,720 --> 00:41:13,440
right there are two machines recognizing

971
00:41:11,119 --> 00:41:16,480
non-regular language

972
00:41:13,440 --> 00:41:17,200
even non-context-free language right

973
00:41:16,480 --> 00:41:20,400
so

974
00:41:17,200 --> 00:41:23,440
regular tm is non-trivial because

975
00:41:20,400 --> 00:41:25,359
it contains some but not all

976
00:41:23,440 --> 00:41:26,880
to machines

977
00:41:25,359 --> 00:41:28,240
and

978
00:41:26,880 --> 00:41:29,760
for the second

979
00:41:28,240 --> 00:41:33,200
condition

980
00:41:29,760 --> 00:41:34,480
if a regular language that say a regular

981
00:41:33,200 --> 00:41:35,680
language a

982
00:41:34,480 --> 00:41:38,880
and we can

983
00:41:35,680 --> 00:41:41,280
surely know that if there is a machine

984
00:41:38,880 --> 00:41:43,440
m1

985
00:41:41,280 --> 00:41:44,240
recognizing a

986
00:41:43,440 --> 00:41:47,359
and

987
00:41:44,240 --> 00:41:49,760
also an other turing machine m2

988
00:41:47,359 --> 00:41:52,160
recognizing the same language

989
00:41:49,760 --> 00:41:53,599
they are both in

990
00:41:52,160 --> 00:41:55,040
regular tn

991
00:41:53,599 --> 00:41:56,800
right

992
00:41:55,040 --> 00:41:58,880
or you have a

993
00:41:56,800 --> 00:42:03,160
regular uh turing machine m a

994
00:41:58,880 --> 00:42:03,160
recognizing let's say

995
00:42:03,280 --> 00:42:08,960
a noun regular language

996
00:42:06,640 --> 00:42:11,520
and all the machines

997
00:42:08,960 --> 00:42:15,359
recognizing the same language they are

998
00:42:11,520 --> 00:42:16,640
out they are not in regular tn

999
00:42:15,359 --> 00:42:19,760
right so

1000
00:42:16,640 --> 00:42:23,520
regular tn fulfill that

1001
00:42:19,760 --> 00:42:24,319
uh that two con those two conditions

1002
00:42:23,520 --> 00:42:27,920
and

1003
00:42:24,319 --> 00:42:30,640
then the same situation goes to etn

1004
00:42:27,920 --> 00:42:32,560
right there are two machines

1005
00:42:30,640 --> 00:42:34,880
recognizing empty set

1006
00:42:32,560 --> 00:42:38,079
and also two machines not recognizing

1007
00:42:34,880 --> 00:42:39,280
empty set so it's non-trivial

1008
00:42:38,079 --> 00:42:40,640
and

1009
00:42:39,280 --> 00:42:42,880
all

1010
00:42:40,640 --> 00:42:45,440
actually all turing machines in the set

1011
00:42:42,880 --> 00:42:48,240
recognizing exactly the same language

1012
00:42:45,440 --> 00:42:49,280
which is empty set as long as your

1013
00:42:48,240 --> 00:42:50,319
machine

1014
00:42:49,280 --> 00:42:52,400
that's

1015
00:42:50,319 --> 00:42:55,760
as long as a machine does not

1016
00:42:52,400 --> 00:42:59,839
recognize empty set they are not in etm

1017
00:42:55,760 --> 00:43:01,520
so it fulfills the

1018
00:42:59,839 --> 00:43:02,480
second conditions too

1019
00:43:01,520 --> 00:43:03,839
right

1020
00:43:02,480 --> 00:43:06,480
and

1021
00:43:03,839 --> 00:43:07,680
you may ask okay so what kind of

1022
00:43:06,480 --> 00:43:09,760
property

1023
00:43:07,680 --> 00:43:13,680
uh

1024
00:43:09,760 --> 00:43:15,440
or what kind of turing machine

1025
00:43:13,680 --> 00:43:16,800
set

1026
00:43:15,440 --> 00:43:18,079
does not

1027
00:43:16,800 --> 00:43:20,079
fulfill the

1028
00:43:18,079 --> 00:43:22,720
second

1029
00:43:20,079 --> 00:43:24,240
condition it's quite easy if you define

1030
00:43:22,720 --> 00:43:25,200
a turing machine

1031
00:43:24,240 --> 00:43:28,640
set

1032
00:43:25,200 --> 00:43:30,960
let's say a turing machine set

1033
00:43:28,640 --> 00:43:32,240
and m is a tn

1034
00:43:30,960 --> 00:43:35,680
okay

1035
00:43:32,240 --> 00:43:35,680
and n has

1036
00:43:36,240 --> 00:43:41,440
uh let's say 100

1037
00:43:38,640 --> 00:43:44,240
states

1038
00:43:41,440 --> 00:43:46,319
okay can we do that yes we can we can

1039
00:43:44,240 --> 00:43:48,640
say that okay i have a set of two

1040
00:43:46,319 --> 00:43:50,720
machine description of which

1041
00:43:48,640 --> 00:43:53,839
all the two machines has

1042
00:43:50,720 --> 00:43:56,480
exactly 100

1043
00:43:53,839 --> 00:43:58,880
okay so that's a tuning machine set

1044
00:43:56,480 --> 00:44:01,119
however this two machine set does not

1045
00:43:58,880 --> 00:44:02,720
fulfill the second condition because if

1046
00:44:01,119 --> 00:44:04,960
you have an

1047
00:44:02,720 --> 00:44:06,839
m1

1048
00:44:04,960 --> 00:44:10,400
in the

1049
00:44:06,839 --> 00:44:14,400
set and you know the language

1050
00:44:10,400 --> 00:44:16,319
recognizing by m1 then you add one

1051
00:44:14,400 --> 00:44:17,440
more useless

1052
00:44:16,319 --> 00:44:20,240
state

1053
00:44:17,440 --> 00:44:23,359
which will never be going to and out of

1054
00:44:20,240 --> 00:44:25,280
the states so you create m2

1055
00:44:23,359 --> 00:44:26,560
since that state

1056
00:44:25,280 --> 00:44:28,640
is useless

1057
00:44:26,560 --> 00:44:32,560
so the language of these two machine

1058
00:44:28,640 --> 00:44:36,880
will be identical however since m2 has

1059
00:44:32,560 --> 00:44:37,839
101 states it's not in a okay

1060
00:44:36,880 --> 00:44:39,119
so

1061
00:44:37,839 --> 00:44:40,400
this kind of

1062
00:44:39,119 --> 00:44:43,040
definition

1063
00:44:40,400 --> 00:44:45,680
of turing machines that it does not

1064
00:44:43,040 --> 00:44:48,319
fulfill the second condition

1065
00:44:45,680 --> 00:44:48,319
okay so

1066
00:44:49,040 --> 00:44:55,200
if we have a property

1067
00:44:52,480 --> 00:44:57,920
fulfills the true condition

1068
00:44:55,200 --> 00:44:59,520
then we can prove that

1069
00:44:57,920 --> 00:45:03,040
such

1070
00:44:59,520 --> 00:45:04,560
a such set of turing machines

1071
00:45:03,040 --> 00:45:06,560
is an

1072
00:45:04,560 --> 00:45:08,240
undecidable language

1073
00:45:06,560 --> 00:45:10,560
okay

1074
00:45:08,240 --> 00:45:10,560
all

1075
00:45:11,680 --> 00:45:15,599
properties satisfying the two conditions

1076
00:45:13,839 --> 00:45:16,640
here

1077
00:45:15,599 --> 00:45:19,200
are

1078
00:45:16,640 --> 00:45:20,319
undecidable we can prove them all

1079
00:45:19,200 --> 00:45:21,680
together

1080
00:45:20,319 --> 00:45:24,560
okay

1081
00:45:21,680 --> 00:45:24,560
and the proof is

1082
00:45:24,880 --> 00:45:29,760
straightforward if you

1083
00:45:27,119 --> 00:45:31,520
consider what we already have for etm

1084
00:45:29,760 --> 00:45:34,160
and regular tm

1085
00:45:31,520 --> 00:45:34,160
let's say

1086
00:45:36,480 --> 00:45:42,400
firstly we assume that p is a decidable

1087
00:45:39,440 --> 00:45:44,160
language okay

1088
00:45:42,400 --> 00:45:48,079
because we want to do

1089
00:45:44,160 --> 00:45:50,480
the proof by contradiction so we uh

1090
00:45:48,079 --> 00:45:55,520
assume that p is undecided sorry

1091
00:45:50,480 --> 00:45:57,680
decidable so there will be a decider rp

1092
00:45:55,520 --> 00:45:59,119
decides p decides p

1093
00:45:57,680 --> 00:46:01,760
right

1094
00:45:59,119 --> 00:46:05,760
and then we construct

1095
00:46:01,760 --> 00:46:10,000
atms decider by using rp here as what we

1096
00:46:05,760 --> 00:46:12,000
did for etm and regular tn

1097
00:46:10,000 --> 00:46:15,760
okay firstly

1098
00:46:12,000 --> 00:46:17,040
with that a regular artery machine t

1099
00:46:15,760 --> 00:46:18,480
uh

1100
00:46:17,040 --> 00:46:21,920
empty set

1101
00:46:18,480 --> 00:46:23,200
be a turing machine that always rejects

1102
00:46:21,920 --> 00:46:26,760
that means

1103
00:46:23,200 --> 00:46:26,760
l of t

1104
00:46:28,160 --> 00:46:34,800
l of t empty is empty set

1105
00:46:31,920 --> 00:46:36,480
now we assume that

1106
00:46:34,800 --> 00:46:39,280
this turing machine

1107
00:46:36,480 --> 00:46:42,400
is not in p

1108
00:46:39,280 --> 00:46:44,000
okay without loss of generality

1109
00:46:42,400 --> 00:46:46,720
why can we do that

1110
00:46:44,000 --> 00:46:49,680
because if language

1111
00:46:46,720 --> 00:46:49,680
is decidable

1112
00:46:50,079 --> 00:46:54,839
the complement of that language is

1113
00:46:52,319 --> 00:46:57,440
decidable too

1114
00:46:54,839 --> 00:47:00,880
right because

1115
00:46:57,440 --> 00:47:03,040
if a language is decidable then you have

1116
00:47:00,880 --> 00:47:05,280
a decider for the language

1117
00:47:03,040 --> 00:47:06,720
then you just need to

1118
00:47:05,280 --> 00:47:09,520
change

1119
00:47:06,720 --> 00:47:11,760
the accept state and reject state to

1120
00:47:09,520 --> 00:47:14,240
create

1121
00:47:11,760 --> 00:47:16,880
the decider for

1122
00:47:14,240 --> 00:47:19,520
the complement of that language

1123
00:47:16,880 --> 00:47:19,520
that's why

1124
00:47:20,000 --> 00:47:24,000
if you have a language which is

1125
00:47:21,599 --> 00:47:27,280
decidable the complement of that

1126
00:47:24,000 --> 00:47:28,079
language is also decidable

1127
00:47:27,280 --> 00:47:29,760
okay

1128
00:47:28,079 --> 00:47:31,200
so

1129
00:47:29,760 --> 00:47:33,920
now

1130
00:47:31,200 --> 00:47:35,760
if we want we since we assume p is

1131
00:47:33,920 --> 00:47:40,000
decidable

1132
00:47:35,760 --> 00:47:41,839
then p bar is assumed to be decidable

1133
00:47:40,000 --> 00:47:44,640
too right

1134
00:47:41,839 --> 00:47:44,640
so let's see

1135
00:47:45,040 --> 00:47:50,319
the machine recognizing empty set

1136
00:47:49,119 --> 00:47:54,720
in p

1137
00:47:50,319 --> 00:47:56,960
over p bar if it is in p

1138
00:47:54,720 --> 00:47:59,040
then

1139
00:47:56,960 --> 00:48:00,640
we consider

1140
00:47:59,040 --> 00:48:03,040
p-bar

1141
00:48:00,640 --> 00:48:07,839
that means we consider

1142
00:48:03,040 --> 00:48:07,839
the language we consider the language

1143
00:48:08,319 --> 00:48:10,800
which contains

1144
00:48:10,079 --> 00:48:15,599
no

1145
00:48:10,800 --> 00:48:15,599
turing machine recognizing empty set

1146
00:48:15,680 --> 00:48:19,599
okay

1147
00:48:16,559 --> 00:48:23,359
so if you want to apply

1148
00:48:19,599 --> 00:48:26,960
rice theorem which we are going to prove

1149
00:48:23,359 --> 00:48:28,079
to regular tn and etn

1150
00:48:26,960 --> 00:48:30,640
we

1151
00:48:28,079 --> 00:48:32,880
actually are proving

1152
00:48:30,640 --> 00:48:33,680
e t m bar

1153
00:48:32,880 --> 00:48:36,079
or

1154
00:48:33,680 --> 00:48:37,520
regular tm bar

1155
00:48:36,079 --> 00:48:40,319
undecidable

1156
00:48:37,520 --> 00:48:42,079
okay if you directly use rice tea rice

1157
00:48:40,319 --> 00:48:45,599
theorem to prove

1158
00:48:42,079 --> 00:48:49,200
regular tm or etm we are actually

1159
00:48:45,599 --> 00:48:51,280
proving etm bar undecidable and regular

1160
00:48:49,200 --> 00:48:54,160
tm bar undecidable

1161
00:48:51,280 --> 00:48:56,640
since etm bar is undecidable so etm is

1162
00:48:54,160 --> 00:48:58,079
undecidable and the same goes to regular

1163
00:48:56,640 --> 00:48:59,200
tier

1164
00:48:58,079 --> 00:49:03,319
okay so

1165
00:48:59,200 --> 00:49:03,319
you have to be uh

1166
00:49:03,359 --> 00:49:08,480
we have to be clear about that so some

1167
00:49:06,160 --> 00:49:10,720
of you may think of it's weird because

1168
00:49:08,480 --> 00:49:12,800
uh

1169
00:49:10,720 --> 00:49:16,000
turing machine recognizing empty set is

1170
00:49:12,800 --> 00:49:19,040
in etn it's actually etm right and in

1171
00:49:16,000 --> 00:49:22,319
regular tm so how can you apply rice

1172
00:49:19,040 --> 00:49:24,800
theorem actually we if you apply rice

1173
00:49:22,319 --> 00:49:27,040
theorem we are talking about etm bar

1174
00:49:24,800 --> 00:49:28,400
undecidable and regular t and bar

1175
00:49:27,040 --> 00:49:29,280
undecidable

1176
00:49:28,400 --> 00:49:32,319
okay

1177
00:49:29,280 --> 00:49:34,960
so we assume that

1178
00:49:32,319 --> 00:49:38,240
the lang the machine recognizing empty

1179
00:49:34,960 --> 00:49:38,240
set not in p

1180
00:49:39,040 --> 00:49:46,559
okay because you you can proceed p bar

1181
00:49:43,119 --> 00:49:46,559
with p bar instead of p

1182
00:49:46,800 --> 00:49:50,480
because p is non-trivial

1183
00:49:49,520 --> 00:49:51,599
then

1184
00:49:50,480 --> 00:49:52,559
we can

1185
00:49:51,599 --> 00:49:54,720
get

1186
00:49:52,559 --> 00:49:56,640
one

1187
00:49:54,720 --> 00:49:59,599
turing machine out of p because there

1188
00:49:56,640 --> 00:50:04,400
are two machines in p right we just get

1189
00:49:59,599 --> 00:50:04,400
one out of it any one and you know that

1190
00:50:04,880 --> 00:50:11,200
the one recognizing empty set is not in

1191
00:50:07,359 --> 00:50:13,359
p so any machine you get from p

1192
00:50:11,200 --> 00:50:14,319
will

1193
00:50:13,359 --> 00:50:16,160
not

1194
00:50:14,319 --> 00:50:18,880
be recognizing

1195
00:50:16,160 --> 00:50:20,960
empty set that's important okay

1196
00:50:18,880 --> 00:50:23,200
then we construct

1197
00:50:20,960 --> 00:50:24,839
atm decider

1198
00:50:23,200 --> 00:50:28,000
to distinguish

1199
00:50:24,839 --> 00:50:31,520
between the machine recognizing empty

1200
00:50:28,000 --> 00:50:32,030
set or the machine recognizing

1201
00:50:31,520 --> 00:50:34,000
some

1202
00:50:32,030 --> 00:50:36,559
[Music]

1203
00:50:34,000 --> 00:50:36,559
language

1204
00:50:38,319 --> 00:50:42,640
for the property

1205
00:50:40,640 --> 00:50:46,640
defined by that property

1206
00:50:42,640 --> 00:50:48,960
okay which will definitely be not empty

1207
00:50:46,640 --> 00:50:51,760
that's what we want to do here

1208
00:50:48,960 --> 00:50:54,880
so the construction process is easy you

1209
00:50:51,760 --> 00:50:57,520
have already uh

1210
00:50:54,880 --> 00:50:59,440
look at etm and regular tm just reverse

1211
00:50:57,520 --> 00:51:01,040
okay not reverse

1212
00:50:59,440 --> 00:51:01,920
very similar to that

1213
00:51:01,040 --> 00:51:04,079
so

1214
00:51:01,920 --> 00:51:05,599
the decider for atn

1215
00:51:04,079 --> 00:51:09,119
on the input

1216
00:51:05,599 --> 00:51:12,559
of the machine input pair

1217
00:51:09,119 --> 00:51:13,520
we construct a turing machine mw

1218
00:51:12,559 --> 00:51:14,720
like

1219
00:51:13,520 --> 00:51:17,280
this one

1220
00:51:14,720 --> 00:51:18,720
so for its own input string

1221
00:51:17,280 --> 00:51:23,839
no matter what

1222
00:51:18,720 --> 00:51:23,839
mw will simulate m on w

1223
00:51:23,920 --> 00:51:27,839
okay

1224
00:51:24,880 --> 00:51:29,760
so as long as we do n on w there are

1225
00:51:27,839 --> 00:51:31,119
three possibilities right

1226
00:51:29,760 --> 00:51:34,000
first one

1227
00:51:31,119 --> 00:51:34,000
runs forever

1228
00:51:35,200 --> 00:51:40,960
right first one runs forever so if mw

1229
00:51:39,280 --> 00:51:43,680
gets stuck on

1230
00:51:40,960 --> 00:51:43,680
this step

1231
00:51:44,000 --> 00:51:47,359
and w

1232
00:51:46,000 --> 00:51:50,480
will be

1233
00:51:47,359 --> 00:51:53,040
recognizing empty set right because

1234
00:51:50,480 --> 00:51:54,079
no matter which string is the input

1235
00:51:53,040 --> 00:51:58,160
string

1236
00:51:54,079 --> 00:52:01,440
the first step of m on w of m w

1237
00:51:58,160 --> 00:52:04,079
is to simulate m on w and get stuck

1238
00:52:01,440 --> 00:52:06,800
so it will never accept any string so

1239
00:52:04,079 --> 00:52:09,440
it's recognizing empty set

1240
00:52:06,800 --> 00:52:11,839
okay so that's the first situation

1241
00:52:09,440 --> 00:52:14,480
the second situation is that

1242
00:52:11,839 --> 00:52:16,400
m reject w

1243
00:52:14,480 --> 00:52:19,599
it holds and reject

1244
00:52:16,400 --> 00:52:23,200
so if it holds and reject

1245
00:52:19,599 --> 00:52:26,960
then we do reject

1246
00:52:23,200 --> 00:52:28,160
and remember that this reject reject

1247
00:52:26,960 --> 00:52:30,640
any

1248
00:52:28,160 --> 00:52:32,319
input string of nw so

1249
00:52:30,640 --> 00:52:34,319
for the second okay this is the first

1250
00:52:32,319 --> 00:52:36,720
one this is the second one for the

1251
00:52:34,319 --> 00:52:39,839
second situation

1252
00:52:36,720 --> 00:52:40,720
also recognizing empty sets

1253
00:52:39,839 --> 00:52:43,440
okay

1254
00:52:40,720 --> 00:52:48,240
then the third

1255
00:52:43,440 --> 00:52:49,520
situation is n accept w so if accept

1256
00:52:48,240 --> 00:52:51,599
we do the

1257
00:52:49,520 --> 00:52:54,720
second step here

1258
00:52:51,599 --> 00:52:58,480
then mw simulates t

1259
00:52:54,720 --> 00:53:04,480
which we get from p right

1260
00:52:58,480 --> 00:53:06,880
which we get from p on its own input

1261
00:53:04,480 --> 00:53:08,079
then we just see what

1262
00:53:06,880 --> 00:53:13,040
t

1263
00:53:08,079 --> 00:53:14,559
will do and mw will do what t will do so

1264
00:53:13,040 --> 00:53:16,480
three

1265
00:53:14,559 --> 00:53:22,720
well what

1266
00:53:16,480 --> 00:53:24,079
language of mw will be language of t

1267
00:53:22,720 --> 00:53:25,520
will be

1268
00:53:24,079 --> 00:53:27,520
not

1269
00:53:25,520 --> 00:53:28,400
empty there

1270
00:53:27,520 --> 00:53:30,400
right

1271
00:53:28,400 --> 00:53:33,359
then we just need to

1272
00:53:30,400 --> 00:53:35,599
use rp

1273
00:53:33,359 --> 00:53:35,599
and

1274
00:53:35,760 --> 00:53:39,680
let's mw

1275
00:53:38,880 --> 00:53:42,640
be

1276
00:53:39,680 --> 00:53:43,520
the input of rp

1277
00:53:42,640 --> 00:53:46,559
since

1278
00:53:43,520 --> 00:53:49,520
empty set is not in p

1279
00:53:46,559 --> 00:53:53,200
if rp say yes

1280
00:53:49,520 --> 00:53:55,200
rp say yes that means

1281
00:53:53,200 --> 00:53:57,680
lo of mw

1282
00:53:55,200 --> 00:53:58,960
is lo of t

1283
00:53:57,680 --> 00:54:02,480
is

1284
00:53:58,960 --> 00:54:05,200
not empty set and we know m

1285
00:54:02,480 --> 00:54:07,119
accept w

1286
00:54:05,200 --> 00:54:11,280
since n accept w

1287
00:54:07,119 --> 00:54:13,359
s as a decider for atm s do

1288
00:54:11,280 --> 00:54:14,319
accept

1289
00:54:13,359 --> 00:54:16,720
okay

1290
00:54:14,319 --> 00:54:18,960
otherwise if

1291
00:54:16,720 --> 00:54:20,480
says no

1292
00:54:18,960 --> 00:54:22,720
that means

1293
00:54:20,480 --> 00:54:22,720
m

1294
00:54:23,200 --> 00:54:28,720
error of mw is empty set

1295
00:54:25,520 --> 00:54:30,319
and empty set is not in p so

1296
00:54:28,720 --> 00:54:32,160
we do a reject

1297
00:54:30,319 --> 00:54:35,359
we don't know

1298
00:54:32,160 --> 00:54:38,000
it is situation one or two we don't know

1299
00:54:35,359 --> 00:54:41,920
we don't know if m on w runs forever or

1300
00:54:38,000 --> 00:54:41,920
every jw we know that

1301
00:54:42,640 --> 00:54:49,839
mw recognizing empty set and we know

1302
00:54:46,319 --> 00:54:50,720
that m does not accept w

1303
00:54:49,839 --> 00:54:54,880
and

1304
00:54:50,720 --> 00:54:57,520
as atm's decider we reject

1305
00:54:54,880 --> 00:54:59,359
our input

1306
00:54:57,520 --> 00:55:02,160
okay

1307
00:54:59,359 --> 00:55:05,920
so the key point is also that we use

1308
00:55:02,160 --> 00:55:08,160
whether or not and access w as a switch

1309
00:55:05,920 --> 00:55:09,760
to change the behavior to determine the

1310
00:55:08,160 --> 00:55:12,640
behavior of

1311
00:55:09,760 --> 00:55:13,520
the machine here the machine mw here

1312
00:55:12,640 --> 00:55:15,040
and

1313
00:55:13,520 --> 00:55:16,960
that's the

1314
00:55:15,040 --> 00:55:18,240
decider for that

1315
00:55:16,960 --> 00:55:21,680
language

1316
00:55:18,240 --> 00:55:22,480
assume to be existence the decider

1317
00:55:21,680 --> 00:55:26,880
to

1318
00:55:22,480 --> 00:55:29,599
to determine whether or not the mw

1319
00:55:26,880 --> 00:55:31,280
in or out of the property

1320
00:55:29,599 --> 00:55:33,760
so

1321
00:55:31,280 --> 00:55:35,920
this one is wrong here so that would be

1322
00:55:33,760 --> 00:55:37,200
m w

1323
00:55:35,920 --> 00:55:41,839
okay

1324
00:55:37,200 --> 00:55:43,920
therefore if m uh therefore m w is in p

1325
00:55:41,839 --> 00:55:46,960
if and only if

1326
00:55:43,920 --> 00:55:46,960
m accept w

1327
00:55:47,040 --> 00:55:50,960
okay

1328
00:55:49,119 --> 00:55:55,359
so

1329
00:55:50,960 --> 00:55:55,359
we know that atm decider cannot be

1330
00:55:55,599 --> 00:55:59,440
cannot exist right

1331
00:55:57,599 --> 00:56:01,680
so

1332
00:55:59,440 --> 00:56:03,040
as long as the decider flow

1333
00:56:01,680 --> 00:56:04,559
p

1334
00:56:03,040 --> 00:56:07,280
exists

1335
00:56:04,559 --> 00:56:10,400
atm designer can be constructed so

1336
00:56:07,280 --> 00:56:13,040
you know p must be undecidable

1337
00:56:10,400 --> 00:56:15,520
so that's right theorem

1338
00:56:13,040 --> 00:56:16,480
you can also see that we modulize the

1339
00:56:15,520 --> 00:56:19,359
proof

1340
00:56:16,480 --> 00:56:22,079
and you just need to

1341
00:56:19,359 --> 00:56:22,079
change some

1342
00:56:23,839 --> 00:56:28,559
let's say module like this one then you

1343
00:56:26,480 --> 00:56:31,200
can prove all

1344
00:56:28,559 --> 00:56:32,960
properties all turing machine

1345
00:56:31,200 --> 00:56:37,040
description sets

1346
00:56:32,960 --> 00:56:39,839
having uh fulfilling the two conditions

1347
00:56:37,040 --> 00:56:41,520
these are undecidable okay so that's

1348
00:56:39,839 --> 00:56:42,960
right there

1349
00:56:41,520 --> 00:56:45,599
so you can

1350
00:56:42,960 --> 00:56:48,960
easily

1351
00:56:45,599 --> 00:56:48,960
define that let's say

1352
00:56:49,040 --> 00:56:52,319
since

1353
00:56:50,160 --> 00:56:55,119
since we know that every context free

1354
00:56:52,319 --> 00:56:56,839
language is a decidable language so if

1355
00:56:55,119 --> 00:57:00,960
you

1356
00:56:56,839 --> 00:57:05,839
uh if you uh define a turing machine

1357
00:57:00,960 --> 00:57:06,880
description set like cfl to machine set

1358
00:57:05,839 --> 00:57:08,960
is that

1359
00:57:06,880 --> 00:57:10,880
all turing machine

1360
00:57:08,960 --> 00:57:16,000
m is a tn

1361
00:57:10,880 --> 00:57:16,000
and recognizing context free language

1362
00:57:16,079 --> 00:57:22,799
then you know that by using rice theorem

1363
00:57:18,960 --> 00:57:24,480
it is decidable why because firstly it

1364
00:57:22,799 --> 00:57:26,720
is non-trivial

1365
00:57:24,480 --> 00:57:28,559
there are two machines recognizing

1366
00:57:26,720 --> 00:57:29,280
context free language and there there

1367
00:57:28,559 --> 00:57:31,040
are

1368
00:57:29,280 --> 00:57:33,119
material machines that

1369
00:57:31,040 --> 00:57:35,599
not recognizing contextual language

1370
00:57:33,119 --> 00:57:38,960
firstly and secondly

1371
00:57:35,599 --> 00:57:42,960
recognizing same language will be both

1372
00:57:38,960 --> 00:57:44,000
in all o2 machine recognizing a language

1373
00:57:42,960 --> 00:57:45,520
will be

1374
00:57:44,000 --> 00:57:48,720
in the in

1375
00:57:45,520 --> 00:57:51,680
this language or out of this language so

1376
00:57:48,720 --> 00:57:54,480
the second conditions are fulfilled

1377
00:57:51,680 --> 00:57:56,720
then we know it is

1378
00:57:54,480 --> 00:57:57,520
this this is undecidable

1379
00:57:56,720 --> 00:58:00,319
and

1380
00:57:57,520 --> 00:58:01,839
for this particular instance we actually

1381
00:58:00,319 --> 00:58:03,040
use

1382
00:58:01,839 --> 00:58:05,319
uh

1383
00:58:03,040 --> 00:58:08,640
rice theoren to prove

1384
00:58:05,319 --> 00:58:09,599
cfltm bar on undecidable

1385
00:58:08,640 --> 00:58:12,799
okay

1386
00:58:09,599 --> 00:58:12,799
that's why because

1387
00:58:13,119 --> 00:58:16,480
empty set is a

1388
00:58:14,720 --> 00:58:18,000
context free language

1389
00:58:16,480 --> 00:58:20,000
okay

1390
00:58:18,000 --> 00:58:20,839
and we can do that

1391
00:58:20,000 --> 00:58:25,040
we can

1392
00:58:20,839 --> 00:58:26,640
uh prove a lot of languages regarding

1393
00:58:25,040 --> 00:58:29,280
turing machine

1394
00:58:26,640 --> 00:58:31,520
descriptions or programs

1395
00:58:29,280 --> 00:58:33,920
together so that means

1396
00:58:31,520 --> 00:58:36,640
in practice it may be very difficult for

1397
00:58:33,920 --> 00:58:38,480
you to write a program to determine

1398
00:58:36,640 --> 00:58:40,240
other programs behavior something like

1399
00:58:38,480 --> 00:58:41,119
that

1400
00:58:40,240 --> 00:58:43,599
and

1401
00:58:41,119 --> 00:58:45,920
but there are still other

1402
00:58:43,599 --> 00:58:47,440
languages that cannot be

1403
00:58:45,920 --> 00:58:49,760
proven

1404
00:58:47,440 --> 00:58:52,000
either decidable or undecidable by rice

1405
00:58:49,760 --> 00:58:55,119
theorem for example

1406
00:58:52,000 --> 00:58:57,440
if we do eqtm here

1407
00:58:55,119 --> 00:58:59,599
what is eqtn

1408
00:58:57,440 --> 00:59:02,880
as our naming convention we got two

1409
00:58:59,599 --> 00:59:04,480
machines they are turing machines and

1410
00:59:02,880 --> 00:59:06,000
their language

1411
00:59:04,480 --> 00:59:07,680
is the same

1412
00:59:06,000 --> 00:59:09,680
okay their language

1413
00:59:07,680 --> 00:59:12,720
is the same

1414
00:59:09,680 --> 00:59:15,280
so apparently we cannot apply

1415
00:59:12,720 --> 00:59:18,079
rice theorem on this language because

1416
00:59:15,280 --> 00:59:20,960
it's not fulfill the requirements of

1417
00:59:18,079 --> 00:59:22,720
rice theorem okay so now we want to

1418
00:59:20,960 --> 00:59:25,839
prove it

1419
00:59:22,720 --> 00:59:26,880
directly but with the similar technique

1420
00:59:25,839 --> 00:59:29,760
for

1421
00:59:26,880 --> 00:59:33,040
etm and regular tn

1422
00:59:29,760 --> 00:59:34,079
we assume a decider for eqtn

1423
00:59:33,040 --> 00:59:36,079
exists

1424
00:59:34,079 --> 00:59:37,599
so eqtm is now b

1425
00:59:36,079 --> 00:59:40,559
right problem b

1426
00:59:37,599 --> 00:59:43,200
we use the solution to problem b

1427
00:59:40,559 --> 00:59:46,640
and construct solution to problem a

1428
00:59:43,200 --> 00:59:47,440
the problem a now is etm

1429
00:59:46,640 --> 00:59:50,000
okay

1430
00:59:47,440 --> 00:59:51,680
if we can do the reduction like this

1431
00:59:50,000 --> 00:59:54,079
then

1432
00:59:51,680 --> 00:59:56,640
since we already know etm is undecidable

1433
00:59:54,079 --> 00:59:59,119
eqtn is undecidable

1434
00:59:56,640 --> 01:00:00,720
okay so what we do the same by

1435
00:59:59,119 --> 01:00:02,079
contradiction

1436
01:00:00,720 --> 01:00:06,240
we

1437
01:00:02,079 --> 01:00:06,240
assume that etm's decider r

1438
01:00:07,040 --> 01:00:11,920
exists

1439
01:00:08,079 --> 01:00:12,880
then we construct decider for etn

1440
01:00:11,920 --> 01:00:13,760
okay

1441
01:00:12,880 --> 01:00:16,960
so

1442
01:00:13,760 --> 01:00:16,960
until machine m

1443
01:00:17,200 --> 01:00:23,200
we firstly

1444
01:00:20,079 --> 01:00:25,760
build a turing machine m1

1445
01:00:23,200 --> 01:00:29,040
and error of m1

1446
01:00:25,760 --> 01:00:31,280
is empty set okay

1447
01:00:29,040 --> 01:00:34,160
it's described as rejects all inputs

1448
01:00:31,280 --> 01:00:38,079
which is recognizing empty set

1449
01:00:34,160 --> 01:00:38,079
so we can write down m1

1450
01:00:38,799 --> 01:00:42,799
our hard code m1 in

1451
01:00:41,280 --> 01:00:45,839
our

1452
01:00:42,799 --> 01:00:48,079
program and then we copy the input into

1453
01:00:45,839 --> 01:00:52,799
here and

1454
01:00:48,079 --> 01:00:54,839
use the whole thing as input to ask the

1455
01:00:52,799 --> 01:00:59,200
decider of

1456
01:00:54,839 --> 01:01:01,520
eqtn right and as long as equity n tells

1457
01:00:59,200 --> 01:01:04,799
us accept

1458
01:01:01,520 --> 01:01:06,799
what does that mean the amine error of m

1459
01:01:04,799 --> 01:01:08,480
and l of m1

1460
01:01:06,799 --> 01:01:12,720
are identical

1461
01:01:08,480 --> 01:01:16,000
and we already know of m1 is you know

1462
01:01:12,720 --> 01:01:18,799
empty set so we know and

1463
01:01:16,000 --> 01:01:19,920
recognizing empty set so we

1464
01:01:18,799 --> 01:01:21,839
accept

1465
01:01:19,920 --> 01:01:22,960
because as now

1466
01:01:21,839 --> 01:01:25,440
here

1467
01:01:22,960 --> 01:01:29,119
is the decider for etm

1468
01:01:25,440 --> 01:01:33,280
otherwise if the decider for eqtm

1469
01:01:29,119 --> 01:01:37,040
rejects that means error of m

1470
01:01:33,280 --> 01:01:39,280
and fm1 recognizing different languages

1471
01:01:37,040 --> 01:01:42,880
and we know that error of m1 recognizing

1472
01:01:39,280 --> 01:01:45,359
empty set so that would be not

1473
01:01:42,880 --> 01:01:47,200
empty the language here is not empty so

1474
01:01:45,359 --> 01:01:49,119
we reject

1475
01:01:47,200 --> 01:01:50,400
and it's not in

1476
01:01:49,119 --> 01:01:54,000
etm

1477
01:01:50,400 --> 01:01:55,520
see so that the behavior of s here is

1478
01:01:54,000 --> 01:01:58,319
definitely

1479
01:01:55,520 --> 01:02:00,079
a decider for etm

1480
01:01:58,319 --> 01:02:02,319
since we know that

1481
01:02:00,079 --> 01:02:03,680
etm's decider cannot

1482
01:02:02,319 --> 01:02:06,799
exist

1483
01:02:03,680 --> 01:02:09,599
and so we got a contradiction and the

1484
01:02:06,799 --> 01:02:14,079
contradiction here is

1485
01:02:09,599 --> 01:02:18,839
caused by the existence of eqtms decider

1486
01:02:14,079 --> 01:02:21,359
so eqtm must be undecidable

1487
01:02:18,839 --> 01:02:24,000
okay so the same

1488
01:02:21,359 --> 01:02:27,200
we use the solution to be to solve a and

1489
01:02:24,000 --> 01:02:30,640
we know a is undecidable then b is

1490
01:02:27,200 --> 01:02:34,079
undecidable because a contradiction

1491
01:02:30,640 --> 01:02:37,079
can be obtained

1492
01:02:34,079 --> 01:02:37,079
okay

