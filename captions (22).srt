1
00:00:00,799 --> 00:00:05,759
the reason why we use our turing machine

2
00:00:03,120 --> 00:00:08,800
as computational models and the turing

3
00:00:05,759 --> 00:00:11,679
machines are popular for discussing

4
00:00:08,800 --> 00:00:11,679
computation

5
00:00:12,639 --> 00:00:18,880
it's because

6
00:00:14,559 --> 00:00:21,119
two machines are closer to what we have

7
00:00:18,880 --> 00:00:23,439
for modern computers

8
00:00:21,119 --> 00:00:26,480
if you consider uh underlying

9
00:00:23,439 --> 00:00:28,800
architecture and uh

10
00:00:26,480 --> 00:00:31,279
like uh

11
00:00:28,800 --> 00:00:34,559
organize a computer organization two

12
00:00:31,279 --> 00:00:36,239
machine is pretty uh similar or close to

13
00:00:34,559 --> 00:00:39,600
what we have right now

14
00:00:36,239 --> 00:00:40,879
and the other important reason is that

15
00:00:39,600 --> 00:00:42,239
uh

16
00:00:40,879 --> 00:00:45,600
many

17
00:00:42,239 --> 00:00:49,840
variants of turing machines are

18
00:00:45,600 --> 00:00:52,320
basically equivalent to each other

19
00:00:49,840 --> 00:00:53,440
for example if we have a

20
00:00:52,320 --> 00:00:54,559
dfa

21
00:00:53,440 --> 00:00:56,879
and

22
00:00:54,559 --> 00:00:56,879
to be

23
00:00:57,280 --> 00:01:00,480
if we add

24
00:00:58,719 --> 00:01:02,800
non-deterministic

25
00:01:00,480 --> 00:01:03,680
capability to dfa

26
00:01:02,800 --> 00:01:05,920
then

27
00:01:03,680 --> 00:01:09,200
final automata becomes non-deterministic

28
00:01:05,920 --> 00:01:12,799
final automata which is nfa and we prove

29
00:01:09,200 --> 00:01:15,840
that nfn dfa i-current right

30
00:01:12,799 --> 00:01:19,439
but for pda pda is

31
00:01:15,840 --> 00:01:23,040
uh intrinsically non-deterministic if we

32
00:01:19,439 --> 00:01:27,439
if we make pda deterministic that will

33
00:01:23,040 --> 00:01:30,799
become dpda which we skipped as uh

34
00:01:27,439 --> 00:01:33,040
section 2.4 in the textbook right

35
00:01:30,799 --> 00:01:34,880
and you can if you are interested you

36
00:01:33,040 --> 00:01:36,079
can go back to

37
00:01:34,880 --> 00:01:40,400
check

38
00:01:36,079 --> 00:01:42,640
chapter 4 uh chapter 2 section 2.4

39
00:01:40,400 --> 00:01:44,399
and you will know that

40
00:01:42,640 --> 00:01:47,520
there is the gap

41
00:01:44,399 --> 00:01:50,479
of computational capability between

42
00:01:47,520 --> 00:01:52,799
pda and the dpda they are different they

43
00:01:50,479 --> 00:01:55,799
are not equivalent

44
00:01:52,799 --> 00:01:55,799
and

45
00:01:56,399 --> 00:01:59,360
as

46
00:01:57,759 --> 00:02:03,040
nfa

47
00:01:59,360 --> 00:02:05,759
if you add a stack that will become pda

48
00:02:03,040 --> 00:02:07,759
right and we know that

49
00:02:05,759 --> 00:02:10,800
nfa can recognize

50
00:02:07,759 --> 00:02:13,200
regular languages but pda can recognize

51
00:02:10,800 --> 00:02:14,720
context-free languages there is also a

52
00:02:13,200 --> 00:02:18,319
gap between

53
00:02:14,720 --> 00:02:21,040
the two type of machines and which

54
00:02:18,319 --> 00:02:21,040
are different

55
00:02:21,120 --> 00:02:26,879
which are different in

56
00:02:22,879 --> 00:02:29,120
having a stack or not so variant

57
00:02:26,879 --> 00:02:30,480
variance between computational models

58
00:02:29,120 --> 00:02:31,360
may create

59
00:02:30,480 --> 00:02:33,599
a

60
00:02:31,360 --> 00:02:34,879
difference in

61
00:02:33,599 --> 00:02:37,440
the

62
00:02:34,879 --> 00:02:38,319
capability of computation or

63
00:02:37,440 --> 00:02:40,959
the

64
00:02:38,319 --> 00:02:42,480
computational limitations

65
00:02:40,959 --> 00:02:45,680
but

66
00:02:42,480 --> 00:02:45,680
for turing machines

67
00:02:46,000 --> 00:02:51,720
variants

68
00:02:47,280 --> 00:02:51,720
many variants many uh

69
00:02:52,959 --> 00:02:58,000
variants

70
00:02:54,800 --> 00:03:01,200
we can prove that they are equivalent so

71
00:02:58,000 --> 00:03:03,440
it will it creates convenience for us to

72
00:03:01,200 --> 00:03:06,159
discussing computation

73
00:03:03,440 --> 00:03:07,440
because uh no matter we as long as we

74
00:03:06,159 --> 00:03:08,480
prove that

75
00:03:07,440 --> 00:03:10,480
uh

76
00:03:08,480 --> 00:03:11,760
we proved the equivalence between

77
00:03:10,480 --> 00:03:14,959
variants

78
00:03:11,760 --> 00:03:16,080
then we can use whatever we have

79
00:03:14,959 --> 00:03:19,200
to prove

80
00:03:16,080 --> 00:03:21,760
what we want to prove okay so that's uh

81
00:03:19,200 --> 00:03:23,120
the other important reason

82
00:03:21,760 --> 00:03:26,720
to uh

83
00:03:23,120 --> 00:03:29,280
accept turing machines as

84
00:03:26,720 --> 00:03:30,799
computational models

85
00:03:29,280 --> 00:03:33,519
so

86
00:03:30,799 --> 00:03:36,319
here we will introduce some variants of

87
00:03:33,519 --> 00:03:38,799
turing machines and the proof

88
00:03:36,319 --> 00:03:41,760
that they are equivalent

89
00:03:38,799 --> 00:03:46,159
so the first one is a k-type multi-type

90
00:03:41,760 --> 00:03:48,239
tube machine as i introduced previously

91
00:03:46,159 --> 00:03:50,239
some textbook cheat

92
00:03:48,239 --> 00:03:52,560
uh

93
00:03:50,239 --> 00:03:55,120
like three tape to machine

94
00:03:52,560 --> 00:03:56,640
as the fundamental one in their textbook

95
00:03:55,120 --> 00:04:01,599
yeah in their book

96
00:03:56,640 --> 00:04:04,159
so uh basically multi-tab turing machine

97
00:04:01,599 --> 00:04:09,519
multiple turing machines are

98
00:04:04,159 --> 00:04:10,319
that you have k tabs okay k k tips

99
00:04:09,519 --> 00:04:11,280
so

100
00:04:10,319 --> 00:04:14,799
the k

101
00:04:11,280 --> 00:04:17,359
here is a finite number like two or

102
00:04:14,799 --> 00:04:18,479
three actually one is the same machine

103
00:04:17,359 --> 00:04:21,600
basically

104
00:04:18,479 --> 00:04:23,840
okay and two or three or a very large

105
00:04:21,600 --> 00:04:27,360
number like a median

106
00:04:23,840 --> 00:04:29,280
but k is not infinite as long as k

107
00:04:27,360 --> 00:04:30,479
is finite

108
00:04:29,280 --> 00:04:32,880
then

109
00:04:30,479 --> 00:04:35,520
we have a k type 2 machine

110
00:04:32,880 --> 00:04:39,199
and since you have k tab you we we need

111
00:04:35,520 --> 00:04:41,360
to slightly modify the definition of a

112
00:04:39,199 --> 00:04:43,680
transition function as

113
00:04:41,360 --> 00:04:46,880
there is a current state of the turing

114
00:04:43,680 --> 00:04:46,880
machine and then

115
00:04:47,040 --> 00:04:53,199
the k symbols you you will

116
00:04:50,960 --> 00:04:55,040
read on the k tab

117
00:04:53,199 --> 00:04:57,680
like

118
00:04:55,040 --> 00:05:00,240
something like this if you have two tape

119
00:04:57,680 --> 00:05:03,280
uh for type one you may be reading this

120
00:05:00,240 --> 00:05:05,360
one and for tab two

121
00:05:03,280 --> 00:05:10,000
you may be reading this one something

122
00:05:05,360 --> 00:05:13,520
like that okay then according to

123
00:05:10,000 --> 00:05:13,520
your uh your state

124
00:05:13,600 --> 00:05:16,400
and

125
00:05:15,039 --> 00:05:18,960
for example

126
00:05:16,400 --> 00:05:20,160
for type one you read a for type two you

127
00:05:18,960 --> 00:05:21,600
read b

128
00:05:20,160 --> 00:05:23,840
stuff like that

129
00:05:21,600 --> 00:05:24,800
and

130
00:05:23,840 --> 00:05:27,600
give

131
00:05:24,800 --> 00:05:29,919
the transition to the other states you

132
00:05:27,600 --> 00:05:33,199
want to transition to and

133
00:05:29,919 --> 00:05:37,520
rewrite or keep the sand on the k tab

134
00:05:33,199 --> 00:05:39,840
and for each tape the head can go left

135
00:05:37,520 --> 00:05:41,120
right or or stay

136
00:05:39,840 --> 00:05:42,320
or stay

137
00:05:41,120 --> 00:05:45,120
in the

138
00:05:42,320 --> 00:05:46,960
center uh position the same location of

139
00:05:45,120 --> 00:05:47,759
the tape

140
00:05:46,960 --> 00:05:50,479
so

141
00:05:47,759 --> 00:05:51,600
for this example you may have uh transit

142
00:05:50,479 --> 00:05:55,120
to p

143
00:05:51,600 --> 00:05:56,080
and you change this symbol to c

144
00:05:55,120 --> 00:05:58,800
and

145
00:05:56,080 --> 00:06:01,120
keep the same symbol the same sorry we

146
00:05:58,800 --> 00:06:05,800
have one more thing here

147
00:06:01,120 --> 00:06:05,800
and then you go for example

148
00:06:06,000 --> 00:06:10,000
go

149
00:06:07,600 --> 00:06:10,000
right

150
00:06:10,880 --> 00:06:12,800
and

151
00:06:11,840 --> 00:06:15,120
stay

152
00:06:12,800 --> 00:06:18,319
at that position something like this

153
00:06:15,120 --> 00:06:20,400
okay so that's a k-type turing machine

154
00:06:18,319 --> 00:06:21,840
and we want to prove that

155
00:06:20,400 --> 00:06:24,319
um

156
00:06:21,840 --> 00:06:27,440
k-type turing machine case final number

157
00:06:24,319 --> 00:06:28,400
k-type turing machine is it

158
00:06:27,440 --> 00:06:30,960
is

159
00:06:28,400 --> 00:06:32,240
equivalent to

160
00:06:30,960 --> 00:06:35,120
our

161
00:06:32,240 --> 00:06:36,479
fundamental to machine okay that's one

162
00:06:35,120 --> 00:06:39,039
tab and

163
00:06:36,479 --> 00:06:40,240
you have a left hand end

164
00:06:39,039 --> 00:06:42,800
okay

165
00:06:40,240 --> 00:06:46,240
of course for this k-type tube machine

166
00:06:42,800 --> 00:06:47,759
we also have left and left-hand end for

167
00:06:46,240 --> 00:06:51,120
each tape

168
00:06:47,759 --> 00:06:53,440
though the right hand side is infinite

169
00:06:51,120 --> 00:06:55,759
then if you want to prove the

170
00:06:53,440 --> 00:06:57,759
equivalence we want to we need to prove

171
00:06:55,759 --> 00:07:01,199
two directions okay

172
00:06:57,759 --> 00:07:02,560
so our fundamental two machine

173
00:07:01,199 --> 00:07:03,919
every

174
00:07:02,560 --> 00:07:06,720
language

175
00:07:03,919 --> 00:07:09,440
or every computation can be done by our

176
00:07:06,720 --> 00:07:10,240
fundamental machine can be done

177
00:07:09,440 --> 00:07:13,599
by

178
00:07:10,240 --> 00:07:15,759
k-tap tube machine

179
00:07:13,599 --> 00:07:19,280
and also k-type 2 machine

180
00:07:15,759 --> 00:07:19,280
anything k type 2 machine

181
00:07:19,520 --> 00:07:26,960
can do can be done by our

182
00:07:22,880 --> 00:07:26,960
two machine fundamental type

183
00:07:28,000 --> 00:07:30,720
but for this

184
00:07:29,199 --> 00:07:34,080
for this

185
00:07:30,720 --> 00:07:35,759
if and only if and only if relationship

186
00:07:34,080 --> 00:07:37,680
we only need to

187
00:07:35,759 --> 00:07:40,160
uh let's say

188
00:07:37,680 --> 00:07:42,240
anything our two machine can

189
00:07:40,160 --> 00:07:44,720
do can be done by

190
00:07:42,240 --> 00:07:46,720
a category machine is trivial

191
00:07:44,720 --> 00:07:48,879
why because

192
00:07:46,720 --> 00:07:51,199
basically

193
00:07:48,879 --> 00:07:54,479
our fundamental turing machine is a

194
00:07:51,199 --> 00:07:58,479
special case of k type 2 machine with

195
00:07:54,479 --> 00:08:00,720
basically k equals 1 right so we don't

196
00:07:58,479 --> 00:08:01,759
prove this direction because that's

197
00:08:00,720 --> 00:08:02,960
trivial

198
00:08:01,759 --> 00:08:06,240
that like

199
00:08:02,960 --> 00:08:07,599
just like dfa is a special case of an

200
00:08:06,240 --> 00:08:09,280
ave

201
00:08:07,599 --> 00:08:12,479
right so

202
00:08:09,280 --> 00:08:15,199
we want to prove the other

203
00:08:12,479 --> 00:08:19,520
direction which really need to be proven

204
00:08:15,199 --> 00:08:19,520
okay so we have a theorem here

205
00:08:20,960 --> 00:08:27,199
every multi-type 2 machine has

206
00:08:24,400 --> 00:08:29,039
an equivalent single tap turing machine

207
00:08:27,199 --> 00:08:31,039
okay by single type 2 machine we mean

208
00:08:29,039 --> 00:08:32,719
the fundamental one we defined

209
00:08:31,039 --> 00:08:38,279
previously

210
00:08:32,719 --> 00:08:38,279
so how to prove the theorem here

211
00:08:46,240 --> 00:08:49,519
the idea here is that

212
00:08:50,640 --> 00:08:56,399
the first the first thing you might

213
00:08:53,200 --> 00:08:57,839
think is that okay i have a single tap

214
00:08:56,399 --> 00:09:00,240
turning machine

215
00:08:57,839 --> 00:09:03,760
like this

216
00:09:00,240 --> 00:09:06,480
we have a left hand end and

217
00:09:03,760 --> 00:09:07,519
hand side infinite right

218
00:09:06,480 --> 00:09:08,880
now

219
00:09:07,519 --> 00:09:12,800
you have

220
00:09:08,880 --> 00:09:14,560
a k type 2 machine

221
00:09:12,800 --> 00:09:17,279
okay type 2 machine

222
00:09:14,560 --> 00:09:17,279
how do you

223
00:09:17,680 --> 00:09:21,440
simulate

224
00:09:18,880 --> 00:09:24,080
the k type 2 machine in

225
00:09:21,440 --> 00:09:25,600
a single tattoo machine that's the first

226
00:09:24,080 --> 00:09:27,920
thing we want to

227
00:09:25,600 --> 00:09:29,200
think about right

228
00:09:27,920 --> 00:09:31,839
but

229
00:09:29,200 --> 00:09:33,839
think about it there is no problem the

230
00:09:31,839 --> 00:09:37,440
first thing you might think is the

231
00:09:33,839 --> 00:09:39,680
size of the storage of all the memory

232
00:09:37,440 --> 00:09:41,760
but don't forget that we have infinite

233
00:09:39,680 --> 00:09:45,200
tape

234
00:09:41,760 --> 00:09:48,000
so k infinite tape and the one infinite

235
00:09:45,200 --> 00:09:49,279
table basically is the same

236
00:09:48,000 --> 00:09:50,800
okay

237
00:09:49,279 --> 00:09:54,640
you can think about

238
00:09:50,800 --> 00:09:54,640
integer okay integer

239
00:09:55,200 --> 00:10:00,320
and odd number

240
00:09:57,680 --> 00:10:01,279
and even number

241
00:10:00,320 --> 00:10:03,519
okay

242
00:10:01,279 --> 00:10:03,519
so

243
00:10:03,680 --> 00:10:08,399
let's mark

244
00:10:05,279 --> 00:10:11,839
the tape like

245
00:10:08,399 --> 00:10:13,360
the first the first

246
00:10:11,839 --> 00:10:17,279
space second

247
00:10:13,360 --> 00:10:19,600
third fourth fifth sixth etcetera

248
00:10:17,279 --> 00:10:20,640
and the thing about you have two tape

249
00:10:19,600 --> 00:10:23,200
crack

250
00:10:20,640 --> 00:10:23,200
two tape

251
00:10:23,839 --> 00:10:29,839
and you can store

252
00:10:26,800 --> 00:10:30,800
you uh you can

253
00:10:29,839 --> 00:10:34,880
store

254
00:10:30,800 --> 00:10:38,720
one three five seven nine etc and the

255
00:10:34,880 --> 00:10:41,040
two four six eight ten etc

256
00:10:38,720 --> 00:10:42,959
right so

257
00:10:41,040 --> 00:10:44,000
in this way

258
00:10:42,959 --> 00:10:45,200
one

259
00:10:44,000 --> 00:10:48,560
single

260
00:10:45,200 --> 00:10:51,600
tape infinite tape can

261
00:10:48,560 --> 00:10:51,600
actually store

262
00:10:52,399 --> 00:10:56,000
k

263
00:10:54,560 --> 00:10:58,320
infinite tape

264
00:10:56,000 --> 00:10:58,320
okay

265
00:10:58,560 --> 00:11:03,600
the relation we want to use is slightly

266
00:11:01,040 --> 00:11:06,000
different than this one but

267
00:11:03,600 --> 00:11:09,040
this uh the the relationship we

268
00:11:06,000 --> 00:11:12,800
introduced here give you some thought to

269
00:11:09,040 --> 00:11:16,079
understand how the whole thing works

270
00:11:12,800 --> 00:11:18,640
okay so

271
00:11:16,079 --> 00:11:22,240
the idea is that

272
00:11:18,640 --> 00:11:25,760
we have a multi-tab tool machine

273
00:11:22,240 --> 00:11:28,399
for this example k equals three right

274
00:11:25,760 --> 00:11:29,360
and then we have a single type 2 machine

275
00:11:28,399 --> 00:11:32,800
here

276
00:11:29,360 --> 00:11:35,279
we want to simulate

277
00:11:32,800 --> 00:11:37,120
k-type 2 machine with our single tap

278
00:11:35,279 --> 00:11:39,760
tube machine

279
00:11:37,120 --> 00:11:41,360
okay and how to do that

280
00:11:39,760 --> 00:11:43,600
firstly

281
00:11:41,360 --> 00:11:45,760
imagine that

282
00:11:43,600 --> 00:11:48,079
initial when you want to put a

283
00:11:45,760 --> 00:11:50,000
multi-temperature machine initially the

284
00:11:48,079 --> 00:11:52,560
input is

285
00:11:50,000 --> 00:11:56,399
stored on the first tape

286
00:11:52,560 --> 00:11:58,000
okay and initially all other k minus one

287
00:11:56,399 --> 00:12:00,399
tape are

288
00:11:58,000 --> 00:12:01,200
empty

289
00:12:00,399 --> 00:12:03,760
so

290
00:12:01,200 --> 00:12:05,600
we can put

291
00:12:03,760 --> 00:12:08,240
we can design a single tab turing

292
00:12:05,600 --> 00:12:11,600
machine we can design a simple single

293
00:12:08,240 --> 00:12:15,120
tab two machine with a special character

294
00:12:11,600 --> 00:12:16,560
as separator to separate

295
00:12:15,120 --> 00:12:19,440
different tape

296
00:12:16,560 --> 00:12:22,880
of the machine you want to simulate

297
00:12:19,440 --> 00:12:25,120
and then initially we put w here

298
00:12:22,880 --> 00:12:26,079
and separate

299
00:12:25,120 --> 00:12:29,600
and then

300
00:12:26,079 --> 00:12:32,320
initially the second tab is empty right

301
00:12:29,600 --> 00:12:36,160
let's say let's do this the second tab

302
00:12:32,320 --> 00:12:40,399
is empty and the third tab is empty

303
00:12:36,160 --> 00:12:42,880
okay and of course infinite blank

304
00:12:40,399 --> 00:12:43,760
on the right hand side

305
00:12:42,880 --> 00:12:44,639
then

306
00:12:43,760 --> 00:12:46,079
we

307
00:12:44,639 --> 00:12:47,519
design

308
00:12:46,079 --> 00:12:50,160
two versions

309
00:12:47,519 --> 00:12:52,720
two versions of each

310
00:12:50,160 --> 00:12:54,959
type alphabet

311
00:12:52,720 --> 00:12:57,680
the uh

312
00:12:54,959 --> 00:12:59,200
two version is weird anyway we will make

313
00:12:57,680 --> 00:13:02,399
duplicate

314
00:12:59,200 --> 00:13:04,560
tape alphabet of each tape

315
00:13:02,399 --> 00:13:06,800
and then

316
00:13:04,560 --> 00:13:08,079
use that on our

317
00:13:06,800 --> 00:13:10,720
single tape

318
00:13:08,079 --> 00:13:14,480
for example here for the first tape the

319
00:13:10,720 --> 00:13:17,680
alphabet may be 0 and 1 right

320
00:13:14,480 --> 00:13:21,279
then we duplicate and

321
00:13:17,680 --> 00:13:22,560
we make it 0 1 low

322
00:13:21,279 --> 00:13:23,680
dot

323
00:13:22,560 --> 00:13:25,120
1

324
00:13:23,680 --> 00:13:26,399
dot

325
00:13:25,120 --> 00:13:29,040
okay

326
00:13:26,399 --> 00:13:32,480
well you can use other symbols as you

327
00:13:29,040 --> 00:13:35,680
know 0.1 dot it doesn't matter

328
00:13:32,480 --> 00:13:38,160
but it just

329
00:13:35,680 --> 00:13:38,160
it just

330
00:13:38,639 --> 00:13:43,920
it they are just symbols that we want to

331
00:13:41,120 --> 00:13:46,240
use as

332
00:13:43,920 --> 00:13:49,839
0 is same as 0

333
00:13:46,240 --> 00:13:51,120
1 as same as one but that means

334
00:13:49,839 --> 00:13:53,519
that that

335
00:13:51,120 --> 00:13:54,959
the head of that tape is at this

336
00:13:53,519 --> 00:13:58,639
location

337
00:13:54,959 --> 00:14:00,320
okay just want to carry more information

338
00:13:58,639 --> 00:14:02,720
with the symbol

339
00:14:00,320 --> 00:14:05,279
so the same thing goes to for example

340
00:14:02,720 --> 00:14:07,680
the second the type alphabet for the

341
00:14:05,279 --> 00:14:09,920
second and the third table is

342
00:14:07,680 --> 00:14:11,600
let's say a and b and c

343
00:14:09,920 --> 00:14:13,839
so we make them

344
00:14:11,600 --> 00:14:13,839
a

345
00:14:14,320 --> 00:14:19,040
b

346
00:14:15,279 --> 00:14:21,120
c and duplicate with a dot

347
00:14:19,040 --> 00:14:23,440
b dot c dot

348
00:14:21,120 --> 00:14:23,440
okay

349
00:14:24,560 --> 00:14:30,399
then

350
00:14:25,440 --> 00:14:33,199
okay uh so i probably need to

351
00:14:30,399 --> 00:14:35,440
do this this way

352
00:14:33,199 --> 00:14:35,440
so

353
00:14:35,600 --> 00:14:37,839
and

354
00:14:38,639 --> 00:14:44,240
we need a blank here for the second tape

355
00:14:42,000 --> 00:14:45,920
and we need a blank here for the third

356
00:14:44,240 --> 00:14:46,800
tape okay

357
00:14:45,920 --> 00:14:48,320
then

358
00:14:46,800 --> 00:14:51,199
we also need

359
00:14:48,320 --> 00:14:55,519
blank and blank dot

360
00:14:51,199 --> 00:14:56,800
okay that means the head is at that

361
00:14:55,519 --> 00:14:59,440
location

362
00:14:56,800 --> 00:15:01,920
so initially

363
00:14:59,440 --> 00:15:01,920
we have

364
00:15:02,079 --> 00:15:08,000
w1 dot here

365
00:15:04,480 --> 00:15:10,800
if the probability w1 is 0 or 1 right

366
00:15:08,000 --> 00:15:15,440
and we have blank dot here and the blank

367
00:15:10,800 --> 00:15:15,440
dot here that means that means

368
00:15:15,519 --> 00:15:21,600
the for the first tape

369
00:15:17,440 --> 00:15:23,680
we will read the symbol w1

370
00:15:21,600 --> 00:15:26,639
and for the second tab we will read

371
00:15:23,680 --> 00:15:27,760
blank for third tab will read

372
00:15:26,639 --> 00:15:28,639
blank

373
00:15:27,760 --> 00:15:30,480
okay

374
00:15:28,639 --> 00:15:33,120
so

375
00:15:30,480 --> 00:15:36,959
every time

376
00:15:33,120 --> 00:15:38,560
we can use a single tab two machine to

377
00:15:36,959 --> 00:15:41,360
scan

378
00:15:38,560 --> 00:15:42,639
the tape once and

379
00:15:41,360 --> 00:15:43,839
collect

380
00:15:42,639 --> 00:15:46,160
the dots

381
00:15:43,839 --> 00:15:47,600
symbol for example for this example we

382
00:15:46,160 --> 00:15:52,000
collect one

383
00:15:47,600 --> 00:15:52,959
we collect a we collect b

384
00:15:52,000 --> 00:15:56,320
right

385
00:15:52,959 --> 00:15:58,480
and we can use the state

386
00:15:56,320 --> 00:16:00,880
to trace

387
00:15:58,480 --> 00:16:02,800
m's state

388
00:16:00,880 --> 00:16:06,320
like we are doing

389
00:16:02,800 --> 00:16:06,320
like we are doing in

390
00:16:07,120 --> 00:16:12,240
using one dfa to trace two dfas

391
00:16:11,360 --> 00:16:15,440
okay

392
00:16:12,240 --> 00:16:20,320
pretty similar with that

393
00:16:15,440 --> 00:16:23,920
we incorporate m's state into s state

394
00:16:20,320 --> 00:16:27,519
everything every state of s is

395
00:16:23,920 --> 00:16:29,839
keep uh keep tracking the state of n

396
00:16:27,519 --> 00:16:29,839
then

397
00:16:30,480 --> 00:16:37,519
after collecting one a b we know m's

398
00:16:34,839 --> 00:16:39,360
state and the 1

399
00:16:37,519 --> 00:16:44,000
a b

400
00:16:39,360 --> 00:16:44,000
then we check up this entry

401
00:16:44,639 --> 00:16:47,759
where

402
00:16:46,160 --> 00:16:49,600
transition

403
00:16:47,759 --> 00:16:53,120
of m

404
00:16:49,600 --> 00:16:55,040
goes for example it goes to mp

405
00:16:53,120 --> 00:16:56,639
and for example

406
00:16:55,040 --> 00:16:58,000
change to

407
00:16:56,639 --> 00:16:59,600
0

408
00:16:58,000 --> 00:17:00,399
and change to

409
00:16:59,600 --> 00:17:01,920
b

410
00:17:00,399 --> 00:17:05,039
and

411
00:17:01,920 --> 00:17:07,919
keep the same way and stay

412
00:17:05,039 --> 00:17:07,919
and go left

413
00:17:08,400 --> 00:17:11,600
go right

414
00:17:09,600 --> 00:17:15,120
for example okay

415
00:17:11,600 --> 00:17:17,520
then we implement the transition on

416
00:17:15,120 --> 00:17:19,360
the tab here

417
00:17:17,520 --> 00:17:21,919
so

418
00:17:19,360 --> 00:17:21,919
we will

419
00:17:22,079 --> 00:17:26,640
we will make

420
00:17:24,400 --> 00:17:27,600
this symbol zero

421
00:17:26,640 --> 00:17:31,120
dot

422
00:17:27,600 --> 00:17:33,520
right because stay and change to zero

423
00:17:31,120 --> 00:17:35,679
so that would be 0 dot

424
00:17:33,520 --> 00:17:37,919
then we make a

425
00:17:35,679 --> 00:17:40,080
a dot here

426
00:17:37,919 --> 00:17:40,080
b

427
00:17:40,160 --> 00:17:42,960
and make

428
00:17:41,760 --> 00:17:45,679
this one

429
00:17:42,960 --> 00:17:48,799
a dot indicate that

430
00:17:45,679 --> 00:17:50,240
the head move to left right

431
00:17:48,799 --> 00:17:51,360
move to left

432
00:17:50,240 --> 00:17:53,919
and then

433
00:17:51,360 --> 00:17:55,520
keep the same

434
00:17:53,919 --> 00:17:58,240
symbol but

435
00:17:55,520 --> 00:18:01,039
it will become b instead of b dot and

436
00:17:58,240 --> 00:18:03,520
the head move right

437
00:18:01,039 --> 00:18:05,760
so that'll be a dot

438
00:18:03,520 --> 00:18:05,760
okay

439
00:18:05,919 --> 00:18:09,520
so

440
00:18:06,880 --> 00:18:11,440
in this way we can implement any

441
00:18:09,520 --> 00:18:12,880
transition

442
00:18:11,440 --> 00:18:14,880
done by m

443
00:18:12,880 --> 00:18:18,880
onto our s

444
00:18:14,880 --> 00:18:20,880
and using the tape to do that

445
00:18:18,880 --> 00:18:23,280
and someone may

446
00:18:20,880 --> 00:18:25,679
argue that okay uh actually you have

447
00:18:23,280 --> 00:18:28,559
infinite tape how do you handle that

448
00:18:25,679 --> 00:18:33,039
there's no problem at all here because

449
00:18:28,559 --> 00:18:34,880
initially you have w here right like i

450
00:18:33,039 --> 00:18:37,360
write this part and

451
00:18:34,880 --> 00:18:40,320
other tabs are empty

452
00:18:37,360 --> 00:18:42,720
and here comes the

453
00:18:40,320 --> 00:18:43,679
i don't know pretty essential property

454
00:18:42,720 --> 00:18:45,520
of

455
00:18:43,679 --> 00:18:47,760
turing machines that

456
00:18:45,520 --> 00:18:49,039
for turing machines

457
00:18:47,760 --> 00:18:52,080
one step

458
00:18:49,039 --> 00:18:52,080
one transition

459
00:18:52,320 --> 00:18:57,600
can generate at most

460
00:18:54,960 --> 00:18:59,919
one symbol appended to

461
00:18:57,600 --> 00:19:04,080
the string or that say

462
00:18:59,919 --> 00:19:06,080
written on to the unused tape space

463
00:19:04,080 --> 00:19:09,360
okay

464
00:19:06,080 --> 00:19:11,280
so for this example if you want to fill

465
00:19:09,360 --> 00:19:14,559
this box

466
00:19:11,280 --> 00:19:16,160
by c you want you need to spend one

467
00:19:14,559 --> 00:19:19,919
transition right

468
00:19:16,160 --> 00:19:21,200
and again one transition one transition

469
00:19:19,919 --> 00:19:23,440
right

470
00:19:21,200 --> 00:19:23,440
so

471
00:19:23,600 --> 00:19:29,760
you will spend transitions on feeding

472
00:19:26,480 --> 00:19:32,480
tab space to grow the type content

473
00:19:29,760 --> 00:19:36,799
so in that case there is no problem to

474
00:19:32,480 --> 00:19:39,520
handle that for by single type right so

475
00:19:36,799 --> 00:19:42,160
you can see in this example if

476
00:19:39,520 --> 00:19:45,200
if you want to fill this one

477
00:19:42,160 --> 00:19:47,120
as let's say a

478
00:19:45,200 --> 00:19:49,679
and then we

479
00:19:47,120 --> 00:19:52,240
write a blank after a

480
00:19:49,679 --> 00:19:53,679
how do we do that we just need to move

481
00:19:52,240 --> 00:19:54,559
the whole thing

482
00:19:53,679 --> 00:19:58,080
back

483
00:19:54,559 --> 00:20:00,880
one space well it's pretty

484
00:19:58,080 --> 00:20:03,440
i don't know tedious work or you may

485
00:20:00,880 --> 00:20:04,400
think it stupid but

486
00:20:03,440 --> 00:20:05,679
it

487
00:20:04,400 --> 00:20:07,600
it can be done

488
00:20:05,679 --> 00:20:11,200
right it can be done

489
00:20:07,600 --> 00:20:12,640
in this systematic way so every time you

490
00:20:11,200 --> 00:20:13,840
need to

491
00:20:12,640 --> 00:20:15,200
extend

492
00:20:13,840 --> 00:20:17,520
a tape

493
00:20:15,200 --> 00:20:19,440
the space of a tape you just need to

494
00:20:17,520 --> 00:20:21,760
copy everything

495
00:20:19,440 --> 00:20:24,080
you just need to copy everything

496
00:20:21,760 --> 00:20:24,080
one

497
00:20:24,960 --> 00:20:30,559
one block once uh

498
00:20:27,440 --> 00:20:33,200
space away then you have one more space

499
00:20:30,559 --> 00:20:34,720
here then you can do whatever you want

500
00:20:33,200 --> 00:20:36,000
to do

501
00:20:34,720 --> 00:20:38,880
okay

502
00:20:36,000 --> 00:20:42,799
so there's no problem for one single

503
00:20:38,880 --> 00:20:43,840
tape to handle the storage of multi

504
00:20:42,799 --> 00:20:46,240
tab

505
00:20:43,840 --> 00:20:47,280
okay is finite

506
00:20:46,240 --> 00:20:48,960
number

507
00:20:47,280 --> 00:20:51,679
okay

508
00:20:48,960 --> 00:20:54,960
so by doing this way uh in

509
00:20:51,679 --> 00:20:57,280
in the textbook is writing more you know

510
00:20:54,960 --> 00:20:58,880
uh formal way here

511
00:20:57,280 --> 00:20:59,919
we

512
00:20:58,880 --> 00:21:01,039
for

513
00:20:59,919 --> 00:21:02,559
on every

514
00:21:01,039 --> 00:21:05,600
input

515
00:21:02,559 --> 00:21:06,880
oh okay here is what i just write

516
00:21:05,600 --> 00:21:11,039
there

517
00:21:06,880 --> 00:21:12,960
we initially have this part on our

518
00:21:11,039 --> 00:21:14,159
single step turing machine

519
00:21:12,960 --> 00:21:17,760
so the

520
00:21:14,159 --> 00:21:20,080
there are separator here here here and

521
00:21:17,760 --> 00:21:23,600
maybe more tape right here

522
00:21:20,080 --> 00:21:25,840
then firstly you will read w1 and for

523
00:21:23,600 --> 00:21:26,640
other tabs blank

524
00:21:25,840 --> 00:21:28,799
okay

525
00:21:26,640 --> 00:21:32,320
so every time

526
00:21:28,799 --> 00:21:35,679
to simulate uh to simulate a single move

527
00:21:32,320 --> 00:21:37,760
of m every time as our single tattoo

528
00:21:35,679 --> 00:21:40,240
machine scans the tag

529
00:21:37,760 --> 00:21:41,679
of one

530
00:21:40,240 --> 00:21:43,760
scanner type

531
00:21:41,679 --> 00:21:47,520
from the left hand end

532
00:21:43,760 --> 00:21:50,720
to the final tapes and then you know

533
00:21:47,520 --> 00:21:53,600
which symbol will be read on each tape

534
00:21:50,720 --> 00:21:57,760
then we simulate that move and implement

535
00:21:53,600 --> 00:22:01,760
the change onto our single tab

536
00:21:57,760 --> 00:22:02,799
then we can pretty much similar simulate

537
00:22:01,760 --> 00:22:06,080
anything

538
00:22:02,799 --> 00:22:08,400
and what uh anything ends doing

539
00:22:06,080 --> 00:22:10,720
so in this way

540
00:22:08,400 --> 00:22:15,440
if n

541
00:22:10,720 --> 00:22:15,440
if n goes to accept

542
00:22:15,600 --> 00:22:21,760
we can go s can go to its own q accept

543
00:22:18,960 --> 00:22:21,760
to indicate

544
00:22:22,720 --> 00:22:28,799
the input is accepted or

545
00:22:26,799 --> 00:22:32,640
reject and we go

546
00:22:28,799 --> 00:22:34,400
reject okay and if it's keep running we

547
00:22:32,640 --> 00:22:38,320
keep running so

548
00:22:34,400 --> 00:22:40,960
we can pretty much build up

549
00:22:38,320 --> 00:22:44,000
equivalent single tap tube machine given

550
00:22:40,960 --> 00:22:45,200
any possible multi-type turing machine

551
00:22:44,000 --> 00:22:46,400
okay

552
00:22:45,200 --> 00:22:48,960
so

553
00:22:46,400 --> 00:22:51,120
since they are equivalent since they are

554
00:22:48,960 --> 00:22:53,280
equivalent

555
00:22:51,120 --> 00:22:56,400
we can extend our

556
00:22:53,280 --> 00:22:58,640
definition of recognizable

557
00:22:56,400 --> 00:23:00,880
even decidable to

558
00:22:58,640 --> 00:23:03,600
uh multi-type 2 machine right

559
00:23:00,880 --> 00:23:07,280
so we can say that a language is too

560
00:23:03,600 --> 00:23:09,280
recognizable if and if and only if

561
00:23:07,280 --> 00:23:11,200
some multi-tab 2 machine recognizes the

562
00:23:09,280 --> 00:23:12,320
language

563
00:23:11,200 --> 00:23:17,440
see

564
00:23:12,320 --> 00:23:17,440
so for computability they are equivalent

565
00:23:18,000 --> 00:23:22,280
and then we are going to

566
00:23:23,840 --> 00:23:26,880
we are going to

567
00:23:25,280 --> 00:23:29,840
look at the non-deterministic

568
00:23:26,880 --> 00:23:31,760
computation for turing machines

569
00:23:29,840 --> 00:23:34,000
and remember that non-deterministic

570
00:23:31,760 --> 00:23:36,720
means

571
00:23:34,000 --> 00:23:38,799
there are several choices at any point

572
00:23:36,720 --> 00:23:42,000
as i said you shouldn't

573
00:23:38,799 --> 00:23:45,039
think choices as the truth you do no you

574
00:23:42,000 --> 00:23:47,840
don't you don't choose anything

575
00:23:45,039 --> 00:23:50,480
the machine just fork enough

576
00:23:47,840 --> 00:23:52,159
branches and go

577
00:23:50,480 --> 00:23:53,919
and go

578
00:23:52,159 --> 00:23:57,200
each branch

579
00:23:53,919 --> 00:23:59,760
to the end okay so it's

580
00:23:57,200 --> 00:24:03,279
doing anything possibly

581
00:23:59,760 --> 00:24:06,159
in the computation and return the

582
00:24:03,279 --> 00:24:08,320
accept accept okay

583
00:24:06,159 --> 00:24:10,960
and to do the non-deterministic

584
00:24:08,320 --> 00:24:12,320
computation we also need to change the

585
00:24:10,960 --> 00:24:13,360
transition function of the turing

586
00:24:12,320 --> 00:24:14,400
machine

587
00:24:13,360 --> 00:24:18,200
so

588
00:24:14,400 --> 00:24:18,200
see we have uh

589
00:24:20,640 --> 00:24:25,840
state and the symbol red from the tape

590
00:24:24,000 --> 00:24:29,200
then map2

591
00:24:25,840 --> 00:24:32,320
you see this part is in our fundamental

592
00:24:29,200 --> 00:24:35,279
definition now it's non-deterministic

593
00:24:32,320 --> 00:24:38,159
computation so we map to power set

594
00:24:35,279 --> 00:24:39,360
that means any possible subset can be

595
00:24:38,159 --> 00:24:40,880
mapped to

596
00:24:39,360 --> 00:24:43,760
so

597
00:24:40,880 --> 00:24:43,760
you can have

598
00:24:43,840 --> 00:24:47,440
any

599
00:24:44,720 --> 00:24:50,159
any next step you want to design for the

600
00:24:47,440 --> 00:24:52,000
non-vitamins tube machine

601
00:24:50,159 --> 00:24:54,240
okay

602
00:24:52,000 --> 00:24:54,240
so

603
00:24:56,400 --> 00:25:00,720
it is interesting that you see for dfa

604
00:24:59,200 --> 00:25:03,039
and nfa

605
00:25:00,720 --> 00:25:04,880
we can prove the equivalence

606
00:25:03,039 --> 00:25:06,640
of

607
00:25:04,880 --> 00:25:09,120
having

608
00:25:06,640 --> 00:25:10,480
the capability of non-deterministic or

609
00:25:09,120 --> 00:25:11,279
not right

610
00:25:10,480 --> 00:25:16,320
but

611
00:25:11,279 --> 00:25:18,159
for pda like i just described dpda is

612
00:25:16,320 --> 00:25:21,360
different from

613
00:25:18,159 --> 00:25:24,799
pda we have introduced

614
00:25:21,360 --> 00:25:27,120
in chapter two they are different but

615
00:25:24,799 --> 00:25:30,320
for two machines they are equivalent

616
00:25:27,120 --> 00:25:31,200
again okay they are current again

617
00:25:30,320 --> 00:25:33,919
so

618
00:25:31,200 --> 00:25:34,880
the same argument goes here that we want

619
00:25:33,919 --> 00:25:38,640
to

620
00:25:34,880 --> 00:25:38,640
prove that to machine

621
00:25:39,360 --> 00:25:43,120
has equivalent

622
00:25:40,840 --> 00:25:46,320
non-deterministic machine and also

623
00:25:43,120 --> 00:25:48,880
non-deterministic machine

624
00:25:46,320 --> 00:25:50,400
has an equivalent to a machine

625
00:25:48,880 --> 00:25:52,960
but

626
00:25:50,400 --> 00:25:56,480
this direction

627
00:25:52,960 --> 00:26:00,320
is trivial right because the same as dfa

628
00:25:56,480 --> 00:26:02,480
nfa because a deterministic machine is

629
00:26:00,320 --> 00:26:04,720
a special case of non-deterministic

630
00:26:02,480 --> 00:26:06,480
machine so by definition

631
00:26:04,720 --> 00:26:08,799
any

632
00:26:06,480 --> 00:26:10,400
deterministic machine has an equivalent

633
00:26:08,799 --> 00:26:13,919
non-deterministic machine

634
00:26:10,400 --> 00:26:16,320
which behaves exactly like that

635
00:26:13,919 --> 00:26:18,080
deterministic machine right because you

636
00:26:16,320 --> 00:26:20,400
only need to

637
00:26:18,080 --> 00:26:23,600
have the transition function

638
00:26:20,400 --> 00:26:25,200
exactly only one possible next move as

639
00:26:23,600 --> 00:26:27,600
the determination machine so that

640
00:26:25,200 --> 00:26:30,520
there's no problem there so what we want

641
00:26:27,600 --> 00:26:33,520
to prove here is that every

642
00:26:30,520 --> 00:26:36,559
non-deterministic turing machine

643
00:26:33,520 --> 00:26:38,880
has an equivalent deterministic machine

644
00:26:36,559 --> 00:26:40,000
okay so that's our

645
00:26:38,880 --> 00:26:43,000
theorem

646
00:26:40,000 --> 00:26:43,000
3.16

647
00:26:44,320 --> 00:26:49,120
i will give you my version of the

648
00:26:49,200 --> 00:26:54,640
proof concept

649
00:26:51,039 --> 00:26:57,440
explaining how the whole proof

650
00:26:54,640 --> 00:26:57,440
goes and

651
00:26:57,760 --> 00:27:05,120
it is not a formal proof but it will be

652
00:27:01,360 --> 00:27:07,840
a explanation to what the proof on the

653
00:27:05,120 --> 00:27:07,840
textbook

654
00:27:08,159 --> 00:27:10,880
how it works

655
00:27:10,000 --> 00:27:12,480
okay

656
00:27:10,880 --> 00:27:14,159
so

657
00:27:12,480 --> 00:27:17,760
let's think about it for

658
00:27:14,159 --> 00:27:19,360
non-deterministic computation

659
00:27:17,760 --> 00:27:22,640
you start from

660
00:27:19,360 --> 00:27:24,480
for two machine let's say you start from

661
00:27:22,640 --> 00:27:29,520
a

662
00:27:24,480 --> 00:27:31,840
star configuration like q0 w right

663
00:27:29,520 --> 00:27:32,880
so that's your start configuration

664
00:27:31,840 --> 00:27:35,840
then

665
00:27:32,880 --> 00:27:39,760
it is possible that you have let's say

666
00:27:35,840 --> 00:27:43,520
two branches right so c one one may goes

667
00:27:39,760 --> 00:27:45,760
to c one c two one and c two two

668
00:27:43,520 --> 00:27:49,360
and then

669
00:27:45,760 --> 00:27:51,200
this point may have three branches right

670
00:27:49,360 --> 00:27:52,640
and this point have two branches

671
00:27:51,200 --> 00:27:55,120
something like that

672
00:27:52,640 --> 00:27:57,440
and then you have c

673
00:27:55,120 --> 00:27:57,440
three

674
00:27:57,600 --> 00:28:03,200
one c three two c three three

675
00:28:01,360 --> 00:28:06,960
c

676
00:28:03,200 --> 00:28:06,960
is not a good i think

677
00:28:07,039 --> 00:28:15,520
let's say uh

678
00:28:10,000 --> 00:28:18,720
that's remembering this as 1 2 and 1

679
00:28:15,520 --> 00:28:18,720
sorry 1 1

680
00:28:19,039 --> 00:28:21,279
and

681
00:28:22,960 --> 00:28:25,840
1

682
00:28:24,559 --> 00:28:27,200
2

683
00:28:25,840 --> 00:28:30,320
then

684
00:28:27,200 --> 00:28:33,360
you have 1 1 one

685
00:28:30,320 --> 00:28:36,640
one one two one one three okay three

686
00:28:33,360 --> 00:28:38,880
branches and then see one two one one

687
00:28:36,640 --> 00:28:39,760
two two

688
00:28:38,880 --> 00:28:43,279
right

689
00:28:39,760 --> 00:28:45,039
and then possibly you have more

690
00:28:43,279 --> 00:28:46,640
more

691
00:28:45,039 --> 00:28:49,039
things like that

692
00:28:46,640 --> 00:28:51,279
okay so you can see that why we want to

693
00:28:49,039 --> 00:28:53,600
define configuration and all this stuff

694
00:28:51,279 --> 00:28:55,760
because we can easily represent the

695
00:28:53,600 --> 00:28:59,440
whole state of uh

696
00:28:55,760 --> 00:29:01,279
a snapshot of a turing machine so

697
00:28:59,440 --> 00:29:03,360
you can think of you are writing a

698
00:29:01,279 --> 00:29:05,520
single temperature machine because you

699
00:29:03,360 --> 00:29:06,559
have infinite tape

700
00:29:05,520 --> 00:29:11,600
right

701
00:29:06,559 --> 00:29:13,440
so initially you use your infinite tape

702
00:29:11,600 --> 00:29:17,520
as

703
00:29:13,440 --> 00:29:18,799
this you use a separator and store c1

704
00:29:17,520 --> 00:29:19,919
here

705
00:29:18,799 --> 00:29:22,720
okay

706
00:29:19,919 --> 00:29:25,200
and since you have c1

707
00:29:22,720 --> 00:29:27,600
you can check up the machines the

708
00:29:25,200 --> 00:29:31,039
non-deterministic machines transition

709
00:29:27,600 --> 00:29:33,039
function and the notes that oh c1

710
00:29:31,039 --> 00:29:35,440
will map to

711
00:29:33,039 --> 00:29:37,039
c11 and c12

712
00:29:35,440 --> 00:29:39,200
of course the

713
00:29:37,039 --> 00:29:43,279
transition function here does not

714
00:29:39,200 --> 00:29:46,880
directly give you c11 and c12 it is only

715
00:29:43,279 --> 00:29:48,159
a transition right about a state

716
00:29:46,880 --> 00:29:50,559
and

717
00:29:48,159 --> 00:29:51,679
symbol and give you

718
00:29:50,559 --> 00:29:52,960
two

719
00:29:51,679 --> 00:29:54,399
state

720
00:29:52,960 --> 00:29:55,200
q1

721
00:29:54,399 --> 00:29:56,159
b

722
00:29:55,200 --> 00:29:57,279
and

723
00:29:56,159 --> 00:29:58,399
probably

724
00:29:57,279 --> 00:30:00,240
right

725
00:29:58,399 --> 00:30:03,200
and the q

726
00:30:00,240 --> 00:30:04,640
become p and the c and right something

727
00:30:03,200 --> 00:30:06,640
like that

728
00:30:04,640 --> 00:30:09,200
then

729
00:30:06,640 --> 00:30:12,039
look at the c1 you implement the

730
00:30:09,200 --> 00:30:15,200
transition to c1 you can get

731
00:30:12,039 --> 00:30:17,279
c12 and implement this transition you

732
00:30:15,200 --> 00:30:19,600
can get c

733
00:30:17,279 --> 00:30:19,600
sorry

734
00:30:20,080 --> 00:30:26,000
c11 and implement this transition you

735
00:30:23,200 --> 00:30:28,320
will get c12

736
00:30:26,000 --> 00:30:30,080
right so

737
00:30:28,320 --> 00:30:31,919
in this way

738
00:30:30,080 --> 00:30:34,960
you think of you

739
00:30:31,919 --> 00:30:36,720
implement a single type 2 machine

740
00:30:34,960 --> 00:30:40,720
which

741
00:30:36,720 --> 00:30:40,720
use the tape as a cue

742
00:30:41,360 --> 00:30:46,480
okay then you write c1 first then starts

743
00:30:44,960 --> 00:30:49,760
the whole procedure

744
00:30:46,480 --> 00:30:52,640
then each time in the iteration

745
00:30:49,760 --> 00:30:54,880
you remove the first

746
00:30:52,640 --> 00:30:56,720
you remove the first

747
00:30:54,880 --> 00:30:59,519
configuration

748
00:30:56,720 --> 00:31:01,200
of the tape

749
00:30:59,519 --> 00:31:03,360
then

750
00:31:01,200 --> 00:31:06,720
implement the first one

751
00:31:03,360 --> 00:31:09,679
you you look at the c1 you know

752
00:31:06,720 --> 00:31:11,840
there are two branches later so you

753
00:31:09,679 --> 00:31:14,720
implement the first

754
00:31:11,840 --> 00:31:15,480
transition to c1 and

755
00:31:14,720 --> 00:31:18,880
write

756
00:31:15,480 --> 00:31:24,159
c11 onto the tape and implement the

757
00:31:18,880 --> 00:31:25,120
second one write c12 onto the tape

758
00:31:24,159 --> 00:31:27,039
okay

759
00:31:25,120 --> 00:31:30,080
so every iteration

760
00:31:27,039 --> 00:31:33,600
the machine does this thing just just

761
00:31:30,080 --> 00:31:37,360
this thing so next iteration

762
00:31:33,600 --> 00:31:39,840
it will remove c11

763
00:31:37,360 --> 00:31:41,200
and look at c11

764
00:31:39,840 --> 00:31:43,039
and

765
00:31:41,200 --> 00:31:44,279
look up the delta function the

766
00:31:43,039 --> 00:31:46,559
transition function of the

767
00:31:44,279 --> 00:31:51,919
non-determining machine and the notes

768
00:31:46,559 --> 00:31:52,880
that they will there will be c11 c12 c13

769
00:31:51,919 --> 00:31:54,720
right

770
00:31:52,880 --> 00:31:58,840
so

771
00:31:54,720 --> 00:32:03,360
we just write c11 onto the tape

772
00:31:58,840 --> 00:32:05,120
c112 onto the tape and then c113 onto

773
00:32:03,360 --> 00:32:06,320
the tape

774
00:32:05,120 --> 00:32:08,880
okay

775
00:32:06,320 --> 00:32:10,880
then go back to the head

776
00:32:08,880 --> 00:32:11,679
because you have to remove this one

777
00:32:10,880 --> 00:32:12,720
right

778
00:32:11,679 --> 00:32:16,799
then

779
00:32:12,720 --> 00:32:18,240
go back remove c12 and also look up

780
00:32:16,799 --> 00:32:20,320
the

781
00:32:18,240 --> 00:32:22,559
transition function you know there will

782
00:32:20,320 --> 00:32:25,360
be c1 to 1

783
00:32:22,559 --> 00:32:27,600
and the c12

784
00:32:25,360 --> 00:32:28,480
and you remove this one

785
00:32:27,600 --> 00:32:30,000
okay

786
00:32:28,480 --> 00:32:32,480
so you just

787
00:32:30,000 --> 00:32:33,840
remove the first configuration

788
00:32:32,480 --> 00:32:36,720
in the tape

789
00:32:33,840 --> 00:32:39,360
and then implement all

790
00:32:36,720 --> 00:32:42,480
implemented transition you

791
00:32:39,360 --> 00:32:44,080
obtain from the transition function of

792
00:32:42,480 --> 00:32:46,399
the non-deterministic

793
00:32:44,080 --> 00:32:48,799
machine you want to simulate and then

794
00:32:46,399 --> 00:32:51,120
you know how many configurations will be

795
00:32:48,799 --> 00:32:53,919
generated and write them down on the

796
00:32:51,120 --> 00:32:56,960
tape append them to the to the end of

797
00:32:53,919 --> 00:32:59,279
the tab content and you have infinite

798
00:32:56,960 --> 00:33:02,240
tape right which is infinite storage so

799
00:32:59,279 --> 00:33:05,120
you don't need to worry about the space

800
00:33:02,240 --> 00:33:07,840
and you just repeat the whole thing and

801
00:33:05,120 --> 00:33:07,840
what do you have

802
00:33:08,559 --> 00:33:15,200
you will have

803
00:33:11,519 --> 00:33:16,320
something similar to

804
00:33:15,200 --> 00:33:17,279
bread

805
00:33:16,320 --> 00:33:20,559
first

806
00:33:17,279 --> 00:33:21,440
triversal of a computation tree

807
00:33:20,559 --> 00:33:24,399
right

808
00:33:21,440 --> 00:33:26,399
because you start from

809
00:33:24,399 --> 00:33:30,799
you start from the

810
00:33:26,399 --> 00:33:32,960
start configuration then you

811
00:33:30,799 --> 00:33:35,039
run this one and

812
00:33:32,960 --> 00:33:40,000
run this one

813
00:33:35,039 --> 00:33:41,360
and then you go this one this one

814
00:33:40,000 --> 00:33:45,279
this one

815
00:33:41,360 --> 00:33:47,600
and as we just explained see

816
00:33:45,279 --> 00:33:49,279
then you actually

817
00:33:47,600 --> 00:33:52,000
traverse the whole

818
00:33:49,279 --> 00:33:54,559
possible computational tree in a breadth

819
00:33:52,000 --> 00:33:56,080
first way

820
00:33:54,559 --> 00:33:59,519
so let's compare

821
00:33:56,080 --> 00:34:01,440
the concept regarding

822
00:33:59,519 --> 00:34:05,200
non-theta music computation

823
00:34:01,440 --> 00:34:05,200
nfa and ntn

824
00:34:05,279 --> 00:34:09,280
for

825
00:34:06,640 --> 00:34:11,440
non-deterministic computation tree

826
00:34:09,280 --> 00:34:13,040
it may look like

827
00:34:11,440 --> 00:34:14,159
something like

828
00:34:13,040 --> 00:34:15,599
this

829
00:34:14,159 --> 00:34:18,839
right

830
00:34:15,599 --> 00:34:21,200
so you have many computational

831
00:34:18,839 --> 00:34:25,040
branches and

832
00:34:21,200 --> 00:34:27,359
some you have one path and some not

833
00:34:25,040 --> 00:34:29,280
and some you have

834
00:34:27,359 --> 00:34:31,520
two or three

835
00:34:29,280 --> 00:34:32,960
something like this

836
00:34:31,520 --> 00:34:35,599
and for the

837
00:34:32,960 --> 00:34:39,200
non-deterministic finite authentic the

838
00:34:35,599 --> 00:34:43,359
nfa proof an effect to dfa proof

839
00:34:39,200 --> 00:34:46,399
what we did is we consider

840
00:34:43,359 --> 00:34:47,520
all possibility of the same

841
00:34:46,399 --> 00:34:48,480
level

842
00:34:47,520 --> 00:34:51,280
one

843
00:34:48,480 --> 00:34:52,159
state that's what we did in that proof

844
00:34:51,280 --> 00:34:53,919
okay

845
00:34:52,159 --> 00:34:55,280
one state

846
00:34:53,919 --> 00:34:57,680
and then

847
00:34:55,280 --> 00:35:00,560
we did something like this

848
00:34:57,680 --> 00:35:03,040
and as long as one is accept then this

849
00:35:00,560 --> 00:35:03,839
is accept otherwise it's not right so

850
00:35:03,040 --> 00:35:05,599
that's

851
00:35:03,839 --> 00:35:08,000
an fa

852
00:35:05,599 --> 00:35:10,960
two dfa

853
00:35:08,000 --> 00:35:12,400
equivalent dfa it works like

854
00:35:10,960 --> 00:35:13,359
the right-hand side

855
00:35:12,400 --> 00:35:16,400
but

856
00:35:13,359 --> 00:35:18,480
here for ntn

857
00:35:16,400 --> 00:35:21,520
we find a

858
00:35:18,480 --> 00:35:23,440
an equivalent deterministic tv machine

859
00:35:21,520 --> 00:35:25,040
what we did is

860
00:35:23,440 --> 00:35:27,440
start from the start

861
00:35:25,040 --> 00:35:29,760
start configuration and then breadth

862
00:35:27,440 --> 00:35:32,400
first search traversal

863
00:35:29,760 --> 00:35:35,520
and then we know there will be two

864
00:35:32,400 --> 00:35:37,599
configuration and then we know

865
00:35:35,520 --> 00:35:41,760
it will be this one from

866
00:35:37,599 --> 00:35:45,680
this one and this one goes through

867
00:35:41,760 --> 00:35:46,560
so the whole thing

868
00:35:45,680 --> 00:35:48,800
is

869
00:35:46,560 --> 00:35:50,960
something similar to

870
00:35:48,800 --> 00:35:53,680
this

871
00:35:50,960 --> 00:35:56,720
but the difference is that

872
00:35:53,680 --> 00:35:58,400
for nfa to dfa we

873
00:35:56,720 --> 00:36:00,160
make each level

874
00:35:58,400 --> 00:36:04,400
one step

875
00:36:00,160 --> 00:36:06,079
but for ntm to dtm we traverse

876
00:36:04,400 --> 00:36:08,800
breakfast

877
00:36:06,079 --> 00:36:10,880
traverse the whole computation tree

878
00:36:08,800 --> 00:36:12,560
that's why

879
00:36:10,880 --> 00:36:16,800
this dtn

880
00:36:12,560 --> 00:36:19,920
is equivalent to the ntn because the dtm

881
00:36:16,800 --> 00:36:21,520
the determination machine will

882
00:36:19,920 --> 00:36:25,520
go through

883
00:36:21,520 --> 00:36:27,680
all possible configurations

884
00:36:25,520 --> 00:36:31,040
by that ntn

885
00:36:27,680 --> 00:36:32,800
okay so that's the concept okay

886
00:36:31,040 --> 00:36:35,440
so in this case

887
00:36:32,800 --> 00:36:35,440
in this case

888
00:36:35,760 --> 00:36:40,160
the same definition goes to

889
00:36:38,480 --> 00:36:44,640
uh non-deterministic non-determination

890
00:36:40,160 --> 00:36:46,320
that as long as one of

891
00:36:44,640 --> 00:36:48,079
one of

892
00:36:46,320 --> 00:36:51,839
the configuration is accepting

893
00:36:48,079 --> 00:36:55,680
configuration we consider the machine

894
00:36:51,839 --> 00:36:58,480
except the string so in that case if

895
00:36:55,680 --> 00:36:59,520
there is a accepting configuration we

896
00:36:58,480 --> 00:37:00,400
will know

897
00:36:59,520 --> 00:37:01,839
right

898
00:37:00,400 --> 00:37:04,400
and when

899
00:37:01,839 --> 00:37:06,720
we consider the machine reject the

900
00:37:04,400 --> 00:37:08,880
string

901
00:37:06,720 --> 00:37:11,359
there is no accepting configuration and

902
00:37:08,880 --> 00:37:11,359
the o

903
00:37:11,680 --> 00:37:15,599
branch ends

904
00:37:13,520 --> 00:37:18,800
right all branch ends

905
00:37:15,599 --> 00:37:20,240
then since o branch ends

906
00:37:18,800 --> 00:37:21,839
and

907
00:37:20,240 --> 00:37:24,320
when

908
00:37:21,839 --> 00:37:25,760
if it ends it must end

909
00:37:24,320 --> 00:37:29,119
at a

910
00:37:25,760 --> 00:37:33,440
accepting or configuration

911
00:37:29,119 --> 00:37:34,720
configuration then if the all terminal

912
00:37:33,440 --> 00:37:36,720
nodes are

913
00:37:34,720 --> 00:37:39,040
rejecting we know that the machine will

914
00:37:36,720 --> 00:37:40,960
reject the string right

915
00:37:39,040 --> 00:37:43,599
and then

916
00:37:40,960 --> 00:37:46,880
if there are brain branch infinitely

917
00:37:43,599 --> 00:37:48,480
growing then we know with our dtm and

918
00:37:46,880 --> 00:37:51,200
goes infinite

919
00:37:48,480 --> 00:37:52,640
right so they are equivalent

920
00:37:51,200 --> 00:37:56,480
they are equivalent

921
00:37:52,640 --> 00:37:58,800
so let's make back the proof to the what

922
00:37:56,480 --> 00:38:01,040
we have on the textbook

923
00:37:58,800 --> 00:38:01,040
that

924
00:38:01,520 --> 00:38:05,119
in

925
00:38:02,560 --> 00:38:06,720
the the proof in the textbook actually

926
00:38:05,119 --> 00:38:10,000
provides

927
00:38:06,720 --> 00:38:13,599
one possible implement implementation of

928
00:38:10,000 --> 00:38:16,720
what i just described the concept okay

929
00:38:13,599 --> 00:38:18,560
so it used the first uh tape as the

930
00:38:16,720 --> 00:38:20,800
input table to

931
00:38:18,560 --> 00:38:24,320
to put the input string and then use the

932
00:38:20,800 --> 00:38:26,800
second tab as a working buffer to do the

933
00:38:24,320 --> 00:38:29,920
you know c11

934
00:38:26,800 --> 00:38:31,920
expansion and look up the

935
00:38:29,920 --> 00:38:34,800
transition function and implement one

936
00:38:31,920 --> 00:38:38,160
transition and the notes that c11 will

937
00:38:34,800 --> 00:38:39,200
become c111 c112 and c113 something like

938
00:38:38,160 --> 00:38:42,720
that

939
00:38:39,200 --> 00:38:46,240
and then it used address tape to

940
00:38:42,720 --> 00:38:47,200
do the branch trace what branch choice

941
00:38:46,240 --> 00:38:48,880
so

942
00:38:47,200 --> 00:38:52,400
you have

943
00:38:48,880 --> 00:38:53,520
one branch 2.3 branch and one branch two

944
00:38:52,400 --> 00:38:56,640
branch

945
00:38:53,520 --> 00:38:59,440
one branch two branch one branch

946
00:38:56,640 --> 00:39:03,119
two branch three branch so that's one

947
00:38:59,440 --> 00:39:06,240
two one two okay so they use a dress

948
00:39:03,119 --> 00:39:07,920
tape to trace the branch

949
00:39:06,240 --> 00:39:11,440
so it goes to

950
00:39:07,920 --> 00:39:12,839
very similar things that

951
00:39:11,440 --> 00:39:15,599
it's uh

952
00:39:12,839 --> 00:39:19,200
basically tracing

953
00:39:15,599 --> 00:39:21,680
uh the computation tree

954
00:39:19,200 --> 00:39:22,560
of that non-defamation machine

955
00:39:21,680 --> 00:39:24,960
okay

956
00:39:22,560 --> 00:39:26,560
so that's the

957
00:39:24,960 --> 00:39:27,520
that's the uh

958
00:39:26,560 --> 00:39:28,880
proof

959
00:39:27,520 --> 00:39:30,320
of the equivalence between

960
00:39:28,880 --> 00:39:31,920
non-deterministic machine and the

961
00:39:30,320 --> 00:39:36,560
deterministic machine

962
00:39:31,920 --> 00:39:36,560
so since they are equivalent so the thin

963
00:39:37,200 --> 00:39:41,040
definition goes to

964
00:39:39,280 --> 00:39:43,599
if

965
00:39:41,040 --> 00:39:44,760
a language is turing recognizable if an

966
00:39:43,599 --> 00:39:46,960
only

967
00:39:44,760 --> 00:39:48,000
non-determinatory machine recognizes the

968
00:39:46,960 --> 00:39:51,680
language

969
00:39:48,000 --> 00:39:54,640
and also if a language is decidable

970
00:39:51,680 --> 00:39:56,800
if and only if non-deterministic machine

971
00:39:54,640 --> 00:39:58,240
decides it okay

972
00:39:56,800 --> 00:40:00,000
so

973
00:39:58,240 --> 00:40:02,560
we know that they are

974
00:40:00,000 --> 00:40:03,599
equivalent

975
00:40:02,560 --> 00:40:05,119
so next

976
00:40:03,599 --> 00:40:06,960
we want to

977
00:40:05,119 --> 00:40:10,359
prove that

978
00:40:06,960 --> 00:40:10,359
there is a

979
00:40:10,640 --> 00:40:14,560
computational model called

980
00:40:13,200 --> 00:40:18,079
enumerator

981
00:40:14,560 --> 00:40:21,760
okay what is enumerator enumerator is uh

982
00:40:18,079 --> 00:40:21,760
also uh imagine

983
00:40:22,839 --> 00:40:29,200
in is also a conceptual

984
00:40:26,720 --> 00:40:31,359
computational model that it will

985
00:40:29,200 --> 00:40:32,480
enumerate strings

986
00:40:31,359 --> 00:40:35,760
you can

987
00:40:32,480 --> 00:40:37,760
consider enumerator as a finite control

988
00:40:35,760 --> 00:40:39,680
and a working tape but

989
00:40:37,760 --> 00:40:42,800
it is unvisible

990
00:40:39,680 --> 00:40:44,800
it is invisible to user and for user you

991
00:40:42,800 --> 00:40:47,520
you only see that

992
00:40:44,800 --> 00:40:50,720
in enumerator here

993
00:40:47,520 --> 00:40:51,760
keep output strings okay

994
00:40:50,720 --> 00:40:53,760
and

995
00:40:51,760 --> 00:40:55,280
one enumerator

996
00:40:53,760 --> 00:40:58,240
represents a

997
00:40:55,280 --> 00:40:59,520
language a set of strings and it just

998
00:40:58,240 --> 00:41:00,720
repeatedly

999
00:40:59,520 --> 00:41:03,119
outputs

1000
00:41:00,720 --> 00:41:04,240
the strings it

1001
00:41:03,119 --> 00:41:06,720
contains

1002
00:41:04,240 --> 00:41:08,560
and it is possible that uh it will

1003
00:41:06,720 --> 00:41:11,040
output the same string twice or three

1004
00:41:08,560 --> 00:41:12,480
times doesn't matter but eventually

1005
00:41:11,040 --> 00:41:15,680
eventually

1006
00:41:12,480 --> 00:41:17,119
a an enumerator will output all the

1007
00:41:15,680 --> 00:41:20,960
strings

1008
00:41:17,119 --> 00:41:24,160
it contains okay eventually so if one

1009
00:41:20,960 --> 00:41:26,800
string is in the language represented by

1010
00:41:24,160 --> 00:41:29,280
a in an enumerator

1011
00:41:26,800 --> 00:41:31,200
that string will eventually be output

1012
00:41:29,280 --> 00:41:34,319
something like that

1013
00:41:31,200 --> 00:41:36,720
so we want to prove that

1014
00:41:34,319 --> 00:41:40,480
we can build up a turing machine

1015
00:41:36,720 --> 00:41:42,720
which is equivalent to one enumerator

1016
00:41:40,480 --> 00:41:42,720
so

1017
00:41:43,680 --> 00:41:48,560
we uh the prove

1018
00:41:46,560 --> 00:41:50,640
the equivalence

1019
00:41:48,560 --> 00:41:51,599
is like

1020
00:41:50,640 --> 00:41:52,800
this

1021
00:41:51,599 --> 00:41:56,319
okay

1022
00:41:52,800 --> 00:41:58,319
so enumerator all the the

1023
00:41:56,319 --> 00:42:00,160
the language represented by the

1024
00:41:58,319 --> 00:42:02,400
numerator will be recognized by some

1025
00:42:00,160 --> 00:42:04,480
tuning machine and vice versa

1026
00:42:02,400 --> 00:42:07,440
so given

1027
00:42:04,480 --> 00:42:09,119
an enumerator so now we want to do the

1028
00:42:07,440 --> 00:42:10,800
if and only thing

1029
00:42:09,119 --> 00:42:13,599
both direction

1030
00:42:10,800 --> 00:42:15,680
so given an enumerator

1031
00:42:13,599 --> 00:42:16,640
we want to build a tube machine like

1032
00:42:15,680 --> 00:42:17,680
this

1033
00:42:16,640 --> 00:42:19,920
okay

1034
00:42:17,680 --> 00:42:19,920
so

1035
00:42:21,119 --> 00:42:24,319
whenever

1036
00:42:22,720 --> 00:42:26,160
we have a

1037
00:42:24,319 --> 00:42:28,400
string to determine

1038
00:42:26,160 --> 00:42:30,960
we run the enumerator we use the turing

1039
00:42:28,400 --> 00:42:33,440
machine to run the enumerator

1040
00:42:30,960 --> 00:42:36,400
and every time the enumerator outputs a

1041
00:42:33,440 --> 00:42:38,720
string we compare with the input

1042
00:42:36,400 --> 00:42:40,880
since by definition

1043
00:42:38,720 --> 00:42:42,400
the string

1044
00:42:40,880 --> 00:42:45,040
of

1045
00:42:42,400 --> 00:42:46,000
the enumerator will eventually be output

1046
00:42:45,040 --> 00:42:49,040
so

1047
00:42:46,000 --> 00:42:50,880
we just wait until it appears

1048
00:42:49,040 --> 00:42:52,880
if

1049
00:42:50,880 --> 00:42:56,839
compares the same

1050
00:42:52,880 --> 00:42:58,480
we accept okay so you will see that l of

1051
00:42:56,839 --> 00:43:00,400
m

1052
00:42:58,480 --> 00:43:03,680
will be

1053
00:43:00,400 --> 00:43:04,400
all string outputted by le

1054
00:43:03,680 --> 00:43:07,920
but

1055
00:43:04,400 --> 00:43:10,720
you also know that for other strings

1056
00:43:07,920 --> 00:43:10,720
four strings

1057
00:43:10,800 --> 00:43:16,880
for strings not in error of e what will

1058
00:43:15,359 --> 00:43:18,960
this machine do

1059
00:43:16,880 --> 00:43:19,920
this machine will never give you an

1060
00:43:18,960 --> 00:43:22,960
answer

1061
00:43:19,920 --> 00:43:24,160
okay but this string can accept all

1062
00:43:22,960 --> 00:43:27,680
strings

1063
00:43:24,160 --> 00:43:29,680
that is in l e

1064
00:43:27,680 --> 00:43:32,560
on the other hand we want to prove the

1065
00:43:29,680 --> 00:43:34,160
other direction if you have a two

1066
00:43:32,560 --> 00:43:35,680
machine and

1067
00:43:34,160 --> 00:43:38,079
how do you

1068
00:43:35,680 --> 00:43:39,599
output all strings

1069
00:43:38,079 --> 00:43:44,319
in

1070
00:43:39,599 --> 00:43:46,560
l of n so we build up an enumerator and

1071
00:43:44,319 --> 00:43:47,839
as i said the numerator doesn't have

1072
00:43:46,560 --> 00:43:49,280
input

1073
00:43:47,839 --> 00:43:50,480
okay

1074
00:43:49,280 --> 00:43:52,319
so for

1075
00:43:50,480 --> 00:43:56,720
for intuitive

1076
00:43:52,319 --> 00:43:59,359
uh for a intuit intuitive way of

1077
00:43:56,720 --> 00:44:02,800
thinking you may

1078
00:43:59,359 --> 00:44:04,560
say that okay for for alphabet like

1079
00:44:02,800 --> 00:44:08,160
for example zero one

1080
00:44:04,560 --> 00:44:11,440
we just enumerate all strings yes so

1081
00:44:08,160 --> 00:44:14,160
lens revolve lens one

1082
00:44:11,440 --> 00:44:14,160
length two

1083
00:44:16,000 --> 00:44:18,880
lens three

1084
00:44:18,000 --> 00:44:21,599
right

1085
00:44:18,880 --> 00:44:22,560
so you can always enumerate all possible

1086
00:44:21,599 --> 00:44:23,440
strings

1087
00:44:22,560 --> 00:44:24,319
built

1088
00:44:23,440 --> 00:44:26,079
by

1089
00:44:24,319 --> 00:44:27,359
build upon and

1090
00:44:26,079 --> 00:44:29,680
alphabet

1091
00:44:27,359 --> 00:44:31,760
we call it let's call graph

1092
00:44:29,680 --> 00:44:33,280
lexicographical

1093
00:44:31,760 --> 00:44:34,240
order

1094
00:44:33,280 --> 00:44:35,359
okay

1095
00:44:34,240 --> 00:44:38,160
but

1096
00:44:35,359 --> 00:44:41,119
you cannot you actually cannot uh test

1097
00:44:38,160 --> 00:44:42,000
each string like you

1098
00:44:41,119 --> 00:44:44,880
feed

1099
00:44:42,000 --> 00:44:48,880
empty string to the m to see if it

1100
00:44:44,880 --> 00:44:51,680
accepts zero to the to m to see if it uh

1101
00:44:48,880 --> 00:44:53,920
it accepts you cannot do that why

1102
00:44:51,680 --> 00:44:55,920
because

1103
00:44:53,920 --> 00:44:58,240
machine n

1104
00:44:55,920 --> 00:45:00,960
if the string is accepted by machine m

1105
00:44:58,240 --> 00:45:02,800
is okay right then you can output that

1106
00:45:00,960 --> 00:45:05,359
string but

1107
00:45:02,800 --> 00:45:08,000
if that string is not accepted by

1108
00:45:05,359 --> 00:45:10,800
machine m it is possible that machine m

1109
00:45:08,000 --> 00:45:12,000
will loop forever and your enumerator

1110
00:45:10,800 --> 00:45:15,280
gets dark

1111
00:45:12,000 --> 00:45:17,280
for example here that

1112
00:45:15,280 --> 00:45:18,480
doesn't work okay that doesn't work you

1113
00:45:17,280 --> 00:45:20,880
cannot just

1114
00:45:18,480 --> 00:45:23,440
uh using lexical graphical order and

1115
00:45:20,880 --> 00:45:25,200
test each string that doesn't work so

1116
00:45:23,440 --> 00:45:27,520
what we do want to do

1117
00:45:25,200 --> 00:45:29,440
here is that

1118
00:45:27,520 --> 00:45:32,560
we

1119
00:45:29,440 --> 00:45:35,440
have all the strings like uh this this

1120
00:45:32,560 --> 00:45:40,000
is the first string second string third

1121
00:45:35,440 --> 00:45:42,000
string fourth string etc like s1 s2

1122
00:45:40,000 --> 00:45:44,480
here okay

1123
00:45:42,000 --> 00:45:45,760
but we do the loop

1124
00:45:44,480 --> 00:45:49,119
for i

1125
00:45:45,760 --> 00:45:53,680
equal to 1 2 3 et cetera and what did

1126
00:45:49,119 --> 00:45:53,680
what do we do we do that for s1

1127
00:45:54,319 --> 00:46:00,880
we feed it into n

1128
00:45:58,000 --> 00:46:03,520
but run only one step

1129
00:46:00,880 --> 00:46:06,079
okay wrong only one step

1130
00:46:03,520 --> 00:46:06,079
one step

1131
00:46:06,640 --> 00:46:09,040
and then

1132
00:46:08,079 --> 00:46:11,760
we

1133
00:46:09,040 --> 00:46:16,560
fit s1 again

1134
00:46:11,760 --> 00:46:16,560
to end and let it run two steps

1135
00:46:17,440 --> 00:46:21,440
and then

1136
00:46:18,880 --> 00:46:22,240
s2 two steps okay

1137
00:46:21,440 --> 00:46:25,119
and

1138
00:46:22,240 --> 00:46:26,319
s1 s2 s3

1139
00:46:25,119 --> 00:46:27,359
three steps

1140
00:46:26,319 --> 00:46:30,480
then

1141
00:46:27,359 --> 00:46:30,480
i equal to four

1142
00:46:34,000 --> 00:46:44,640
s1 s2 s3 as for four steps etc

1143
00:46:39,680 --> 00:46:47,760
okay so i equal to let's say n

1144
00:46:44,640 --> 00:46:48,640
you have s1 s2

1145
00:46:47,760 --> 00:46:51,280
sorry

1146
00:46:48,640 --> 00:46:52,960
s1 s2

1147
00:46:51,280 --> 00:46:56,560
2sn

1148
00:46:52,960 --> 00:46:58,079
n steps and then so on

1149
00:46:56,560 --> 00:47:00,000
so on so forth

1150
00:46:58,079 --> 00:47:01,359
then

1151
00:47:00,000 --> 00:47:05,440
you will see that

1152
00:47:01,359 --> 00:47:08,319
our machine m here will never be

1153
00:47:05,440 --> 00:47:11,280
stuck by some particular string that it

1154
00:47:08,319 --> 00:47:13,440
will never accept

1155
00:47:11,280 --> 00:47:16,560
on the other hand if

1156
00:47:13,440 --> 00:47:18,960
some string will be accepted eventually

1157
00:47:16,560 --> 00:47:21,359
it will be accept

1158
00:47:18,960 --> 00:47:24,400
right for example stream

1159
00:47:21,359 --> 00:47:27,359
213 will be accepted

1160
00:47:24,400 --> 00:47:32,480
by using m

1161
00:47:27,359 --> 00:47:35,760
with like 1 million steps okay then

1162
00:47:32,480 --> 00:47:39,119
when i equal to 1 million you will

1163
00:47:35,760 --> 00:47:40,800
accept 1 to two one three then you will

1164
00:47:39,119 --> 00:47:41,760
output two and three

1165
00:47:40,800 --> 00:47:44,720
so

1166
00:47:41,760 --> 00:47:47,200
we can build up a enumerator

1167
00:47:44,720 --> 00:47:48,800
in this way to enumerate all strings

1168
00:47:47,200 --> 00:47:50,319
represented by

1169
00:47:48,800 --> 00:47:52,160
that

1170
00:47:50,319 --> 00:47:53,359
uh

1171
00:47:52,160 --> 00:47:54,559
turing machine

1172
00:47:53,359 --> 00:47:56,800
okay

1173
00:47:54,559 --> 00:47:56,800
so

1174
00:47:58,000 --> 00:48:00,880
we can

1175
00:47:58,960 --> 00:48:03,520
say that a language is tuning

1176
00:48:00,880 --> 00:48:05,119
recognizable

1177
00:48:03,520 --> 00:48:08,319
if and only

1178
00:48:05,119 --> 00:48:09,440
if some enumerate enumerates the

1179
00:48:08,319 --> 00:48:10,720
language

1180
00:48:09,440 --> 00:48:12,800
okay that's

1181
00:48:10,720 --> 00:48:15,599
what we have done

1182
00:48:12,800 --> 00:48:18,240
and for chapter three

1183
00:48:15,599 --> 00:48:21,280
so chapter three finally let's go back

1184
00:48:18,240 --> 00:48:22,720
to the definition of algorithm so what

1185
00:48:21,280 --> 00:48:24,400
exactly

1186
00:48:22,720 --> 00:48:26,640
an algorithm or

1187
00:48:24,400 --> 00:48:29,119
procedure or recipe

1188
00:48:26,640 --> 00:48:31,599
if you see the numerical analysis or

1189
00:48:29,119 --> 00:48:33,839
computation there are many things called

1190
00:48:31,599 --> 00:48:37,440
recipes which means how you can do the

1191
00:48:33,839 --> 00:48:39,760
computation okay it goes back to

1192
00:48:37,440 --> 00:48:42,800
uh hilbert's problem

1193
00:48:39,760 --> 00:48:44,000
in hilbert's problem is one of the

1194
00:48:42,800 --> 00:48:46,480
famous

1195
00:48:44,000 --> 00:48:49,760
problem is that

1196
00:48:46,480 --> 00:48:53,440
he asks us to find an algorithm to

1197
00:48:49,760 --> 00:48:55,040
determine whether or whether a given

1198
00:48:53,440 --> 00:48:57,359
uh polynomial

1199
00:48:55,040 --> 00:49:00,559
diaphanetite

1200
00:48:57,359 --> 00:49:04,319
equation with integer coefficient has an

1201
00:49:00,559 --> 00:49:05,440
integer solution whether or not

1202
00:49:04,319 --> 00:49:08,480
so

1203
00:49:05,440 --> 00:49:09,599
he used some words in french actually

1204
00:49:08,480 --> 00:49:13,440
but

1205
00:49:09,599 --> 00:49:13,440
something like find that means

1206
00:49:13,839 --> 00:49:19,920
he

1207
00:49:14,839 --> 00:49:20,800
never believed that the algorithm not ex

1208
00:49:19,920 --> 00:49:23,760
the

1209
00:49:20,800 --> 00:49:26,480
non-existence of that algorithm okay

1210
00:49:23,760 --> 00:49:28,400
anyway so mathematicians and scholars

1211
00:49:26,480 --> 00:49:31,440
tries to solve this problem

1212
00:49:28,400 --> 00:49:33,599
so they found uh very soon they found

1213
00:49:31,440 --> 00:49:35,359
they found that we need to define

1214
00:49:33,599 --> 00:49:37,599
algorithm first

1215
00:49:35,359 --> 00:49:38,559
that is we need to define computation

1216
00:49:37,599 --> 00:49:41,760
first

1217
00:49:38,559 --> 00:49:45,200
so church proposed lambda calculus i

1218
00:49:41,760 --> 00:49:47,359
under calculus as i just as i previously

1219
00:49:45,200 --> 00:49:48,720
described and turing proposed turing

1220
00:49:47,359 --> 00:49:50,079
machines and

1221
00:49:48,720 --> 00:49:51,599
later they proved that they are

1222
00:49:50,079 --> 00:49:54,640
equivalent okay

1223
00:49:51,599 --> 00:49:55,680
so if we use turing machine terminology

1224
00:49:54,640 --> 00:49:59,839
then

1225
00:49:55,680 --> 00:49:59,839
the whole problem here becomes

1226
00:50:01,359 --> 00:50:05,119
is there

1227
00:50:02,400 --> 00:50:08,559
is the problem as a language to

1228
00:50:05,119 --> 00:50:10,559
indecidable to unrecognizable

1229
00:50:08,559 --> 00:50:12,800
if it is desirable then that two machine

1230
00:50:10,559 --> 00:50:15,040
is the algorithm it is not too

1231
00:50:12,800 --> 00:50:16,720
recognizable or too undecidable then we

1232
00:50:15,040 --> 00:50:17,839
don't have an algorithm something like

1233
00:50:16,720 --> 00:50:18,880
that

1234
00:50:17,839 --> 00:50:21,440
okay

1235
00:50:18,880 --> 00:50:21,440
so anyway

1236
00:50:22,800 --> 00:50:28,240
if you are interested you can look up

1237
00:50:25,280 --> 00:50:31,119
wiki or google this problem of the

1238
00:50:28,240 --> 00:50:33,200
beginning of study on computations and

1239
00:50:31,119 --> 00:50:35,760
we know that in general

1240
00:50:33,200 --> 00:50:39,839
there is no such algorithm now we know

1241
00:50:35,760 --> 00:50:44,559
that but for particular

1242
00:50:39,839 --> 00:50:47,599
form of such equation like over one

1243
00:50:44,559 --> 00:50:49,599
variable with

1244
00:50:47,599 --> 00:50:52,880
over one variable we can determine that

1245
00:50:49,599 --> 00:50:55,760
because you can do an exhaustive search

1246
00:50:52,880 --> 00:50:58,000
anyway so that's the beginning

1247
00:50:55,760 --> 00:51:00,559
and for turing machines

1248
00:50:58,000 --> 00:51:03,359
we actually will use different levels of

1249
00:51:00,559 --> 00:51:04,880
detail for two machines the first level

1250
00:51:03,359 --> 00:51:07,200
is

1251
00:51:04,880 --> 00:51:08,400
formal description okay

1252
00:51:07,200 --> 00:51:10,480
so

1253
00:51:08,400 --> 00:51:14,400
for formal description actually

1254
00:51:10,480 --> 00:51:16,800
everything eventually must be done at

1255
00:51:14,400 --> 00:51:19,280
the formal description level because you

1256
00:51:16,800 --> 00:51:21,839
need to formally define the seventh

1257
00:51:19,280 --> 00:51:25,280
tuple of artillery machine

1258
00:51:21,839 --> 00:51:27,760
including states including alphabets etc

1259
00:51:25,280 --> 00:51:29,599
okay that's required

1260
00:51:27,760 --> 00:51:32,960
but sometimes

1261
00:51:29,599 --> 00:51:34,559
okay actually often often times

1262
00:51:32,960 --> 00:51:36,800
we don't

1263
00:51:34,559 --> 00:51:39,440
do formal description

1264
00:51:36,800 --> 00:51:41,680
like we have

1265
00:51:39,440 --> 00:51:43,599
as m2 here we don't do formal

1266
00:51:41,680 --> 00:51:46,480
description like this

1267
00:51:43,599 --> 00:51:49,040
okay we do description more like

1268
00:51:46,480 --> 00:51:50,480
implementation level like

1269
00:51:49,040 --> 00:51:51,839
we

1270
00:51:50,480 --> 00:51:52,960
have here

1271
00:51:51,839 --> 00:51:56,160
for incoming

1272
00:51:52,960 --> 00:51:57,040
implementation level we need to describe

1273
00:51:56,160 --> 00:52:00,240
how

1274
00:51:57,040 --> 00:52:00,960
turing machine moves the head how data

1275
00:52:00,240 --> 00:52:03,280
is

1276
00:52:00,960 --> 00:52:05,839
data are stored and how you manipulate

1277
00:52:03,280 --> 00:52:08,640
that as long as

1278
00:52:05,839 --> 00:52:11,280
everybody agrees upon the

1279
00:52:08,640 --> 00:52:14,000
implementation which can be

1280
00:52:11,280 --> 00:52:15,040
realized realized by a turing machine

1281
00:52:14,000 --> 00:52:16,880
then

1282
00:52:15,040 --> 00:52:19,839
there's no problem

1283
00:52:16,880 --> 00:52:19,839
okay

1284
00:52:20,079 --> 00:52:24,000
then

1285
00:52:21,599 --> 00:52:27,040
more openly we

1286
00:52:24,000 --> 00:52:28,480
will do something like

1287
00:52:27,040 --> 00:52:31,599
this thing

1288
00:52:28,480 --> 00:52:33,680
okay so

1289
00:52:31,599 --> 00:52:36,160
well that that's uh

1290
00:52:33,680 --> 00:52:36,160
between

1291
00:52:38,480 --> 00:52:41,839
implementation description and high

1292
00:52:40,400 --> 00:52:44,000
level description

1293
00:52:41,839 --> 00:52:46,400
well for high level distribution is more

1294
00:52:44,000 --> 00:52:48,880
like we have here

1295
00:52:46,400 --> 00:52:51,760
okay we have here

1296
00:52:48,880 --> 00:52:54,160
these two machine is

1297
00:52:51,760 --> 00:52:57,200
kind of high level description we

1298
00:52:54,160 --> 00:52:58,480
describe what we want to do and

1299
00:52:57,200 --> 00:53:01,280
with

1300
00:52:58,480 --> 00:53:03,520
sufficient

1301
00:53:01,280 --> 00:53:05,920
knowledge regarding trade machine you

1302
00:53:03,520 --> 00:53:08,480
may believe that that's doable biotin

1303
00:53:05,920 --> 00:53:11,599
machine in that case

1304
00:53:08,480 --> 00:53:14,800
it's okay you don't need to speed out

1305
00:53:11,599 --> 00:53:16,079
all states transitions the formal

1306
00:53:14,800 --> 00:53:19,119
description

1307
00:53:16,079 --> 00:53:21,760
so in a way okay in a way formal

1308
00:53:19,119 --> 00:53:22,880
description is more like a

1309
00:53:21,760 --> 00:53:25,359
machine

1310
00:53:22,880 --> 00:53:29,839
machine code

1311
00:53:25,359 --> 00:53:29,839
or at least assembly language

1312
00:53:30,559 --> 00:53:37,119
assembly program which is

1313
00:53:33,839 --> 00:53:38,559
very closely attached to the underlying

1314
00:53:37,119 --> 00:53:41,119
machine okay

1315
00:53:38,559 --> 00:53:42,720
and you can see you can think of

1316
00:53:41,119 --> 00:53:45,839
implementation

1317
00:53:42,720 --> 00:53:47,760
description like some c program java

1318
00:53:45,839 --> 00:53:49,520
program you are writing

1319
00:53:47,760 --> 00:53:51,599
that's an implementation

1320
00:53:49,520 --> 00:53:53,680
okay hi

1321
00:53:51,599 --> 00:53:56,640
and high level description is more like

1322
00:53:53,680 --> 00:53:57,920
a pseudo code

1323
00:53:56,640 --> 00:54:00,160
it's more like

1324
00:53:57,920 --> 00:54:04,240
pseudocode we have

1325
00:54:00,160 --> 00:54:04,240
in like paper or something so

1326
00:54:04,960 --> 00:54:09,599
you may encounter some situation that

1327
00:54:06,960 --> 00:54:12,079
people give pseudo code and you believe

1328
00:54:09,599 --> 00:54:14,480
that's implementable right it can be

1329
00:54:12,079 --> 00:54:16,640
implemented or people write in some

1330
00:54:14,480 --> 00:54:20,160
pseudocode you don't believe it can be

1331
00:54:16,640 --> 00:54:22,000
implemented then you will ask him or her

1332
00:54:20,160 --> 00:54:24,559
to implement

1333
00:54:22,000 --> 00:54:28,000
at least the java programs the programs

1334
00:54:24,559 --> 00:54:29,280
the plus program python program etc

1335
00:54:28,000 --> 00:54:31,520
and

1336
00:54:29,280 --> 00:54:31,520
if

1337
00:54:33,280 --> 00:54:38,079
this kind of this level cannot convince

1338
00:54:35,760 --> 00:54:40,880
you finally you will need to have some

1339
00:54:38,079 --> 00:54:43,359
program that can run on your machine to

1340
00:54:40,880 --> 00:54:46,559
verify it that's basically formal

1341
00:54:43,359 --> 00:54:49,119
description okay so we will use the

1342
00:54:46,559 --> 00:54:50,720
three kinds of different level of detail

1343
00:54:49,119 --> 00:54:53,200
and

1344
00:54:50,720 --> 00:54:56,720
from now on mostly like high level

1345
00:54:53,200 --> 00:54:58,559
description because we won't go back to

1346
00:54:56,720 --> 00:55:00,240
do a formal

1347
00:54:58,559 --> 00:55:02,640
way of turing machine because that's

1348
00:55:00,240 --> 00:55:04,480
very tedious

1349
00:55:02,640 --> 00:55:06,880
however you still need to convince

1350
00:55:04,480 --> 00:55:08,000
others that what you want to do with tui

1351
00:55:06,880 --> 00:55:12,400
machine

1352
00:55:08,000 --> 00:55:13,599
is really doable okay that's also a

1353
00:55:12,400 --> 00:55:15,440
a

1354
00:55:13,599 --> 00:55:16,960
mathematical way

1355
00:55:15,440 --> 00:55:21,280
and

1356
00:55:16,960 --> 00:55:25,040
let's see an example here if we want to

1357
00:55:21,280 --> 00:55:27,839
determine a graph is connected

1358
00:55:25,040 --> 00:55:29,200
then we define in a transmission way we

1359
00:55:27,839 --> 00:55:30,880
define

1360
00:55:29,200 --> 00:55:32,400
graph

1361
00:55:30,880 --> 00:55:33,440
as a string

1362
00:55:32,400 --> 00:55:36,000
and

1363
00:55:33,440 --> 00:55:39,760
the language is that

1364
00:55:36,000 --> 00:55:39,760
the graph is connected

1365
00:55:40,799 --> 00:55:46,240
the string is in the language

1366
00:55:43,760 --> 00:55:49,280
so let's have a high level description

1367
00:55:46,240 --> 00:55:50,960
of a turing machine that decides a that

1368
00:55:49,280 --> 00:55:53,839
means

1369
00:55:50,960 --> 00:55:58,000
the string in a language a will accept

1370
00:55:53,839 --> 00:56:00,400
not in a language a will reject okay

1371
00:55:58,000 --> 00:56:02,720
so you can simply read the whole thing

1372
00:56:00,400 --> 00:56:05,920
here that you select the first node and

1373
00:56:02,720 --> 00:56:05,920
mark it and

1374
00:56:06,400 --> 00:56:11,040
repeat

1375
00:56:07,760 --> 00:56:12,000
the loop until no new nodes are marked

1376
00:56:11,040 --> 00:56:13,040
right

1377
00:56:12,000 --> 00:56:16,799
and

1378
00:56:13,040 --> 00:56:19,280
you just check each node

1379
00:56:16,799 --> 00:56:21,920
if it attached by an edge to a node that

1380
00:56:19,280 --> 00:56:24,640
is already marked then mark the node and

1381
00:56:21,920 --> 00:56:26,640
every iteration you mark some node right

1382
00:56:24,640 --> 00:56:29,760
since g has in

1383
00:56:26,640 --> 00:56:32,480
finite nodes and it

1384
00:56:29,760 --> 00:56:34,640
oh it uh each iteration you mark some

1385
00:56:32,480 --> 00:56:38,000
nodes eventually it will stop

1386
00:56:34,640 --> 00:56:39,839
and after stop you check if all nodes

1387
00:56:38,000 --> 00:56:42,160
are marked then accept because they are

1388
00:56:39,839 --> 00:56:43,839
connected otherwise reject

1389
00:56:42,160 --> 00:56:48,640
okay so

1390
00:56:43,839 --> 00:56:48,640
in a way we all believe that this uh

1391
00:56:48,880 --> 00:56:53,680
this algorithm can be implemented by two

1392
00:56:51,520 --> 00:56:56,240
machines so that's a

1393
00:56:53,680 --> 00:56:58,640
high level description okay

1394
00:56:56,240 --> 00:56:59,839
and by this example finally we want to

1395
00:56:58,640 --> 00:57:02,160
say that

1396
00:56:59,839 --> 00:57:02,160
all

1397
00:57:04,559 --> 00:57:10,480
all problems you want to model you need

1398
00:57:07,359 --> 00:57:14,720
to determine some encoding scheme for

1399
00:57:10,480 --> 00:57:16,000
this example we want to encode a

1400
00:57:14,720 --> 00:57:19,280
graph

1401
00:57:16,000 --> 00:57:22,160
onto the as the input string so

1402
00:57:19,280 --> 00:57:25,760
one possible encoding scheme is that is

1403
00:57:22,160 --> 00:57:28,480
like this we use left parenthesis

1404
00:57:25,760 --> 00:57:32,640
one two three four and a comma comma

1405
00:57:28,480 --> 00:57:33,680
comma right parenthesis to encode the

1406
00:57:32,640 --> 00:57:35,599
vertex

1407
00:57:33,680 --> 00:57:36,400
and then we encode

1408
00:57:35,599 --> 00:57:40,160
h

1409
00:57:36,400 --> 00:57:41,839
and graph is verticent h right graphics

1410
00:57:40,160 --> 00:57:44,640
vertex and h

1411
00:57:41,839 --> 00:57:46,079
so that comes to the encodings of the

1412
00:57:44,640 --> 00:57:49,119
mathematic

1413
00:57:46,079 --> 00:57:51,520
objects in mathematics okay you need to

1414
00:57:49,119 --> 00:57:53,200
have a reasonable you need to have

1415
00:57:51,520 --> 00:57:55,040
reasonable

1416
00:57:53,200 --> 00:57:58,079
way to encode

1417
00:57:55,040 --> 00:58:00,480
the input string that will not can be

1418
00:57:58,079 --> 00:58:01,920
processed by your turing machine and we

1419
00:58:00,480 --> 00:58:04,720
will

1420
00:58:01,920 --> 00:58:07,680
discuss that a little bit later but in

1421
00:58:04,720 --> 00:58:10,480
this in this example particularly this

1422
00:58:07,680 --> 00:58:13,680
example you must know that firstly

1423
00:58:10,480 --> 00:58:14,880
1 2 3 4 are not integers they are just

1424
00:58:13,680 --> 00:58:18,720
symbols

1425
00:58:14,880 --> 00:58:21,119
and secondly such encoding

1426
00:58:18,720 --> 00:58:23,359
cannot be basically cannot be general

1427
00:58:21,119 --> 00:58:26,720
why because

1428
00:58:23,359 --> 00:58:29,119
you cannot encode an arbitrary finite

1429
00:58:26,720 --> 00:58:31,680
numbers of nodes

1430
00:58:29,119 --> 00:58:35,040
if you want to do that you need to have

1431
00:58:31,680 --> 00:58:37,520
some new enumerating system for

1432
00:58:35,040 --> 00:58:39,200
like know the

1433
00:58:37,520 --> 00:58:42,400
node number

1434
00:58:39,200 --> 00:58:44,480
2134 something like that and then you

1435
00:58:42,400 --> 00:58:46,880
can encode arbitrary

1436
00:58:44,480 --> 00:58:48,319
numbers of

1437
00:58:46,880 --> 00:58:51,359
vertex

1438
00:58:48,319 --> 00:58:54,160
but for easy representation we use we

1439
00:58:51,359 --> 00:58:56,559
usually use uh something like this and

1440
00:58:54,160 --> 00:58:58,880
we know that it can be

1441
00:58:56,559 --> 00:59:01,839
understandable that uh

1442
00:58:58,880 --> 00:59:04,400
the encoding scheme is important for

1443
00:59:01,839 --> 00:59:07,400
designing a turing machine

1444
00:59:04,400 --> 00:59:07,400
okay

