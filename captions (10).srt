1
00:00:00,880 --> 00:00:05,520
next we will be talking about by hill

2
00:00:03,600 --> 00:00:08,720
the road theorem

3
00:00:05,520 --> 00:00:10,800
before uh introduce the this

4
00:00:08,720 --> 00:00:13,280
theorem we need to

5
00:00:10,800 --> 00:00:14,799
define some

6
00:00:13,280 --> 00:00:16,960
uh

7
00:00:14,799 --> 00:00:19,359
we need to define something first

8
00:00:16,960 --> 00:00:22,080
so uh

9
00:00:19,359 --> 00:00:24,880
let's define

10
00:00:22,080 --> 00:00:24,880
a relation

11
00:00:25,039 --> 00:00:28,880
by using a given language

12
00:00:29,599 --> 00:00:32,480
uh

13
00:00:30,640 --> 00:00:35,600
please note that

14
00:00:32,480 --> 00:00:38,399
the language can be any given language

15
00:00:35,600 --> 00:00:41,520
okay so when we talk about the relation

16
00:00:38,399 --> 00:00:42,719
defined by a given language that means

17
00:00:41,520 --> 00:00:45,440
uh

18
00:00:42,719 --> 00:00:48,000
when you specify a language

19
00:00:45,440 --> 00:00:51,840
and you can use

20
00:00:48,000 --> 00:00:52,800
the definition we will be introducing

21
00:00:51,840 --> 00:00:55,039
to

22
00:00:52,800 --> 00:00:58,399
construct a relation

23
00:00:55,039 --> 00:00:59,680
defined by that given language

24
00:00:58,399 --> 00:01:01,920
okay

25
00:00:59,680 --> 00:01:01,920
so

26
00:01:03,199 --> 00:01:08,479
given a language

27
00:01:05,840 --> 00:01:12,320
let's say l

28
00:01:08,479 --> 00:01:14,400
still l can be any given language okay

29
00:01:12,320 --> 00:01:15,840
given a language l

30
00:01:14,400 --> 00:01:17,360
we say that

31
00:01:15,840 --> 00:01:19,360
we can

32
00:01:17,360 --> 00:01:21,680
distinguish

33
00:01:19,360 --> 00:01:22,560
two strings x and y

34
00:01:21,680 --> 00:01:27,040
okay

35
00:01:22,560 --> 00:01:30,640
x and y here are strings

36
00:01:27,040 --> 00:01:33,200
we use arrow to distinguish strings

37
00:01:30,640 --> 00:01:35,640
and how to do that

38
00:01:33,200 --> 00:01:39,439
we say x and y are

39
00:01:35,640 --> 00:01:39,439
distinguishable by l

40
00:01:39,600 --> 00:01:42,799
if

41
00:01:41,439 --> 00:01:44,079
there is a

42
00:01:42,799 --> 00:01:46,240
string

43
00:01:44,079 --> 00:01:46,240
z

44
00:01:49,920 --> 00:01:57,680
concatenate to x and y

45
00:01:55,119 --> 00:02:01,280
exactly one

46
00:01:57,680 --> 00:02:04,799
of the two strings

47
00:02:01,280 --> 00:02:04,799
is a member of l

48
00:02:05,759 --> 00:02:10,319
okay

49
00:02:07,840 --> 00:02:10,319
that means

50
00:02:11,280 --> 00:02:14,400
you have two strings

51
00:02:14,800 --> 00:02:19,920
right and you have a language l

52
00:02:18,160 --> 00:02:22,959
okay

53
00:02:19,920 --> 00:02:26,879
x and y are any strings

54
00:02:22,959 --> 00:02:29,680
and l is a given language

55
00:02:26,879 --> 00:02:30,560
which can be any language but when it's

56
00:02:29,680 --> 00:02:33,519
given

57
00:02:30,560 --> 00:02:36,400
it's given okay

58
00:02:33,519 --> 00:02:41,120
and x and y

59
00:02:36,400 --> 00:02:41,120
have no particular relationship with l

60
00:02:41,840 --> 00:02:45,519
so

61
00:02:43,680 --> 00:02:48,400
when we have an l

62
00:02:45,519 --> 00:02:51,599
to define a relation

63
00:02:48,400 --> 00:02:55,040
which is used to distinguish x and y

64
00:02:51,599 --> 00:02:56,319
and how do we do that

65
00:02:55,040 --> 00:02:59,200
we try

66
00:02:56,319 --> 00:03:00,319
all possible

67
00:02:59,200 --> 00:03:01,440
strings

68
00:03:00,319 --> 00:03:04,800
okay

69
00:03:01,440 --> 00:03:07,760
we try all possible strings how to try

70
00:03:04,800 --> 00:03:09,680
that we concatenate

71
00:03:07,760 --> 00:03:13,040
z to x

72
00:03:09,680 --> 00:03:14,159
and also z to y

73
00:03:13,040 --> 00:03:15,200
if

74
00:03:14,159 --> 00:03:20,080
okay

75
00:03:15,200 --> 00:03:20,080
if there is any string z

76
00:03:20,480 --> 00:03:25,920
makes

77
00:03:21,760 --> 00:03:28,720
one exactly one of xz

78
00:03:25,920 --> 00:03:28,720
and yz

79
00:03:28,799 --> 00:03:36,000
a member of l

80
00:03:31,680 --> 00:03:36,000
that means if there is some z here

81
00:03:38,319 --> 00:03:41,200
max xz

82
00:03:41,680 --> 00:03:46,080
max xz in l

83
00:03:44,319 --> 00:03:47,680
but y z

84
00:03:46,080 --> 00:03:49,360
not in l

85
00:03:47,680 --> 00:03:50,720
or

86
00:03:49,360 --> 00:03:52,560
x e

87
00:03:50,720 --> 00:03:56,080
not in l

88
00:03:52,560 --> 00:03:58,239
and y z in l

89
00:03:56,080 --> 00:04:02,959
okay exactly

90
00:03:58,239 --> 00:04:05,120
one of the strings xz and yz is a member

91
00:04:02,959 --> 00:04:07,360
of l

92
00:04:05,120 --> 00:04:08,799
if such z

93
00:04:07,360 --> 00:04:11,519
exists

94
00:04:08,799 --> 00:04:16,079
then we say that

95
00:04:11,519 --> 00:04:17,759
x and y the two strings x and y can be

96
00:04:16,079 --> 00:04:19,040
distinguishable

97
00:04:17,759 --> 00:04:20,560
distinguished

98
00:04:19,040 --> 00:04:24,320
by l

99
00:04:20,560 --> 00:04:25,840
and also x and y are distinguishable by

100
00:04:24,320 --> 00:04:29,120
l

101
00:04:25,840 --> 00:04:31,840
if there is some z

102
00:04:29,120 --> 00:04:31,840
making them

103
00:04:33,040 --> 00:04:38,800
making them exactly one of them

104
00:04:36,720 --> 00:04:40,840
a member of l

105
00:04:38,800 --> 00:04:42,639
okay

106
00:04:40,840 --> 00:04:45,840
otherwise

107
00:04:42,639 --> 00:04:49,680
if all possible z

108
00:04:45,840 --> 00:04:49,680
if o possible z

109
00:04:50,800 --> 00:04:53,520
we have

110
00:04:53,840 --> 00:05:01,520
xz in l if and only if

111
00:04:58,800 --> 00:05:02,880
y z in l

112
00:05:01,520 --> 00:05:05,919
okay

113
00:05:02,880 --> 00:05:08,000
that's the situation here you have x and

114
00:05:05,919 --> 00:05:09,199
y

115
00:05:08,000 --> 00:05:12,479
and

116
00:05:09,199 --> 00:05:17,600
here is your language l

117
00:05:12,479 --> 00:05:17,600
and you try all possible z

118
00:05:18,320 --> 00:05:21,759
and you'll find that

119
00:05:20,720 --> 00:05:23,280
x z

120
00:05:21,759 --> 00:05:27,919
and y z

121
00:05:23,280 --> 00:05:27,919
are either both in l

122
00:05:28,000 --> 00:05:32,400
or both outside of l

123
00:05:33,039 --> 00:05:35,840
okay

124
00:05:34,080 --> 00:05:37,120
then we said that

125
00:05:35,840 --> 00:05:38,680
x and y

126
00:05:37,120 --> 00:05:41,360
are

127
00:05:38,680 --> 00:05:42,240
indistinguishable by l

128
00:05:41,360 --> 00:05:46,080
okay

129
00:05:42,240 --> 00:05:46,080
indistinguishable by l

130
00:05:46,880 --> 00:05:53,280
so let's repeat that again

131
00:05:49,039 --> 00:05:55,039
so if you have x and y

132
00:05:53,280 --> 00:05:58,400
and

133
00:05:55,039 --> 00:06:02,479
you want to use l

134
00:05:58,400 --> 00:06:05,680
as the relation to distinguish x and y

135
00:06:02,479 --> 00:06:07,840
the process is that you try all possible

136
00:06:05,680 --> 00:06:07,840
z

137
00:06:08,000 --> 00:06:12,400
if

138
00:06:08,880 --> 00:06:15,680
one of the resultant string

139
00:06:12,400 --> 00:06:18,319
in l and the other out

140
00:06:15,680 --> 00:06:18,319
out of l

141
00:06:18,560 --> 00:06:25,360
then we say that these two strings

142
00:06:23,280 --> 00:06:28,800
are distinguishable by l

143
00:06:25,360 --> 00:06:31,600
otherwise they are indistinguishable by

144
00:06:28,800 --> 00:06:35,080
all that means if

145
00:06:31,600 --> 00:06:35,080
you count

146
00:06:35,199 --> 00:06:39,360
for all possible strings the

147
00:06:39,680 --> 00:06:45,759
you concatenate

148
00:06:42,080 --> 00:06:45,759
you append it to x

149
00:06:46,000 --> 00:06:48,400
and

150
00:06:46,840 --> 00:06:50,160
y

151
00:06:48,400 --> 00:06:51,919
the two strings

152
00:06:50,160 --> 00:06:55,680
are either

153
00:06:51,919 --> 00:06:58,199
both in l or both outside of l

154
00:06:55,680 --> 00:07:00,960
then we say that x and y are

155
00:06:58,199 --> 00:07:03,840
indistinguishable by l

156
00:07:00,960 --> 00:07:03,840
okay

157
00:07:03,919 --> 00:07:10,160
if x and y are indistinguishable by l

158
00:07:07,599 --> 00:07:10,160
we write

159
00:07:11,199 --> 00:07:15,080
we use this notation

160
00:07:19,199 --> 00:07:23,440
to denote the relation

161
00:07:21,840 --> 00:07:26,160
okay

162
00:07:23,440 --> 00:07:26,160
in other words

163
00:07:27,039 --> 00:07:33,840
for x and y

164
00:07:30,479 --> 00:07:33,840
we denote x

165
00:07:34,639 --> 00:07:39,280
and y are

166
00:07:36,199 --> 00:07:41,440
indistinguishable by l

167
00:07:39,280 --> 00:07:42,400
if and only if

168
00:07:41,440 --> 00:07:45,840
for

169
00:07:42,400 --> 00:07:45,840
each z

170
00:07:45,919 --> 00:07:54,199
xz

171
00:07:47,440 --> 00:07:54,199
in l if and only if yz in l

172
00:08:02,560 --> 00:08:06,160
with

173
00:08:03,440 --> 00:08:08,400
this construction

174
00:08:06,160 --> 00:08:10,879
for any given language

175
00:08:08,400 --> 00:08:12,879
we can make some relationship

176
00:08:10,879 --> 00:08:16,639
like this

177
00:08:12,879 --> 00:08:18,160
and we can use such a relationship

178
00:08:16,639 --> 00:08:21,120
to distinguish

179
00:08:18,160 --> 00:08:26,160
arbitrary strings

180
00:08:21,120 --> 00:08:31,039
and this relation we just defined

181
00:08:26,160 --> 00:08:31,039
is actually an equivalence relation

182
00:08:32,479 --> 00:08:36,159
so

183
00:08:34,000 --> 00:08:39,120
if two strings x and y are

184
00:08:36,159 --> 00:08:41,440
indistinguishable by l

185
00:08:39,120 --> 00:08:42,560
in a way you can consider

186
00:08:41,440 --> 00:08:45,839
x and y

187
00:08:42,560 --> 00:08:45,839
are equivalent

188
00:08:46,320 --> 00:08:52,240
by using l

189
00:08:48,480 --> 00:08:53,279
or according to the criteria

190
00:08:52,240 --> 00:08:55,839
of l

191
00:08:53,279 --> 00:08:55,839
something like that

192
00:08:56,000 --> 00:08:59,440
okay

193
00:08:56,959 --> 00:09:02,800
and why this relationship

194
00:08:59,440 --> 00:09:04,080
why this relation defined by a language

195
00:09:02,800 --> 00:09:06,480
is

196
00:09:04,080 --> 00:09:08,240
an equivalence relation

197
00:09:06,480 --> 00:09:10,080
because

198
00:09:08,240 --> 00:09:12,480
it satisfied

199
00:09:10,080 --> 00:09:12,480
three

200
00:09:13,760 --> 00:09:17,920
conditions or we said it has the

201
00:09:16,320 --> 00:09:19,440
following three

202
00:09:17,920 --> 00:09:20,800
properties

203
00:09:19,440 --> 00:09:22,399
first one

204
00:09:20,800 --> 00:09:25,360
such a relation

205
00:09:22,399 --> 00:09:27,680
is reflexive

206
00:09:25,360 --> 00:09:30,800
what is reflective that means

207
00:09:27,680 --> 00:09:33,040
every element in discussion

208
00:09:30,800 --> 00:09:34,240
has such relationship

209
00:09:33,040 --> 00:09:36,720
with

210
00:09:34,240 --> 00:09:38,000
itself

211
00:09:36,720 --> 00:09:39,760
okay

212
00:09:38,000 --> 00:09:41,040
so

213
00:09:39,760 --> 00:09:45,200
when you

214
00:09:41,040 --> 00:09:47,440
look at the how we define a relation

215
00:09:45,200 --> 00:09:50,240
obviously

216
00:09:47,440 --> 00:09:51,440
x and the x

217
00:09:50,240 --> 00:09:53,200
always

218
00:09:51,440 --> 00:09:56,000
have

219
00:09:53,200 --> 00:09:57,680
the property like this right

220
00:09:56,000 --> 00:09:59,760
so

221
00:09:57,680 --> 00:10:01,440
any string has

222
00:09:59,760 --> 00:10:04,640
the relationship

223
00:10:01,440 --> 00:10:05,519
the relation with itself

224
00:10:04,640 --> 00:10:09,200
not

225
00:10:05,519 --> 00:10:11,279
many uh sorry not every relation has the

226
00:10:09,200 --> 00:10:13,839
property of reflexive

227
00:10:11,279 --> 00:10:13,839
let's say

228
00:10:14,399 --> 00:10:18,480
everybody knows that uh we have like

229
00:10:17,120 --> 00:10:19,519
greater than

230
00:10:18,480 --> 00:10:22,240
okay

231
00:10:19,519 --> 00:10:23,680
greater than four let's say integers or

232
00:10:22,240 --> 00:10:24,959
values

233
00:10:23,680 --> 00:10:28,240
so

234
00:10:24,959 --> 00:10:28,240
for integer five

235
00:10:28,560 --> 00:10:32,079
it doesn't

236
00:10:30,000 --> 00:10:34,640
such a relation

237
00:10:32,079 --> 00:10:38,640
greater than

238
00:10:34,640 --> 00:10:40,240
has no reflexive relation

239
00:10:38,640 --> 00:10:41,440
uh property right

240
00:10:40,240 --> 00:10:44,839
because

241
00:10:41,440 --> 00:10:48,160
an integer is not greater than

242
00:10:44,839 --> 00:10:48,160
itself okay

243
00:10:48,959 --> 00:10:53,360
for the second property

244
00:10:51,200 --> 00:10:55,360
this relation here

245
00:10:53,360 --> 00:10:56,640
has symmetric

246
00:10:55,360 --> 00:10:58,399
property

247
00:10:56,640 --> 00:10:59,519
that means

248
00:10:58,399 --> 00:11:00,480
if

249
00:10:59,519 --> 00:11:02,240
two

250
00:11:00,480 --> 00:11:05,440
elements

251
00:11:02,240 --> 00:11:05,440
has the relation

252
00:11:07,680 --> 00:11:11,760
x

253
00:11:08,800 --> 00:11:14,880
has the relation with y

254
00:11:11,760 --> 00:11:16,000
y also has the relation

255
00:11:14,880 --> 00:11:19,040
with x

256
00:11:16,000 --> 00:11:21,360
that's called symmetric

257
00:11:19,040 --> 00:11:21,360
okay

258
00:11:23,200 --> 00:11:28,040
so

259
00:11:24,320 --> 00:11:28,040
for x for example

260
00:11:30,959 --> 00:11:35,360
five

261
00:11:32,399 --> 00:11:37,200
is greater than or equal to

262
00:11:35,360 --> 00:11:38,800
three

263
00:11:37,200 --> 00:11:40,079
and you know that

264
00:11:38,800 --> 00:11:41,760
three is

265
00:11:40,079 --> 00:11:45,440
not

266
00:11:41,760 --> 00:11:46,720
greater than and equal to 5

267
00:11:45,440 --> 00:11:48,240
right

268
00:11:46,720 --> 00:11:52,000
so

269
00:11:48,240 --> 00:11:52,000
not all relation

270
00:11:52,079 --> 00:11:58,399
have such property of symmetric

271
00:11:56,079 --> 00:12:00,480
and the third property is

272
00:11:58,399 --> 00:12:01,760
transitive

273
00:12:00,480 --> 00:12:05,279
okay

274
00:12:01,760 --> 00:12:08,800
now the definition here is like

275
00:12:05,279 --> 00:12:11,839
x and what has relation with y this

276
00:12:08,800 --> 00:12:16,079
relation with y and y has this relation

277
00:12:11,839 --> 00:12:17,680
with z then we have x has the relation

278
00:12:16,079 --> 00:12:20,320
with z

279
00:12:17,680 --> 00:12:21,519
so one of the example is like

280
00:12:20,320 --> 00:12:23,760
5

281
00:12:21,519 --> 00:12:24,720
greater than or equal to

282
00:12:23,760 --> 00:12:27,760
three

283
00:12:24,720 --> 00:12:29,680
and you know three greater than or equal

284
00:12:27,760 --> 00:12:30,800
to one

285
00:12:29,680 --> 00:12:32,800
then

286
00:12:30,800 --> 00:12:34,000
you know that

287
00:12:32,800 --> 00:12:36,639
five

288
00:12:34,000 --> 00:12:39,680
greater than or equal to one

289
00:12:36,639 --> 00:12:42,720
okay that's transitive

290
00:12:39,680 --> 00:12:42,720
any relation

291
00:12:43,440 --> 00:12:47,120
has

292
00:12:44,240 --> 00:12:50,720
the three property

293
00:12:47,120 --> 00:12:50,720
is an equivalence relation

294
00:12:51,519 --> 00:12:55,200
the concept is pretty much the same as

295
00:12:54,079 --> 00:12:56,079
equal

296
00:12:55,200 --> 00:12:58,079
right

297
00:12:56,079 --> 00:13:01,839
so if you check

298
00:12:58,079 --> 00:13:03,920
greater than greater equal and

299
00:13:01,839 --> 00:13:05,440
less than

300
00:13:03,920 --> 00:13:07,760
and

301
00:13:05,440 --> 00:13:09,120
like these operators or this

302
00:13:07,760 --> 00:13:10,800
relationship

303
00:13:09,120 --> 00:13:13,360
you know that only

304
00:13:10,800 --> 00:13:14,320
equivalent

305
00:13:13,360 --> 00:13:16,240
let's say

306
00:13:14,320 --> 00:13:20,399
equal has such

307
00:13:16,240 --> 00:13:23,279
has all the three properties

308
00:13:20,399 --> 00:13:25,360
because you any member is

309
00:13:23,279 --> 00:13:28,240
itself right

310
00:13:25,360 --> 00:13:30,240
and it doesn't matter

311
00:13:28,240 --> 00:13:32,560
if

312
00:13:30,240 --> 00:13:32,560
x

313
00:13:33,040 --> 00:13:38,560
the order doesn't matter okay

314
00:13:35,920 --> 00:13:40,000
and also you have transitive

315
00:13:38,560 --> 00:13:42,639
property

316
00:13:40,000 --> 00:13:44,800
so you have

317
00:13:42,639 --> 00:13:48,399
something like

318
00:13:44,800 --> 00:13:50,720
the concept of equal so it's that's why

319
00:13:48,399 --> 00:13:54,320
we also use the notation

320
00:13:50,720 --> 00:13:58,800
like this one and define it by l

321
00:13:54,320 --> 00:14:02,800
so we can use this way to define

322
00:13:58,800 --> 00:14:05,120
an equivalence relation

323
00:14:02,800 --> 00:14:05,120
okay

324
00:14:06,240 --> 00:14:10,560
so let's give an example here

325
00:14:15,680 --> 00:14:21,199
if the alphabet here is 0 1

326
00:14:19,120 --> 00:14:23,279
as we usually have

327
00:14:21,199 --> 00:14:25,680
and let's say

328
00:14:23,279 --> 00:14:28,480
if there is a language here

329
00:14:25,680 --> 00:14:28,480
defined as

330
00:14:28,800 --> 00:14:31,519
0 string

331
00:14:30,480 --> 00:14:33,199
but no

332
00:14:31,519 --> 00:14:34,480
uh empty string

333
00:14:33,199 --> 00:14:35,600
so

334
00:14:34,480 --> 00:14:36,399
what are

335
00:14:35,600 --> 00:14:39,040
uh

336
00:14:36,399 --> 00:14:40,880
what are these strings in this language

337
00:14:39,040 --> 00:14:42,160
that'll be

338
00:14:40,880 --> 00:14:44,480
zero

339
00:14:42,160 --> 00:14:46,800
zero zero

340
00:14:44,480 --> 00:14:49,040
0 0 0

341
00:14:46,800 --> 00:14:52,560
4 0's

342
00:14:49,040 --> 00:14:56,839
and 5 etc etc right

343
00:14:52,560 --> 00:14:59,440
so that will be our language l0 here

344
00:14:56,839 --> 00:15:01,360
then use the

345
00:14:59,440 --> 00:15:02,720
procedure checking procedure we just

346
00:15:01,360 --> 00:15:04,320
introduced

347
00:15:02,720 --> 00:15:07,199
we can define

348
00:15:04,320 --> 00:15:07,199
a relation

349
00:15:08,320 --> 00:15:11,360
by l0

350
00:15:10,399 --> 00:15:13,680
okay

351
00:15:11,360 --> 00:15:16,480
then we can start

352
00:15:13,680 --> 00:15:18,959
to check the equivalence

353
00:15:16,480 --> 00:15:22,720
based on l0

354
00:15:18,959 --> 00:15:22,720
of any two strings

355
00:15:23,519 --> 00:15:26,639
in sigma star

356
00:15:25,279 --> 00:15:29,360
okay

357
00:15:26,639 --> 00:15:30,480
so firstly we check

358
00:15:29,360 --> 00:15:33,120
zero

359
00:15:30,480 --> 00:15:35,360
and zero zero zero

360
00:15:33,120 --> 00:15:35,360
right

361
00:15:38,320 --> 00:15:40,959
so

362
00:15:39,199 --> 00:15:42,480
let's say

363
00:15:40,959 --> 00:15:45,360
we

364
00:15:42,480 --> 00:15:47,519
for the given procedure actually we need

365
00:15:45,360 --> 00:15:50,160
to check all possible strings

366
00:15:47,519 --> 00:15:51,839
right so let's say what are all possible

367
00:15:50,160 --> 00:15:53,519
string in sigma star

368
00:15:51,839 --> 00:15:54,959
that will be

369
00:15:53,519 --> 00:15:56,160
epsilon

370
00:15:54,959 --> 00:15:58,399
0

371
00:15:56,160 --> 00:15:59,839
1 0 0

372
00:15:58,399 --> 00:16:04,399
0 1

373
00:15:59,839 --> 00:16:06,320
1 0 1 1 and 0 0 0

374
00:16:04,399 --> 00:16:10,160
etc right

375
00:16:06,320 --> 00:16:10,160
that's all possible strings

376
00:16:11,759 --> 00:16:18,480
then let's try uh some of them

377
00:16:15,279 --> 00:16:20,639
so we can connect absorb

378
00:16:18,480 --> 00:16:23,040
to

379
00:16:20,639 --> 00:16:25,600
the tool string here

380
00:16:23,040 --> 00:16:28,480
then you will find that

381
00:16:25,600 --> 00:16:30,639
they are both in l right

382
00:16:28,480 --> 00:16:33,360
they are both in uh sorry they are both

383
00:16:30,639 --> 00:16:34,839
in l0

384
00:16:33,360 --> 00:16:37,680
then we

385
00:16:34,839 --> 00:16:40,079
try container one that's already zero

386
00:16:37,680 --> 00:16:43,360
here then you got four zeros

387
00:16:40,079 --> 00:16:44,720
they are both in l

388
00:16:43,360 --> 00:16:47,199
both in l

389
00:16:44,720 --> 00:16:49,279
and they're both in l

390
00:16:47,199 --> 00:16:53,600
and then you show one that would be zero

391
00:16:49,279 --> 00:16:55,759
1 there will be 0 0 0 1 they are both

392
00:16:53,600 --> 00:16:59,839
out of l

393
00:16:55,759 --> 00:17:02,000
okay then you try 0 0 they'll become

394
00:16:59,839 --> 00:17:03,199
3 0

395
00:17:02,000 --> 00:17:04,400
4 0

396
00:17:03,199 --> 00:17:05,520
they are both

397
00:17:04,400 --> 00:17:08,400
in air

398
00:17:05,520 --> 00:17:09,679
sorry l0 here

399
00:17:08,400 --> 00:17:13,280
okay

400
00:17:09,679 --> 00:17:15,120
then you try zero one that will be zero

401
00:17:13,280 --> 00:17:17,600
zero one

402
00:17:15,120 --> 00:17:18,880
zero zero zero

403
00:17:17,600 --> 00:17:21,039
0

404
00:17:18,880 --> 00:17:21,039
1

405
00:17:21,679 --> 00:17:24,720
1 3 0

406
00:17:25,679 --> 00:17:31,600
2 here okay

407
00:17:27,360 --> 00:17:33,120
they are both out of l uh l0

408
00:17:31,600 --> 00:17:35,520
so

409
00:17:33,120 --> 00:17:37,520
repeat all the process for all possible

410
00:17:35,520 --> 00:17:40,160
string you will find that

411
00:17:37,520 --> 00:17:42,559
as long as you append

412
00:17:40,160 --> 00:17:44,640
a z

413
00:17:42,559 --> 00:17:47,120
without one

414
00:17:44,640 --> 00:17:50,080
without one like

415
00:17:47,120 --> 00:17:52,640
epsilon zero zero zero

416
00:17:50,080 --> 00:17:55,120
zero zero zero etc

417
00:17:52,640 --> 00:17:58,640
the resultant strings are all

418
00:17:55,120 --> 00:18:01,440
uh both in l uh l zero

419
00:17:58,640 --> 00:18:02,240
otherwise as long as the z

420
00:18:01,440 --> 00:18:04,320
has

421
00:18:02,240 --> 00:18:05,360
one in the string

422
00:18:04,320 --> 00:18:06,400
then

423
00:18:05,360 --> 00:18:08,400
both

424
00:18:06,400 --> 00:18:10,480
of the resultant string

425
00:18:08,400 --> 00:18:11,679
are out of arrow

426
00:18:10,480 --> 00:18:12,840
l zero

427
00:18:11,679 --> 00:18:16,240
out of l

428
00:18:12,840 --> 00:18:16,240
zero so

429
00:18:16,960 --> 00:18:21,480
zero and zero zero zero

430
00:18:20,480 --> 00:18:23,600
are

431
00:18:21,480 --> 00:18:25,840
indistinguishable by

432
00:18:23,600 --> 00:18:29,039
l zero here

433
00:18:25,840 --> 00:18:32,080
so they can be constant they can be

434
00:18:29,039 --> 00:18:36,400
considered equivalent

435
00:18:32,080 --> 00:18:36,400
they can be considered equivalent

436
00:18:38,799 --> 00:18:44,320
with the relation defined by l0

437
00:18:42,960 --> 00:18:47,200
okay

438
00:18:44,320 --> 00:18:50,320
so let's try the next one

439
00:18:47,200 --> 00:18:52,880
one one and the one zero one

440
00:18:50,320 --> 00:18:54,880
and you will find that no matter

441
00:18:52,880 --> 00:18:56,400
which string

442
00:18:54,880 --> 00:18:58,240
you select from

443
00:18:56,400 --> 00:18:59,919
sigma star

444
00:18:58,240 --> 00:19:04,720
no matter which string you select from

445
00:18:59,919 --> 00:19:06,240
sigma star the resultant string always

446
00:19:04,720 --> 00:19:07,520
out of l

447
00:19:06,240 --> 00:19:09,760
right

448
00:19:07,520 --> 00:19:11,600
sorry out of l0

449
00:19:09,760 --> 00:19:15,039
so they are the

450
00:19:11,600 --> 00:19:17,919
two strings here are also in

451
00:19:15,039 --> 00:19:19,039
distinguishable by l

452
00:19:17,919 --> 00:19:21,120
because

453
00:19:19,039 --> 00:19:26,000
no matter which string you

454
00:19:21,120 --> 00:19:28,960
append to the two string x and y here

455
00:19:26,000 --> 00:19:28,960
there is no way

456
00:19:29,039 --> 00:19:33,520
to get the situation that one of the

457
00:19:31,600 --> 00:19:38,720
resultant string

458
00:19:33,520 --> 00:19:39,919
is in l and the other is out of l

459
00:19:38,720 --> 00:19:43,840
finally

460
00:19:39,919 --> 00:19:45,600
let's try this example epsilon and zero

461
00:19:43,840 --> 00:19:47,120
zero

462
00:19:45,600 --> 00:19:49,360
okay

463
00:19:47,120 --> 00:19:53,919
so when you append

464
00:19:49,360 --> 00:19:56,000
epsilon to epsilon you get epsilon right

465
00:19:53,919 --> 00:19:58,320
and epsilon is not

466
00:19:56,000 --> 00:20:03,520
in l0

467
00:19:58,320 --> 00:20:08,080
and you append epsilon 2 0 0 you get 0 0

468
00:20:03,520 --> 00:20:11,120
which is in l0 so see that

469
00:20:08,080 --> 00:20:13,679
one is in l the other is not

470
00:20:11,120 --> 00:20:15,840
so they are

471
00:20:13,679 --> 00:20:17,440
these two string empty string and the

472
00:20:15,840 --> 00:20:18,840
zero zero

473
00:20:17,440 --> 00:20:22,240
are

474
00:20:18,840 --> 00:20:25,760
distinguishable by l

475
00:20:22,240 --> 00:20:28,559
in other words they are not

476
00:20:25,760 --> 00:20:28,559
equivalent

477
00:20:29,360 --> 00:20:35,520
with the relation defined by l

478
00:20:31,919 --> 00:20:37,840
l 0 sorry

479
00:20:35,520 --> 00:20:37,840
okay

480
00:20:39,600 --> 00:20:42,240
so you can

481
00:20:43,120 --> 00:20:48,720
use the relationship

482
00:20:45,760 --> 00:20:52,559
you can use the relation defined by some

483
00:20:48,720 --> 00:20:54,559
given language to

484
00:20:52,559 --> 00:20:55,840
distinguish

485
00:20:54,559 --> 00:20:57,760
any

486
00:20:55,840 --> 00:21:01,360
strings

487
00:20:57,760 --> 00:21:04,320
okay so you you need to pay attention to

488
00:21:01,360 --> 00:21:06,559
the definition here firstly

489
00:21:04,320 --> 00:21:09,120
the language used to

490
00:21:06,559 --> 00:21:13,919
define the relation

491
00:21:09,120 --> 00:21:13,919
can be any possible language

492
00:21:14,840 --> 00:21:20,640
second the string to be

493
00:21:18,159 --> 00:21:23,200
checked to be examined if they are

494
00:21:20,640 --> 00:21:24,480
distinguishable by that language

495
00:21:23,200 --> 00:21:27,840
they have

496
00:21:24,480 --> 00:21:30,080
they have no relation

497
00:21:27,840 --> 00:21:32,320
they are they they don't need to be in

498
00:21:30,080 --> 00:21:34,480
that language or not in that language

499
00:21:32,320 --> 00:21:37,360
they are just

500
00:21:34,480 --> 00:21:40,000
some strings in

501
00:21:37,360 --> 00:21:42,000
the possible languages of the given

502
00:21:40,000 --> 00:21:45,000
alphabet

503
00:21:42,000 --> 00:21:45,000
okay

504
00:21:45,039 --> 00:21:49,360
okay

505
00:21:46,159 --> 00:21:50,799
now we have an we have an equivalent

506
00:21:49,360 --> 00:21:51,760
relation

507
00:21:50,799 --> 00:21:53,679
okay

508
00:21:51,760 --> 00:21:54,960
equivalent relation is

509
00:21:53,679 --> 00:21:57,200
well

510
00:21:54,960 --> 00:22:00,640
interesting because

511
00:21:57,200 --> 00:22:02,799
when you use equivalent relation

512
00:22:00,640 --> 00:22:04,880
you can use

513
00:22:02,799 --> 00:22:09,280
when you have recovered an equivalent

514
00:22:04,880 --> 00:22:12,280
relation you can use such relation to do

515
00:22:09,280 --> 00:22:12,280
classification

516
00:22:12,400 --> 00:22:17,520
what does that mean

517
00:22:14,400 --> 00:22:17,520
okay consider that

518
00:22:18,000 --> 00:22:21,120
we

519
00:22:19,360 --> 00:22:25,039
look at

520
00:22:21,120 --> 00:22:26,720
each other i mean all students id

521
00:22:25,039 --> 00:22:28,159
okay our student id

522
00:22:26,720 --> 00:22:31,280
then i said

523
00:22:28,159 --> 00:22:34,799
let's see the last digit okay for

524
00:22:31,280 --> 00:22:35,840
example if your student id is one two

525
00:22:34,799 --> 00:22:37,600
three

526
00:22:35,840 --> 00:22:39,600
four five

527
00:22:37,600 --> 00:22:41,440
six seven

528
00:22:39,600 --> 00:22:42,799
that's that let's see the

529
00:22:41,440 --> 00:22:45,440
the final

530
00:22:42,799 --> 00:22:48,000
the last digit

531
00:22:45,440 --> 00:22:49,600
let's define an equivalent equivalent

532
00:22:48,000 --> 00:22:51,440
relation here

533
00:22:49,600 --> 00:22:52,880
i said okay

534
00:22:51,440 --> 00:22:54,960
if

535
00:22:52,880 --> 00:22:58,240
if

536
00:22:54,960 --> 00:22:58,240
it's an odd number

537
00:22:58,720 --> 00:23:04,400
then i consider then consider all odd

538
00:23:02,000 --> 00:23:06,960
number equivalent

539
00:23:04,400 --> 00:23:09,600
to each other and all even number

540
00:23:06,960 --> 00:23:11,360
equivalent to each other

541
00:23:09,600 --> 00:23:16,799
so

542
00:23:11,360 --> 00:23:20,080
1 2 3 4 5 6 9

543
00:23:16,799 --> 00:23:23,760
is equivalent to

544
00:23:20,080 --> 00:23:26,480
the relation i just defined right and

545
00:23:23,760 --> 00:23:27,760
not equivalent to like

546
00:23:26,480 --> 00:23:28,720
eight here

547
00:23:27,760 --> 00:23:30,640
but

548
00:23:28,720 --> 00:23:32,080
if you end with

549
00:23:30,640 --> 00:23:34,000
a

550
00:23:32,080 --> 00:23:37,120
the num the student number will be

551
00:23:34,000 --> 00:23:39,360
equivalent to something end with

552
00:23:37,120 --> 00:23:39,360
4

553
00:23:39,600 --> 00:23:44,640
and

554
00:23:41,200 --> 00:23:46,720
is this using a oddity

555
00:23:44,640 --> 00:23:49,600
odd or even

556
00:23:46,720 --> 00:23:53,840
an equivalent relation yes it is why

557
00:23:49,600 --> 00:23:55,360
because you can check that with these

558
00:23:53,840 --> 00:23:57,520
properties

559
00:23:55,360 --> 00:23:59,679
for r and even

560
00:23:57,520 --> 00:24:02,400
all numbers

561
00:23:59,679 --> 00:24:05,039
have such a relation because

562
00:24:02,400 --> 00:24:06,080
let's say 5

563
00:24:05,039 --> 00:24:09,360
5

564
00:24:06,080 --> 00:24:10,799
and symmetric of course and transitive

565
00:24:09,360 --> 00:24:13,279
yes right

566
00:24:10,799 --> 00:24:14,799
so we can use add an even as an

567
00:24:13,279 --> 00:24:16,320
equivalent relation

568
00:24:14,799 --> 00:24:20,240
and after you have an equivalent

569
00:24:16,320 --> 00:24:22,960
relation you can using that to classify

570
00:24:20,240 --> 00:24:27,039
all the members you are discussing

571
00:24:22,960 --> 00:24:29,600
so if i use add an event

572
00:24:27,039 --> 00:24:31,039
how many class

573
00:24:29,600 --> 00:24:33,679
i can

574
00:24:31,039 --> 00:24:35,440
classify student id

575
00:24:33,679 --> 00:24:38,880
2 right

576
00:24:35,440 --> 00:24:42,159
all students are all student ids ending

577
00:24:38,880 --> 00:24:46,000
with an odd number 1 3

578
00:24:42,159 --> 00:24:47,440
5 7 9.

579
00:24:46,000 --> 00:24:52,480
is a group

580
00:24:47,440 --> 00:24:54,320
because any student id within this group

581
00:24:52,480 --> 00:24:57,360
they are equivalent

582
00:24:54,320 --> 00:25:01,039
and the other group will be ending with

583
00:24:57,360 --> 00:25:02,640
0 2 4 6 8

584
00:25:01,039 --> 00:25:05,200
and same

585
00:25:02,640 --> 00:25:08,400
all members within

586
00:25:05,200 --> 00:25:11,679
this group they are equivalent

587
00:25:08,400 --> 00:25:13,360
and all members across group they are

588
00:25:11,679 --> 00:25:14,799
not equivalent

589
00:25:13,360 --> 00:25:16,880
okay

590
00:25:14,799 --> 00:25:18,880
so using uh

591
00:25:16,880 --> 00:25:22,320
oddity i can

592
00:25:18,880 --> 00:25:24,880
classify all possible students id into

593
00:25:22,320 --> 00:25:24,880
two groups

594
00:25:25,120 --> 00:25:29,600
okay so that's slightly generalized the

595
00:25:28,240 --> 00:25:31,520
concept here

596
00:25:29,600 --> 00:25:32,960
if i

597
00:25:31,520 --> 00:25:34,159
if i

598
00:25:32,960 --> 00:25:36,320
define

599
00:25:34,159 --> 00:25:38,640
like

600
00:25:36,320 --> 00:25:42,480
uh i check two persons

601
00:25:38,640 --> 00:25:44,880
and if their blood type let's say

602
00:25:42,480 --> 00:25:48,960
we don't want to go into the biology

603
00:25:44,880 --> 00:25:51,360
detail or medicine detail but

604
00:25:48,960 --> 00:25:53,679
if it does say the blood type

605
00:25:51,360 --> 00:25:58,640
there are only four blood type okay

606
00:25:53,679 --> 00:25:58,640
let's say there are only four blood type

607
00:25:59,279 --> 00:26:02,000
then

608
00:26:00,559 --> 00:26:05,200
if we consider

609
00:26:02,000 --> 00:26:07,120
people of the same blood type as

610
00:26:05,200 --> 00:26:09,679
equivalent then

611
00:26:07,120 --> 00:26:11,760
such checking criteria

612
00:26:09,679 --> 00:26:14,640
such judging criteria

613
00:26:11,760 --> 00:26:18,799
can be considered an equivalent relation

614
00:26:14,640 --> 00:26:20,080
and you can classify people into four

615
00:26:18,799 --> 00:26:23,120
groups

616
00:26:20,080 --> 00:26:27,440
right a group of blood type a a group of

617
00:26:23,120 --> 00:26:27,440
blood type b and a b and o

618
00:26:28,320 --> 00:26:31,039
okay

619
00:26:29,200 --> 00:26:34,640
so for many

620
00:26:31,039 --> 00:26:38,679
oh sorry so for any equivalent relation

621
00:26:34,640 --> 00:26:38,679
you can use it to classify

622
00:26:39,120 --> 00:26:41,440
said

623
00:26:40,000 --> 00:26:44,559
okay

624
00:26:41,440 --> 00:26:45,760
and also consider that

625
00:26:44,559 --> 00:26:47,360
if

626
00:26:45,760 --> 00:26:49,360
for all people

627
00:26:47,360 --> 00:26:51,360
i want to

628
00:26:49,360 --> 00:26:54,720
say okay

629
00:26:51,360 --> 00:26:57,679
randomly pick one people

630
00:26:54,720 --> 00:26:57,679
that people will be

631
00:26:57,840 --> 00:27:02,480
a or b or o or a b right

632
00:27:01,600 --> 00:27:04,400
then

633
00:27:02,480 --> 00:27:05,679
if i want to i want to pick another

634
00:27:04,400 --> 00:27:07,840
people

635
00:27:05,679 --> 00:27:09,840
okay and other people

636
00:27:07,840 --> 00:27:11,360
then

637
00:27:09,840 --> 00:27:13,520
these the

638
00:27:11,360 --> 00:27:16,159
the second people

639
00:27:13,520 --> 00:27:20,000
are also one of

640
00:27:16,159 --> 00:27:24,399
a b a b or o right

641
00:27:20,000 --> 00:27:28,080
what if i said okay i want to uh

642
00:27:24,399 --> 00:27:29,520
i want to have a group a group of people

643
00:27:28,080 --> 00:27:31,840
but

644
00:27:29,520 --> 00:27:33,200
all each of them

645
00:27:31,840 --> 00:27:36,559
are

646
00:27:33,200 --> 00:27:39,520
not equivalent according to

647
00:27:36,559 --> 00:27:41,919
the judging criteria here

648
00:27:39,520 --> 00:27:44,240
that means i want to have a group of

649
00:27:41,919 --> 00:27:48,480
people

650
00:27:44,240 --> 00:27:50,799
for example 1 from a and two from o

651
00:27:48,480 --> 00:27:52,480
i don't want them to have to have the

652
00:27:50,799 --> 00:27:54,159
same block type

653
00:27:52,480 --> 00:27:57,279
and how large

654
00:27:54,159 --> 00:27:58,080
can this group be

655
00:27:57,279 --> 00:28:01,279
for

656
00:27:58,080 --> 00:28:04,559
the for the blood type example

657
00:28:01,279 --> 00:28:04,559
this group can

658
00:28:04,640 --> 00:28:07,200
have at most

659
00:28:06,399 --> 00:28:09,200
four

660
00:28:07,200 --> 00:28:12,159
people right

661
00:28:09,200 --> 00:28:15,200
it is clearly that

662
00:28:12,159 --> 00:28:18,880
the largest group in this definition

663
00:28:15,200 --> 00:28:18,880
will be each one

664
00:28:19,200 --> 00:28:25,520
each uh each people for example you have

665
00:28:22,399 --> 00:28:28,559
first people from a second people from o

666
00:28:25,520 --> 00:28:30,720
third people from a b

667
00:28:28,559 --> 00:28:32,320
and the fourth people

668
00:28:30,720 --> 00:28:35,840
from b

669
00:28:32,320 --> 00:28:38,480
and if you have one more people

670
00:28:35,840 --> 00:28:41,039
it meant it must be it must be from one

671
00:28:38,480 --> 00:28:44,080
of the four

672
00:28:41,039 --> 00:28:46,080
possibilities right then

673
00:28:44,080 --> 00:28:48,880
five people will not

674
00:28:46,080 --> 00:28:48,880
make the group

675
00:28:50,559 --> 00:28:56,159
what i want what i want i want a group

676
00:28:54,399 --> 00:28:57,520
in

677
00:28:56,159 --> 00:29:00,000
i want a group

678
00:28:57,520 --> 00:29:02,640
and the people in this group

679
00:29:00,000 --> 00:29:02,640
has no

680
00:29:03,279 --> 00:29:07,120
uh same blood type

681
00:29:07,440 --> 00:29:10,080
okay

682
00:29:08,799 --> 00:29:12,880
so that's

683
00:29:10,080 --> 00:29:16,399
uh do another other example

684
00:29:12,880 --> 00:29:18,000
we again we use student id so ending

685
00:29:16,399 --> 00:29:18,960
with 0

686
00:29:18,000 --> 00:29:20,480
1

687
00:29:18,960 --> 00:29:21,520
2 2

688
00:29:20,480 --> 00:29:22,320
9

689
00:29:21,520 --> 00:29:23,279
right

690
00:29:22,320 --> 00:29:25,840
and we

691
00:29:23,279 --> 00:29:27,679
directly use the last digit as the

692
00:29:25,840 --> 00:29:29,039
checking criteria as the judging

693
00:29:27,679 --> 00:29:32,000
criteria

694
00:29:29,039 --> 00:29:34,320
in this way we can

695
00:29:32,000 --> 00:29:36,320
classify the whole

696
00:29:34,320 --> 00:29:38,080
student body into

697
00:29:36,320 --> 00:29:41,440
10

698
00:29:38,080 --> 00:29:43,600
categories 10 classes right

699
00:29:41,440 --> 00:29:46,880
and how many

700
00:29:43,600 --> 00:29:49,279
people can be in a group that within a

701
00:29:46,880 --> 00:29:51,840
group there's no

702
00:29:49,279 --> 00:29:54,559
students from two different

703
00:29:51,840 --> 00:29:56,159
groups two different classes so the

704
00:29:54,559 --> 00:29:58,799
answer is 10

705
00:29:56,159 --> 00:30:01,679
in this case right because

706
00:29:58,799 --> 00:30:04,799
you can have fewer people achieving

707
00:30:01,679 --> 00:30:06,799
you know people from a different group

708
00:30:04,799 --> 00:30:09,279
but if you have 11 there must be

709
00:30:06,799 --> 00:30:11,600
duplication

710
00:30:09,279 --> 00:30:11,600
okay

711
00:30:12,000 --> 00:30:17,039
so let's go into the details of my heel

712
00:30:15,440 --> 00:30:20,799
and the road theorem

713
00:30:17,039 --> 00:30:20,799
what is my human raw theorem

714
00:30:21,200 --> 00:30:24,880
the theorem describes

715
00:30:24,080 --> 00:30:27,200
let

716
00:30:24,880 --> 00:30:28,320
l be a language

717
00:30:27,200 --> 00:30:31,640
okay

718
00:30:28,320 --> 00:30:31,640
any language

719
00:30:36,799 --> 00:30:41,039
and x be a set of strings

720
00:30:42,240 --> 00:30:46,240
we said that

721
00:30:44,240 --> 00:30:47,039
x

722
00:30:46,240 --> 00:30:51,360
is

723
00:30:47,039 --> 00:30:55,200
pairwise distinguishable by l

724
00:30:51,360 --> 00:30:58,559
if every two distinct strings in s

725
00:30:55,200 --> 00:31:02,159
are distinguishable by l

726
00:30:58,559 --> 00:31:04,720
okay so that's why we explain that i

727
00:31:02,159 --> 00:31:06,880
want to have a group of people

728
00:31:04,720 --> 00:31:10,000
and

729
00:31:06,880 --> 00:31:10,000
any two of them

730
00:31:10,320 --> 00:31:13,519
are not equivalent

731
00:31:12,640 --> 00:31:15,440
okay

732
00:31:13,519 --> 00:31:17,360
so here

733
00:31:15,440 --> 00:31:20,480
you have a language l

734
00:31:17,360 --> 00:31:24,240
which is used as

735
00:31:20,480 --> 00:31:27,200
the judging criteria of two strings to

736
00:31:24,240 --> 00:31:30,159
be distinguishable or not

737
00:31:27,200 --> 00:31:32,960
and you want to have a

738
00:31:30,159 --> 00:31:35,360
string set of string that's called x

739
00:31:32,960 --> 00:31:36,559
and within x

740
00:31:35,360 --> 00:31:39,519
every

741
00:31:36,559 --> 00:31:40,720
any pair for example this one and this

742
00:31:39,519 --> 00:31:44,320
one

743
00:31:40,720 --> 00:31:46,720
are distinguishable and also this one

744
00:31:44,320 --> 00:31:48,159
and this one are distinguishable by all

745
00:31:46,720 --> 00:31:50,080
this one and this one are

746
00:31:48,159 --> 00:31:52,720
distinguishable by l

747
00:31:50,080 --> 00:31:55,519
we call such

748
00:31:52,720 --> 00:31:57,760
pairwise distinguishable by all

749
00:31:55,519 --> 00:31:59,679
the set x

750
00:31:57,760 --> 00:32:01,600
okay

751
00:31:59,679 --> 00:32:05,600
then

752
00:32:01,600 --> 00:32:05,600
how large can this x be

753
00:32:05,679 --> 00:32:12,159
okay so we defined the maximum number

754
00:32:09,919 --> 00:32:12,159
of

755
00:32:12,840 --> 00:32:19,679
elements in any set that's that is pair

756
00:32:16,880 --> 00:32:22,399
wise distinguishable by l

757
00:32:19,679 --> 00:32:24,399
the index of l

758
00:32:22,399 --> 00:32:27,399
okay the index of l

759
00:32:24,399 --> 00:32:27,399
and

760
00:32:32,799 --> 00:32:38,240
what uh

761
00:32:34,960 --> 00:32:41,039
let's say the index of f of l may be

762
00:32:38,240 --> 00:32:43,760
finite or infinite

763
00:32:41,039 --> 00:32:47,440
what is the index of l or what is the

764
00:32:43,760 --> 00:32:47,440
maximum number of elements

765
00:32:48,480 --> 00:32:52,880
of x

766
00:32:50,320 --> 00:32:54,720
according to i just described with

767
00:32:52,880 --> 00:32:57,919
people of

768
00:32:54,720 --> 00:32:59,840
classified with blood type of student id

769
00:32:57,919 --> 00:33:03,120
you know that

770
00:32:59,840 --> 00:33:06,640
how many can be in here

771
00:33:03,120 --> 00:33:09,360
actually the number of classes

772
00:33:06,640 --> 00:33:10,480
the number of possible groups

773
00:33:09,360 --> 00:33:12,720
right

774
00:33:10,480 --> 00:33:15,360
so that means if

775
00:33:12,720 --> 00:33:18,720
given a language arrow

776
00:33:15,360 --> 00:33:21,200
and use l as

777
00:33:18,720 --> 00:33:23,679
a judging criteria

778
00:33:21,200 --> 00:33:27,600
use l to define the relation the

779
00:33:23,679 --> 00:33:29,519
equivalent relation we just introduced

780
00:33:27,600 --> 00:33:32,159
it can

781
00:33:29,519 --> 00:33:35,039
such a relation can classify

782
00:33:32,159 --> 00:33:38,880
all possible string strings

783
00:33:35,039 --> 00:33:40,960
into many different

784
00:33:38,880 --> 00:33:44,399
classes

785
00:33:40,960 --> 00:33:47,039
and how many classes

786
00:33:44,399 --> 00:33:47,840
the number of classes will

787
00:33:47,039 --> 00:33:49,760
be

788
00:33:47,840 --> 00:33:51,279
the maximum number

789
00:33:49,760 --> 00:33:52,720
of

790
00:33:51,279 --> 00:33:55,440
x here

791
00:33:52,720 --> 00:33:59,039
the maximum number of

792
00:33:55,440 --> 00:33:59,039
pairwise set here

793
00:34:00,000 --> 00:34:03,200
okay

794
00:34:01,120 --> 00:34:07,519
then

795
00:34:03,200 --> 00:34:10,320
my here on the road theorem describes

796
00:34:07,519 --> 00:34:14,399
l is recognized

797
00:34:10,320 --> 00:34:14,399
by a dfa with k states

798
00:34:15,119 --> 00:34:21,919
if l is recognized

799
00:34:17,839 --> 00:34:24,320
if l is recognized by a dfa with k-state

800
00:34:21,919 --> 00:34:24,320
then

801
00:34:24,480 --> 00:34:30,639
the index of l

802
00:34:27,280 --> 00:34:30,639
is at most k

803
00:34:33,040 --> 00:34:36,000
okay

804
00:34:34,399 --> 00:34:37,280
that means

805
00:34:36,000 --> 00:34:40,560
see

806
00:34:37,280 --> 00:34:42,639
l is recognized by dfa

807
00:34:40,560 --> 00:34:43,440
is our definition for regular language

808
00:34:42,639 --> 00:34:44,240
right

809
00:34:43,440 --> 00:34:45,839
so

810
00:34:44,240 --> 00:34:49,839
the first thing is

811
00:34:45,839 --> 00:34:52,079
if l is a regular language

812
00:34:49,839 --> 00:34:52,079
then

813
00:34:52,159 --> 00:34:54,399
l

814
00:34:54,480 --> 00:35:01,200
has an index at the most some

815
00:34:57,760 --> 00:35:03,599
dfa recognized l

816
00:35:01,200 --> 00:35:06,079
the num the states uh now the number of

817
00:35:03,599 --> 00:35:08,079
the states of that dfa

818
00:35:06,079 --> 00:35:09,760
will be

819
00:35:08,079 --> 00:35:11,680
else index

820
00:35:09,760 --> 00:35:14,320
okay at most

821
00:35:11,680 --> 00:35:17,200
that will be the upper bound of

822
00:35:14,320 --> 00:35:19,839
else index

823
00:35:17,200 --> 00:35:19,839
and second

824
00:35:20,560 --> 00:35:23,920
if

825
00:35:21,359 --> 00:35:25,760
somehow you know that

826
00:35:23,920 --> 00:35:28,480
the index of l

827
00:35:25,760 --> 00:35:30,320
is a finite number let's say

828
00:35:28,480 --> 00:35:32,720
k

829
00:35:30,320 --> 00:35:36,320
then

830
00:35:32,720 --> 00:35:41,280
the language l is recognized

831
00:35:36,320 --> 00:35:41,280
by a dfa with exactly k-state

832
00:35:42,839 --> 00:35:47,599
okay so you see

833
00:35:45,680 --> 00:35:50,960
if you know

834
00:35:47,599 --> 00:35:52,400
the index of l is a finite number

835
00:35:50,960 --> 00:35:55,040
that means

836
00:35:52,400 --> 00:35:57,920
if you use l

837
00:35:55,040 --> 00:35:58,800
to define the equivalent relation and

838
00:35:57,920 --> 00:36:01,359
then

839
00:35:58,800 --> 00:36:04,480
you use such a relation

840
00:36:01,359 --> 00:36:06,720
to classify all possible strings

841
00:36:04,480 --> 00:36:07,760
and you got

842
00:36:06,720 --> 00:36:10,320
finite

843
00:36:07,760 --> 00:36:13,359
groups binary clauses

844
00:36:10,320 --> 00:36:15,040
let's say k classes

845
00:36:13,359 --> 00:36:18,320
so

846
00:36:15,040 --> 00:36:20,880
the x here is at most k you know that

847
00:36:18,320 --> 00:36:23,680
and then you know that

848
00:36:20,880 --> 00:36:26,480
l the language can be recognized by a

849
00:36:23,680 --> 00:36:30,880
dfa with k states

850
00:36:26,480 --> 00:36:33,119
that means l is a regular language

851
00:36:30,880 --> 00:36:33,119
so

852
00:36:33,440 --> 00:36:37,359
with this 2

853
00:36:35,920 --> 00:36:40,720
we know that

854
00:36:37,359 --> 00:36:43,680
l is regular if and only if it has

855
00:36:40,720 --> 00:36:45,520
finite index

856
00:36:43,680 --> 00:36:48,800
okay

857
00:36:45,520 --> 00:36:48,800
l is regular

858
00:36:49,520 --> 00:36:55,280
if and only if it is important

859
00:36:52,880 --> 00:36:57,920
okay it is important

860
00:36:55,280 --> 00:36:58,960
because for pumping nema

861
00:36:57,920 --> 00:37:00,640
we

862
00:36:58,960 --> 00:37:03,200
because pumping nema for regular

863
00:37:00,640 --> 00:37:05,280
languages is only a

864
00:37:03,200 --> 00:37:06,839
necessary condition

865
00:37:05,280 --> 00:37:09,760
it's not

866
00:37:06,839 --> 00:37:13,760
sufficient so we can only use pumping

867
00:37:09,760 --> 00:37:16,320
lemma to prove some language is reg is

868
00:37:13,760 --> 00:37:18,800
not regular you cannot

869
00:37:16,320 --> 00:37:20,720
use paminema to prove a language to be

870
00:37:18,800 --> 00:37:25,040
regular however

871
00:37:20,720 --> 00:37:25,040
my here on the road theorem is an

872
00:37:25,680 --> 00:37:29,200
is a sufficient and the necessary

873
00:37:27,760 --> 00:37:31,839
conditions

874
00:37:29,200 --> 00:37:35,359
so you can use it to

875
00:37:31,839 --> 00:37:36,720
prove a language to be regular or to be

876
00:37:35,359 --> 00:37:40,240
non-regular

877
00:37:36,720 --> 00:37:40,240
you can use it both ways

878
00:37:40,640 --> 00:37:45,599
then how to use

879
00:37:42,960 --> 00:37:46,480
how to use my healing role to do the

880
00:37:45,599 --> 00:37:47,920
proof

881
00:37:46,480 --> 00:37:51,760
see

882
00:37:47,920 --> 00:37:55,280
the language here is used to

883
00:37:51,760 --> 00:37:57,520
define the equivalent relation

884
00:37:55,280 --> 00:37:59,440
so you if you want to prove some

885
00:37:57,520 --> 00:38:01,359
language

886
00:37:59,440 --> 00:38:03,440
to be regular

887
00:38:01,359 --> 00:38:05,359
you can do that by

888
00:38:03,440 --> 00:38:08,000
using that language

889
00:38:05,359 --> 00:38:10,160
to define an equivalent relation and

890
00:38:08,000 --> 00:38:12,640
and find that

891
00:38:10,160 --> 00:38:15,119
that equivalent relation

892
00:38:12,640 --> 00:38:17,920
can only

893
00:38:15,119 --> 00:38:20,160
classify all possible strings into

894
00:38:17,920 --> 00:38:21,680
finite number

895
00:38:20,160 --> 00:38:24,400
of classes

896
00:38:21,680 --> 00:38:25,599
then that language

897
00:38:24,400 --> 00:38:26,960
is regular

898
00:38:25,599 --> 00:38:29,280
otherwise

899
00:38:26,960 --> 00:38:31,280
if you have a language and you use that

900
00:38:29,280 --> 00:38:33,760
language to

901
00:38:31,280 --> 00:38:36,320
classify all possible strings and you'll

902
00:38:33,760 --> 00:38:38,079
find that you have to classify all

903
00:38:36,320 --> 00:38:39,280
possible strings

904
00:38:38,079 --> 00:38:40,880
into

905
00:38:39,280 --> 00:38:41,839
infinite

906
00:38:40,880 --> 00:38:43,359
groups

907
00:38:41,839 --> 00:38:44,400
into infinite

908
00:38:43,359 --> 00:38:47,280
clauses

909
00:38:44,400 --> 00:38:51,119
then that language

910
00:38:47,280 --> 00:38:53,119
is not a regular language

911
00:38:51,119 --> 00:38:55,280
okay

912
00:38:53,119 --> 00:38:59,440
so

913
00:38:55,280 --> 00:39:03,040
the proof of my human raw theorem is on

914
00:38:59,440 --> 00:39:03,040
textbook page 19.

915
00:39:03,200 --> 00:39:08,000
okay

916
00:39:04,320 --> 00:39:10,240
the prop problem 1.48 page 19

917
00:39:08,000 --> 00:39:10,240
and

918
00:39:10,560 --> 00:39:17,119
facebook actually has

919
00:39:12,640 --> 00:39:20,000
provides the proof to the theorem on 98

920
00:39:17,119 --> 00:39:22,800
so we don't want to go through that but

921
00:39:20,000 --> 00:39:22,800
uh it's

922
00:39:23,280 --> 00:39:28,480
it's not that complicated it just you

923
00:39:26,079 --> 00:39:30,960
can think of the

924
00:39:28,480 --> 00:39:32,480
dfo of dfa operation

925
00:39:30,960 --> 00:39:36,160
you see that

926
00:39:32,480 --> 00:39:37,040
for dfa for language l

927
00:39:36,160 --> 00:39:38,079
if

928
00:39:37,040 --> 00:39:41,520
okay

929
00:39:38,079 --> 00:39:43,839
if it is regular then by our definition

930
00:39:41,520 --> 00:39:47,040
there is a dfa

931
00:39:43,839 --> 00:39:49,359
recognizing l right

932
00:39:47,040 --> 00:39:49,359
then

933
00:39:49,440 --> 00:39:54,800
dfa has finite

934
00:39:52,480 --> 00:39:57,520
states right

935
00:39:54,800 --> 00:40:00,320
star state and sum

936
00:39:57,520 --> 00:40:00,320
accept states

937
00:40:00,640 --> 00:40:04,800
and imagine that for all possible

938
00:40:02,880 --> 00:40:06,480
strings

939
00:40:04,800 --> 00:40:08,839
in sigma star

940
00:40:06,480 --> 00:40:13,680
when you process the

941
00:40:08,839 --> 00:40:15,760
string after every symbol is processed

942
00:40:13,680 --> 00:40:17,839
the machine

943
00:40:15,760 --> 00:40:20,880
will stop

944
00:40:17,839 --> 00:40:23,599
on some states right for example stops

945
00:40:20,880 --> 00:40:26,079
on this state state one

946
00:40:23,599 --> 00:40:28,560
or stop on state 2

947
00:40:26,079 --> 00:40:29,440
or stop on stage 3

948
00:40:28,560 --> 00:40:32,079
and

949
00:40:29,440 --> 00:40:33,920
or step state 4

950
00:40:32,079 --> 00:40:36,319
etc right

951
00:40:33,920 --> 00:40:36,319
then

952
00:40:36,839 --> 00:40:43,200
connect this situation back to our

953
00:40:40,400 --> 00:40:46,000
definition of the equivalent relation

954
00:40:43,200 --> 00:40:48,000
here you will find that

955
00:40:46,000 --> 00:40:50,800
after

956
00:40:48,000 --> 00:40:50,800
stop at

957
00:40:51,520 --> 00:40:56,480
and exception accepts

958
00:40:53,520 --> 00:40:57,440
acceptance straight state

959
00:40:56,480 --> 00:40:59,440
then

960
00:40:57,440 --> 00:41:02,720
if you process x

961
00:40:59,440 --> 00:41:04,839
it stop on this state and the process y

962
00:41:02,720 --> 00:41:09,920
stop on this state

963
00:41:04,839 --> 00:41:14,000
and start again from this state

964
00:41:09,920 --> 00:41:16,960
since x and y reach the same state

965
00:41:14,000 --> 00:41:18,880
no matter what

966
00:41:16,960 --> 00:41:21,599
string you go

967
00:41:18,880 --> 00:41:23,440
next they will

968
00:41:21,599 --> 00:41:25,920
always

969
00:41:23,440 --> 00:41:29,200
reach the same state

970
00:41:25,920 --> 00:41:31,920
right if that state is not

971
00:41:29,200 --> 00:41:34,560
an exception accept states then they are

972
00:41:31,920 --> 00:41:36,400
both not in l

973
00:41:34,560 --> 00:41:38,000
they are both out of l

974
00:41:36,400 --> 00:41:41,520
or

975
00:41:38,000 --> 00:41:44,000
that state is n accept states

976
00:41:41,520 --> 00:41:46,160
then they both are in l

977
00:41:44,000 --> 00:41:46,160
so

978
00:41:46,560 --> 00:41:50,640
for language for regular language you

979
00:41:48,880 --> 00:41:52,880
can easily see

980
00:41:50,640 --> 00:41:54,960
how the definition

981
00:41:52,880 --> 00:41:56,960
connects to

982
00:41:54,960 --> 00:42:00,240
the result

983
00:41:56,960 --> 00:42:04,640
anyway here we want to introduce how do

984
00:42:00,240 --> 00:42:06,079
we use this theorem to prove the

985
00:42:04,640 --> 00:42:08,960
language

986
00:42:06,079 --> 00:42:11,760
regular or non-regular

987
00:42:08,960 --> 00:42:14,160
so here is how we use it

988
00:42:11,760 --> 00:42:16,720
given a language b

989
00:42:14,160 --> 00:42:18,880
that's construct at the relation

990
00:42:16,720 --> 00:42:20,960
equivalence relation

991
00:42:18,880 --> 00:42:22,000
here by using b

992
00:42:20,960 --> 00:42:22,960
okay

993
00:42:22,000 --> 00:42:24,560
then

994
00:42:22,960 --> 00:42:26,079
you just prove

995
00:42:24,560 --> 00:42:28,880
b is a

996
00:42:26,079 --> 00:42:33,200
if you prove that

997
00:42:28,880 --> 00:42:34,160
b has a finite index then b is regular

998
00:42:33,200 --> 00:42:37,040
if b

999
00:42:34,160 --> 00:42:42,319
has infinite

1000
00:42:37,040 --> 00:42:42,319
index then b is not a regular language

1001
00:42:42,960 --> 00:42:45,839
okay

1002
00:42:52,720 --> 00:42:58,560
let's go for an example of

1003
00:42:56,000 --> 00:43:01,040
of the one we are proved by using

1004
00:42:58,560 --> 00:43:02,720
palmileima for regular language

1005
00:43:01,040 --> 00:43:04,880
that is

1006
00:43:02,720 --> 00:43:04,880
b

1007
00:43:05,599 --> 00:43:09,280
0 and

1008
00:43:07,440 --> 00:43:11,599
1 n

1009
00:43:09,280 --> 00:43:11,890
right

1010
00:43:11,599 --> 00:43:13,920
and

1011
00:43:11,890 --> 00:43:16,240
[Music]

1012
00:43:13,920 --> 00:43:16,240
okay

1013
00:43:16,960 --> 00:43:21,119
because this language is our target

1014
00:43:21,359 --> 00:43:26,160
so we

1015
00:43:23,119 --> 00:43:28,400
use this language to define the

1016
00:43:26,160 --> 00:43:30,079
equivalence relation

1017
00:43:28,400 --> 00:43:33,760
okay

1018
00:43:30,079 --> 00:43:36,720
then the next step is we want to use

1019
00:43:33,760 --> 00:43:39,200
this equivalence relation

1020
00:43:36,720 --> 00:43:41,599
to check

1021
00:43:39,200 --> 00:43:43,119
all possible

1022
00:43:41,599 --> 00:43:47,359
strings

1023
00:43:43,119 --> 00:43:47,359
okay to check all possible string

1024
00:43:47,920 --> 00:43:52,880
but all possible strings are you know

1025
00:43:50,880 --> 00:43:55,280
slightly difficult

1026
00:43:52,880 --> 00:43:56,800
to discuss as a whole

1027
00:43:55,280 --> 00:43:59,520
so

1028
00:43:56,800 --> 00:44:00,400
the idea is

1029
00:43:59,520 --> 00:44:02,960
we

1030
00:44:00,400 --> 00:44:04,319
select a subset

1031
00:44:02,960 --> 00:44:08,640
a subset

1032
00:44:04,319 --> 00:44:09,599
from all possible strings

1033
00:44:08,640 --> 00:44:11,520
okay

1034
00:44:09,599 --> 00:44:12,560
and the idea is that

1035
00:44:11,520 --> 00:44:14,640
if

1036
00:44:12,560 --> 00:44:17,440
if the subset

1037
00:44:14,640 --> 00:44:20,560
of all possible strings

1038
00:44:17,440 --> 00:44:20,560
has already

1039
00:44:20,839 --> 00:44:28,000
classified into infinite numbers

1040
00:44:24,800 --> 00:44:29,680
infinite number of classes

1041
00:44:28,000 --> 00:44:32,160
then of course

1042
00:44:29,680 --> 00:44:35,200
the whole

1043
00:44:32,160 --> 00:44:39,440
sigma star has to be classified

1044
00:44:35,200 --> 00:44:41,119
into infinite clauses then b

1045
00:44:39,440 --> 00:44:44,160
has

1046
00:44:41,119 --> 00:44:46,640
an infinite an infinite index

1047
00:44:44,160 --> 00:44:50,800
right that's our goal

1048
00:44:46,640 --> 00:44:52,960
so which subset we should choose

1049
00:44:50,800 --> 00:44:55,599
let's say we choose

1050
00:44:52,960 --> 00:44:58,000
a subset

1051
00:44:55,599 --> 00:44:58,000
0

1052
00:44:58,480 --> 00:45:04,119
and

1053
00:44:59,599 --> 00:45:04,119
let's do it this way okay

1054
00:45:05,599 --> 00:45:09,280
we choose this subset

1055
00:45:10,160 --> 00:45:14,720
out of sigma star

1056
00:45:12,319 --> 00:45:16,160
okay again why do we want to choose this

1057
00:45:14,720 --> 00:45:18,720
subset

1058
00:45:16,160 --> 00:45:22,880
we choose this subset to discuss how

1059
00:45:18,720 --> 00:45:22,880
many class cars classes

1060
00:45:23,359 --> 00:45:26,319
whale

1061
00:45:25,200 --> 00:45:28,480
this

1062
00:45:26,319 --> 00:45:30,240
equivalence relation

1063
00:45:28,480 --> 00:45:31,440
generate

1064
00:45:30,240 --> 00:45:33,119
okay

1065
00:45:31,440 --> 00:45:36,000
if

1066
00:45:33,119 --> 00:45:37,760
using b as the definition for

1067
00:45:36,000 --> 00:45:38,560
equivalence relation

1068
00:45:37,760 --> 00:45:42,960
has

1069
00:45:38,560 --> 00:45:44,079
to classify the subset into infinite

1070
00:45:42,960 --> 00:45:44,960
classes

1071
00:45:44,079 --> 00:45:49,040
then

1072
00:45:44,960 --> 00:45:49,040
that equivalence relation must

1073
00:45:49,440 --> 00:45:53,119
class

1074
00:45:50,560 --> 00:45:55,119
classify the whole sigma star into

1075
00:45:53,119 --> 00:45:57,680
infinite classes

1076
00:45:55,119 --> 00:46:00,640
it doesn't make sense to

1077
00:45:57,680 --> 00:46:02,560
have fewer classes right it must be

1078
00:46:00,640 --> 00:46:04,960
greater than or equal to the number of

1079
00:46:02,560 --> 00:46:05,839
classes

1080
00:46:04,960 --> 00:46:07,520
okay

1081
00:46:05,839 --> 00:46:10,640
so

1082
00:46:07,520 --> 00:46:12,240
how do we discuss how many how many

1083
00:46:10,640 --> 00:46:15,520
classes we need

1084
00:46:12,240 --> 00:46:18,079
by using the equivalence relation

1085
00:46:15,520 --> 00:46:20,160
well in this case kind of tricky

1086
00:46:18,079 --> 00:46:21,839
consider that

1087
00:46:20,160 --> 00:46:25,440
we pick

1088
00:46:21,839 --> 00:46:25,440
any two different

1089
00:46:25,760 --> 00:46:29,839
strings

1090
00:46:26,880 --> 00:46:29,839
from

1091
00:46:31,680 --> 00:46:35,280
from this class

1092
00:46:33,280 --> 00:46:37,119
but sorry from this

1093
00:46:35,280 --> 00:46:40,000
from this

1094
00:46:37,119 --> 00:46:41,760
subset of all possible strings

1095
00:46:40,000 --> 00:46:44,720
okay

1096
00:46:41,760 --> 00:46:46,960
first one is i zeros and the second one

1097
00:46:44,720 --> 00:46:47,920
is j zeros and

1098
00:46:46,960 --> 00:46:51,119
i

1099
00:46:47,920 --> 00:46:51,119
is not equal to j

1100
00:46:51,599 --> 00:46:57,839
okay so in this case let's say x

1101
00:46:55,119 --> 00:46:57,839
and y

1102
00:46:58,079 --> 00:47:04,000
okay

1103
00:46:59,760 --> 00:47:04,000
then we need to try all possible z's

1104
00:47:04,160 --> 00:47:08,640
to see if they

1105
00:47:05,920 --> 00:47:11,839
if the resultant strings

1106
00:47:08,640 --> 00:47:14,160
are both in l or out of l or you know

1107
00:47:11,839 --> 00:47:16,079
one of one in l the other is not

1108
00:47:14,160 --> 00:47:19,280
something like that

1109
00:47:16,079 --> 00:47:20,960
and you will easily find that

1110
00:47:19,280 --> 00:47:22,400
there exists

1111
00:47:20,960 --> 00:47:23,200
a string

1112
00:47:22,400 --> 00:47:25,680
z

1113
00:47:23,200 --> 00:47:28,480
actually two z's in this case actually

1114
00:47:25,680 --> 00:47:30,319
two but let's say

1115
00:47:28,480 --> 00:47:33,359
when z is

1116
00:47:30,319 --> 00:47:33,359
one i

1117
00:47:34,079 --> 00:47:37,680
okay

1118
00:47:35,680 --> 00:47:39,680
i once actually

1119
00:47:37,680 --> 00:47:41,359
x what is xz

1120
00:47:39,680 --> 00:47:42,480
xz

1121
00:47:41,359 --> 00:47:43,839
will be

1122
00:47:42,480 --> 00:47:45,680
0i

1123
00:47:43,839 --> 00:47:47,680
1i

1124
00:47:45,680 --> 00:47:49,040
which is

1125
00:47:47,680 --> 00:47:51,200
in

1126
00:47:49,040 --> 00:47:51,200
b

1127
00:47:51,359 --> 00:47:57,280
and y z

1128
00:47:54,400 --> 00:48:00,240
is what is the row j

1129
00:47:57,280 --> 00:48:02,160
one i which is not

1130
00:48:00,240 --> 00:48:03,440
in b

1131
00:48:02,160 --> 00:48:05,599
right

1132
00:48:03,440 --> 00:48:06,960
so the other z will be

1133
00:48:05,599 --> 00:48:09,200
j once

1134
00:48:06,960 --> 00:48:12,559
right that will make

1135
00:48:09,200 --> 00:48:14,000
x z not in b and y z in b

1136
00:48:12,559 --> 00:48:17,680
okay

1137
00:48:14,000 --> 00:48:18,839
by our definition we know that

1138
00:48:17,680 --> 00:48:21,760
zero

1139
00:48:18,839 --> 00:48:23,440
i r

1140
00:48:21,760 --> 00:48:26,880
and the uh

1141
00:48:23,440 --> 00:48:28,800
zero j are in the are distinguishable by

1142
00:48:26,880 --> 00:48:31,920
b

1143
00:48:28,800 --> 00:48:33,040
so they are

1144
00:48:31,920 --> 00:48:36,480
what

1145
00:48:33,040 --> 00:48:37,359
they are they are distinguishable by p

1146
00:48:36,480 --> 00:48:42,079
and

1147
00:48:37,359 --> 00:48:46,640
you can easily find out any different

1148
00:48:42,079 --> 00:48:49,920
any different strings in this set

1149
00:48:46,640 --> 00:48:51,200
any different strings in this set

1150
00:48:49,920 --> 00:48:54,800
are

1151
00:48:51,200 --> 00:48:54,800
distinguishable by b

1152
00:48:55,119 --> 00:48:58,240
right

1153
00:48:56,720 --> 00:49:00,800
so

1154
00:48:58,240 --> 00:49:03,680
let's name it x

1155
00:49:00,800 --> 00:49:04,480
big x okay capital x

1156
00:49:03,680 --> 00:49:05,599
so

1157
00:49:04,480 --> 00:49:06,960
x here

1158
00:49:05,599 --> 00:49:10,319
is really

1159
00:49:06,960 --> 00:49:13,359
a pairwise distinguishable

1160
00:49:10,319 --> 00:49:17,760
uh it's really a set of string

1161
00:49:13,359 --> 00:49:19,760
that is pairwise distinguishable by b

1162
00:49:17,760 --> 00:49:21,359
and how large is x

1163
00:49:19,760 --> 00:49:24,800
here

1164
00:49:21,359 --> 00:49:25,839
actually the cardinality the size of x

1165
00:49:24,800 --> 00:49:27,119
here

1166
00:49:25,839 --> 00:49:30,119
is

1167
00:49:27,119 --> 00:49:30,119
infinite

1168
00:49:30,160 --> 00:49:35,520
right because arbitrary m here

1169
00:49:33,920 --> 00:49:37,200
so

1170
00:49:35,520 --> 00:49:39,359
we know that

1171
00:49:37,200 --> 00:49:40,319
b

1172
00:49:39,359 --> 00:49:42,240
has

1173
00:49:40,319 --> 00:49:44,400
an infinite

1174
00:49:42,240 --> 00:49:45,440
index

1175
00:49:44,400 --> 00:49:46,559
since b

1176
00:49:45,440 --> 00:49:48,240
has

1177
00:49:46,559 --> 00:49:51,119
an infinite index

1178
00:49:48,240 --> 00:49:52,640
we know that b is not

1179
00:49:51,119 --> 00:49:54,960
a regular

1180
00:49:52,640 --> 00:49:57,200
language

1181
00:49:54,960 --> 00:49:57,200
okay

1182
00:49:57,520 --> 00:50:00,880
so

1183
00:49:58,800 --> 00:50:03,280
remember that

1184
00:50:00,880 --> 00:50:06,319
the language we want to prove to be

1185
00:50:03,280 --> 00:50:07,599
regular or not regular

1186
00:50:06,319 --> 00:50:09,760
is

1187
00:50:07,599 --> 00:50:12,720
used to define

1188
00:50:09,760 --> 00:50:14,559
the equivalence relation

1189
00:50:12,720 --> 00:50:17,280
then

1190
00:50:14,559 --> 00:50:21,280
we are discussing

1191
00:50:17,280 --> 00:50:22,960
how many classes can be classified by

1192
00:50:21,280 --> 00:50:26,000
using the

1193
00:50:22,960 --> 00:50:28,880
equivalence equivalence relation defined

1194
00:50:26,000 --> 00:50:32,640
by the given language

1195
00:50:28,880 --> 00:50:33,599
we prove that language to be regular or

1196
00:50:32,640 --> 00:50:36,640
not

1197
00:50:33,599 --> 00:50:36,640
by checking

1198
00:50:37,280 --> 00:50:43,440
the size of the maximum size of the

1199
00:50:40,000 --> 00:50:45,680
pairwise distinguishable

1200
00:50:43,440 --> 00:50:45,680
set

1201
00:50:46,640 --> 00:50:51,839
okay so that's how we use my heel

1202
00:50:49,680 --> 00:50:55,359
the road theorem

1203
00:50:51,839 --> 00:50:57,680
and by using my heel on the road theorem

1204
00:50:55,359 --> 00:50:59,359
we can

1205
00:50:57,680 --> 00:51:01,599
prove some

1206
00:50:59,359 --> 00:51:03,280
language that is not

1207
00:51:01,599 --> 00:51:04,559
that is not

1208
00:51:03,280 --> 00:51:05,599
regular

1209
00:51:04,559 --> 00:51:08,240
while

1210
00:51:05,599 --> 00:51:11,920
we cannot use pumping lemma for regular

1211
00:51:08,240 --> 00:51:12,720
language to disprove it

1212
00:51:11,920 --> 00:51:15,119
for

1213
00:51:12,720 --> 00:51:18,000
an example of this kind of language you

1214
00:51:15,119 --> 00:51:20,880
can check on textbook

1215
00:51:18,000 --> 00:51:24,960
the third edition textbook

1216
00:51:20,880 --> 00:51:26,640
okay p page 19

1217
00:51:24,960 --> 00:51:29,599
sorry page 90

1218
00:51:26,640 --> 00:51:31,680
oh what am i doing

1219
00:51:29,599 --> 00:51:35,880
page 90

1220
00:51:31,680 --> 00:51:35,880
one problem 1.49

1221
00:51:36,880 --> 00:51:42,000
that language

1222
00:51:38,559 --> 00:51:42,000
has pamping leima

1223
00:51:42,319 --> 00:51:49,200
has the properties of pumping lemma for

1224
00:51:46,000 --> 00:51:51,200
regular languages but it's not regular

1225
00:51:49,200 --> 00:51:54,079
and we

1226
00:51:51,200 --> 00:51:54,880
we cannot use pumping lemma to disprove

1227
00:51:54,079 --> 00:51:57,839
it

1228
00:51:54,880 --> 00:51:59,520
while we can use my human raw theorem to

1229
00:51:57,839 --> 00:52:03,160
disprove it

1230
00:51:59,520 --> 00:52:03,160
as regular language

1231
00:52:11,839 --> 00:52:13,920
you

