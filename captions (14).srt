1
00:00:01,040 --> 00:00:05,200
after introducing contextual grammar and

2
00:00:04,000 --> 00:00:07,520
defining

3
00:00:05,200 --> 00:00:08,720
context free languages as those

4
00:00:07,520 --> 00:00:11,440
languages

5
00:00:08,720 --> 00:00:14,160
which can be generated by context

6
00:00:11,440 --> 00:00:14,160
requirements

7
00:00:14,719 --> 00:00:18,320
remember that in chapter one we

8
00:00:16,720 --> 00:00:19,199
introduced

9
00:00:18,320 --> 00:00:22,320
uh

10
00:00:19,199 --> 00:00:25,599
final automata and said that

11
00:00:22,320 --> 00:00:29,039
regular languages are those languages

12
00:00:25,599 --> 00:00:31,439
generate uh recognized by

13
00:00:29,039 --> 00:00:34,320
finite automata and then we

14
00:00:31,439 --> 00:00:36,079
introduced the definition of regular

15
00:00:34,320 --> 00:00:37,520
expressions

16
00:00:36,079 --> 00:00:40,879
trying to

17
00:00:37,520 --> 00:00:44,960
specify more directly specified

18
00:00:40,879 --> 00:00:49,360
languages recognized by dfa

19
00:00:44,960 --> 00:00:51,840
here we want we also want to introduce

20
00:00:49,360 --> 00:00:55,280
uh abstract machines

21
00:00:51,840 --> 00:00:56,840
which is called push down automata or

22
00:00:55,280 --> 00:00:59,840
pda

23
00:00:56,840 --> 00:01:04,000
okay so uh

24
00:00:59,840 --> 00:01:04,000
the formal definition of pdas

25
00:01:04,400 --> 00:01:07,920
is

26
00:01:05,360 --> 00:01:08,720
that a push down automaton

27
00:01:07,920 --> 00:01:10,640
is

28
00:01:08,720 --> 00:01:14,159
a sixth tuple

29
00:01:10,640 --> 00:01:17,280
yes one more then uh finite automata dfa

30
00:01:14,159 --> 00:01:21,680
or nfa one more so which six

31
00:01:17,280 --> 00:01:24,640
so first one is the uh set finite set of

32
00:01:21,680 --> 00:01:29,439
states we also denote

33
00:01:24,640 --> 00:01:31,680
it as q and the second one is

34
00:01:29,439 --> 00:01:31,680
the

35
00:01:32,320 --> 00:01:38,240
input the input alphabet which is also a

36
00:01:35,520 --> 00:01:41,680
finite set of symbols

37
00:01:38,240 --> 00:01:45,680
then the third one is a new component

38
00:01:41,680 --> 00:01:48,640
for our abstract machine which is called

39
00:01:45,680 --> 00:01:50,159
stack alphabet which is also

40
00:01:48,640 --> 00:01:52,799
also a

41
00:01:50,159 --> 00:01:56,240
finite set of symbols

42
00:01:52,799 --> 00:01:59,439
then let's say the fifth one is the

43
00:01:56,240 --> 00:02:02,719
start state which is one of

44
00:01:59,439 --> 00:02:03,759
our states then the final one the sixth

45
00:02:02,719 --> 00:02:06,399
one

46
00:02:03,759 --> 00:02:08,479
is a subset of our set

47
00:02:06,399 --> 00:02:12,640
also the set of

48
00:02:08,479 --> 00:02:12,640
accept states okay so the

49
00:02:12,879 --> 00:02:15,440
the uh

50
00:02:15,599 --> 00:02:20,560
the fourth one is the transition

51
00:02:18,080 --> 00:02:20,560
function

52
00:02:20,840 --> 00:02:27,280
which is basically

53
00:02:25,120 --> 00:02:29,599
the transition function for

54
00:02:27,280 --> 00:02:32,959
non-deterministic final automata

55
00:02:29,599 --> 00:02:36,959
and here we add one more com

56
00:02:32,959 --> 00:02:39,840
argument for that function which is the

57
00:02:36,959 --> 00:02:41,360
stack alphabet

58
00:02:39,840 --> 00:02:44,400
and also

59
00:02:41,360 --> 00:02:45,680
probably epsilon string

60
00:02:44,400 --> 00:02:48,840
empty string

61
00:02:45,680 --> 00:02:52,080
mapped to the power set

62
00:02:48,840 --> 00:02:53,040
of q

63
00:02:52,080 --> 00:02:55,599
and

64
00:02:53,040 --> 00:02:57,440
stack alphabet we use the transition

65
00:02:55,599 --> 00:02:59,519
function to

66
00:02:57,440 --> 00:03:01,599
do the

67
00:02:59,519 --> 00:03:05,200
state transition

68
00:03:01,599 --> 00:03:06,959
according to what according to input

69
00:03:05,200 --> 00:03:09,360
and also

70
00:03:06,959 --> 00:03:10,400
symbol on the stack

71
00:03:09,360 --> 00:03:12,080
and

72
00:03:10,400 --> 00:03:15,200
transit to

73
00:03:12,080 --> 00:03:18,480
some state with

74
00:03:15,200 --> 00:03:20,159
doing operations on

75
00:03:18,480 --> 00:03:21,360
the stack

76
00:03:20,159 --> 00:03:22,800
and

77
00:03:21,360 --> 00:03:24,080
pdas

78
00:03:22,800 --> 00:03:26,680
are

79
00:03:24,080 --> 00:03:29,840
fundamentally

80
00:03:26,680 --> 00:03:32,879
non-deterministic computational models

81
00:03:29,840 --> 00:03:36,000
so we map to a power set of all part

82
00:03:32,879 --> 00:03:38,480
actually we map to all possible uh next

83
00:03:36,000 --> 00:03:40,720
moves and you can

84
00:03:38,480 --> 00:03:43,519
chose you can choose the

85
00:03:40,720 --> 00:03:44,840
combinations you want in here

86
00:03:43,519 --> 00:03:48,560
so that's why

87
00:03:44,840 --> 00:03:51,599
powerset is used here

88
00:03:48,560 --> 00:03:56,400
okay so let's see an example and let's

89
00:03:51,599 --> 00:03:56,400
talk about how pdas operate

90
00:03:58,720 --> 00:04:04,239
so here is an example

91
00:04:01,120 --> 00:04:04,239
of a pda

92
00:04:04,319 --> 00:04:09,040
let's formally describe it first

93
00:04:07,120 --> 00:04:11,760
so

94
00:04:09,040 --> 00:04:13,360
there are four states

95
00:04:11,760 --> 00:04:14,640
for this pda

96
00:04:13,360 --> 00:04:17,840
and

97
00:04:14,640 --> 00:04:22,240
the input alphabet is 0 1

98
00:04:17,840 --> 00:04:23,280
the stack alphabet is 0 and dollar sign

99
00:04:22,240 --> 00:04:27,440
okay

100
00:04:23,280 --> 00:04:29,520
and the final accept accept states are

101
00:04:27,440 --> 00:04:32,560
q1 and q4

102
00:04:29,520 --> 00:04:34,720
okay so there'll be four components

103
00:04:32,560 --> 00:04:36,560
already

104
00:04:34,720 --> 00:04:38,080
and the q1

105
00:04:36,560 --> 00:04:39,440
here is our

106
00:04:38,080 --> 00:04:42,960
star state

107
00:04:39,440 --> 00:04:44,080
then transition function here is given

108
00:04:42,960 --> 00:04:45,440
by

109
00:04:44,080 --> 00:04:48,720
the

110
00:04:45,440 --> 00:04:50,800
table here and

111
00:04:48,720 --> 00:04:53,040
blank entries

112
00:04:50,800 --> 00:04:54,880
are all empty sets

113
00:04:53,040 --> 00:04:57,520
that means going to

114
00:04:54,880 --> 00:04:59,600
nowhere so let's say there's a

115
00:04:57,520 --> 00:05:04,080
transition

116
00:04:59,600 --> 00:05:07,440
when the machine is at q2 and the input

117
00:05:04,080 --> 00:05:09,120
the input symbol is zero

118
00:05:07,440 --> 00:05:10,400
then there is an

119
00:05:09,120 --> 00:05:14,400
epstrom

120
00:05:10,400 --> 00:05:15,600
for stake symbol two here

121
00:05:14,400 --> 00:05:18,080
okay

122
00:05:15,600 --> 00:05:20,560
so that's remember that our delta

123
00:05:18,080 --> 00:05:23,759
function the type of our delta function

124
00:05:20,560 --> 00:05:25,199
function is q

125
00:05:23,759 --> 00:05:28,880
product with

126
00:05:25,199 --> 00:05:30,080
sigma epsilon and also stack symbol

127
00:05:28,880 --> 00:05:31,120
epsilon

128
00:05:30,080 --> 00:05:32,000
okay

129
00:05:31,120 --> 00:05:35,600
so

130
00:05:32,000 --> 00:05:37,440
uh this entry is q2

131
00:05:35,600 --> 00:05:39,840
0

132
00:05:37,440 --> 00:05:39,840
epsilon

133
00:05:39,919 --> 00:05:44,000
which map to the power set of

134
00:05:43,039 --> 00:05:46,880
q

135
00:05:44,000 --> 00:05:49,199
and sigma epsilon okay

136
00:05:46,880 --> 00:05:50,960
so that will be

137
00:05:49,199 --> 00:05:53,680
q 2

138
00:05:50,960 --> 00:05:58,400
0 something like this

139
00:05:53,680 --> 00:05:58,400
okay so there are five transitions for

140
00:05:58,639 --> 00:06:05,280
the transition function

141
00:06:01,039 --> 00:06:05,280
and you know that for any other

142
00:06:05,360 --> 00:06:07,759
entries

143
00:06:06,560 --> 00:06:09,199
that would be

144
00:06:07,759 --> 00:06:12,160
empties

145
00:06:09,199 --> 00:06:15,199
empty set empty set empty set empty set

146
00:06:12,160 --> 00:06:16,800
empty set stuff like that okay

147
00:06:15,199 --> 00:06:18,319
and when we

148
00:06:16,800 --> 00:06:19,199
visualize

149
00:06:18,319 --> 00:06:23,199
this

150
00:06:19,199 --> 00:06:23,199
pda which is m1 here

151
00:06:23,840 --> 00:06:30,319
we can have the diagram as figure 2 15.

152
00:06:28,639 --> 00:06:34,160
so the m1

153
00:06:30,319 --> 00:06:34,880
m1 diagram can be draw can be drawn as

154
00:06:34,160 --> 00:06:37,840
the

155
00:06:34,880 --> 00:06:40,080
the machine on the upper part

156
00:06:37,840 --> 00:06:40,080
so

157
00:06:40,720 --> 00:06:43,199
we have

158
00:06:45,280 --> 00:06:48,639
machines here so how this machine

159
00:06:47,600 --> 00:06:49,599
operate

160
00:06:48,639 --> 00:06:51,919
let's

161
00:06:49,599 --> 00:06:54,160
give an example okay

162
00:06:51,919 --> 00:06:56,800
so you see if you have

163
00:06:54,160 --> 00:06:56,800
a string

164
00:07:00,560 --> 00:07:04,800
if you have a string

165
00:07:03,039 --> 00:07:06,400
0 0

166
00:07:04,800 --> 00:07:08,880
0

167
00:07:06,400 --> 00:07:10,319
1 1 1

168
00:07:08,880 --> 00:07:12,880
okay

169
00:07:10,319 --> 00:07:14,080
and for this string

170
00:07:12,880 --> 00:07:17,680
we start

171
00:07:14,080 --> 00:07:18,639
from q1 right because q1 is our start

172
00:07:17,680 --> 00:07:22,479
state

173
00:07:18,639 --> 00:07:23,360
and we start from q1 so if your string

174
00:07:22,479 --> 00:07:25,039
is

175
00:07:23,360 --> 00:07:29,360
empty string let's

176
00:07:25,039 --> 00:07:32,800
give a quick example here empty string

177
00:07:29,360 --> 00:07:35,360
it is already accepted at q1 right

178
00:07:32,800 --> 00:07:38,479
because string is empty and the q1 is

179
00:07:35,360 --> 00:07:40,400
accept state and when your input string

180
00:07:38,479 --> 00:07:43,360
is emptied

181
00:07:40,400 --> 00:07:44,800
and you stopped at

182
00:07:43,360 --> 00:07:48,000
stays at

183
00:07:44,800 --> 00:07:50,639
one of the one of the accept states then

184
00:07:48,000 --> 00:07:52,000
the machine accepts that's that string

185
00:07:50,639 --> 00:07:54,080
right so

186
00:07:52,000 --> 00:07:58,319
empty string okay

187
00:07:54,080 --> 00:08:01,039
okay then let's say zero zero one one

188
00:07:58,319 --> 00:08:04,319
and remember that it is an

189
00:08:01,039 --> 00:08:07,120
uh non-deterministic machine so

190
00:08:04,319 --> 00:08:08,960
there is a app there is a

191
00:08:07,120 --> 00:08:12,560
abstract arrow here

192
00:08:08,960 --> 00:08:15,440
but for pds you need to match

193
00:08:12,560 --> 00:08:16,160
symbols on the stack too

194
00:08:15,440 --> 00:08:17,039
so

195
00:08:16,160 --> 00:08:21,360
you

196
00:08:17,039 --> 00:08:24,240
imagine that there is a stack here okay

197
00:08:21,360 --> 00:08:26,240
and initially it's empty

198
00:08:24,240 --> 00:08:29,520
so

199
00:08:26,240 --> 00:08:32,320
we are lucky that there is an also empty

200
00:08:29,520 --> 00:08:34,240
string here so the empty string here

201
00:08:32,320 --> 00:08:36,800
means that

202
00:08:34,240 --> 00:08:39,760
you don't need to check

203
00:08:36,800 --> 00:08:42,240
or you don't need to pop a symbol

204
00:08:39,760 --> 00:08:43,200
the corresponding symbol on the stack

205
00:08:42,240 --> 00:08:44,959
okay

206
00:08:43,200 --> 00:08:46,240
so

207
00:08:44,959 --> 00:08:49,839
because

208
00:08:46,240 --> 00:08:53,600
the criteria are matched so we can go

209
00:08:49,839 --> 00:08:55,600
this way okay we can do this transition

210
00:08:53,600 --> 00:08:56,880
and when we do this transition

211
00:08:55,600 --> 00:08:58,000
transition

212
00:08:56,880 --> 00:09:00,720
the machine

213
00:08:58,000 --> 00:09:03,200
starts at q1 right then when we do this

214
00:09:00,720 --> 00:09:04,800
transition the machine goes to

215
00:09:03,200 --> 00:09:07,600
q2

216
00:09:04,800 --> 00:09:10,240
and in the process

217
00:09:07,600 --> 00:09:10,240
epsilon

218
00:09:10,320 --> 00:09:14,800
is consumed so nothing happened to the

219
00:09:13,279 --> 00:09:16,959
input string

220
00:09:14,800 --> 00:09:18,160
and

221
00:09:16,959 --> 00:09:20,399
epsilon

222
00:09:18,160 --> 00:09:21,279
this apps on the second epsilon from

223
00:09:20,399 --> 00:09:23,200
stack

224
00:09:21,279 --> 00:09:24,640
is popped

225
00:09:23,200 --> 00:09:26,959
or removed

226
00:09:24,640 --> 00:09:30,240
but it's empty string so

227
00:09:26,959 --> 00:09:31,440
stack is unaffected right

228
00:09:30,240 --> 00:09:32,880
and

229
00:09:31,440 --> 00:09:34,880
we push

230
00:09:32,880 --> 00:09:38,720
the other side

231
00:09:34,880 --> 00:09:40,080
to the top of the stack

232
00:09:38,720 --> 00:09:41,600
okay

233
00:09:40,080 --> 00:09:43,440
so that'll become

234
00:09:41,600 --> 00:09:44,880
this

235
00:09:43,440 --> 00:09:46,959
situation

236
00:09:44,880 --> 00:09:49,519
then

237
00:09:46,959 --> 00:09:52,640
we are at q2 now with

238
00:09:49,519 --> 00:09:53,440
zero zero one one one okay

239
00:09:52,640 --> 00:09:55,600
and

240
00:09:53,440 --> 00:09:57,360
this machine is non-deterministic

241
00:09:55,600 --> 00:10:01,920
machine so you need to try every

242
00:09:57,360 --> 00:10:04,640
possible uh transitions so let's try

243
00:10:01,920 --> 00:10:05,360
this transition first but

244
00:10:04,640 --> 00:10:07,519
this

245
00:10:05,360 --> 00:10:10,240
transition asks for

246
00:10:07,519 --> 00:10:12,720
one as the input symbol and now we have

247
00:10:10,240 --> 00:10:13,440
first one is zero right it doesn't match

248
00:10:12,720 --> 00:10:15,839
so

249
00:10:13,440 --> 00:10:17,760
we won't go this transition

250
00:10:15,839 --> 00:10:19,279
and for this one

251
00:10:17,760 --> 00:10:20,320
let's try

252
00:10:19,279 --> 00:10:21,360
input

253
00:10:20,320 --> 00:10:24,000
zero

254
00:10:21,360 --> 00:10:24,800
input zero checked

255
00:10:24,000 --> 00:10:27,760
okay

256
00:10:24,800 --> 00:10:33,360
we don't need to check

257
00:10:27,760 --> 00:10:35,600
stack so okay okay then we go

258
00:10:33,360 --> 00:10:36,640
this transition

259
00:10:35,600 --> 00:10:37,839
so

260
00:10:36,640 --> 00:10:39,440
q2

261
00:10:37,839 --> 00:10:40,800
right and

262
00:10:39,440 --> 00:10:43,040
no need

263
00:10:40,800 --> 00:10:46,880
no need to operate on stack i mean uh

264
00:10:43,040 --> 00:10:50,160
push up sorry pop from stack and when we

265
00:10:46,880 --> 00:10:53,839
go this transition we go back to q2 and

266
00:10:50,160 --> 00:10:55,680
push zero into the stack so the stack

267
00:10:53,839 --> 00:10:58,160
will be

268
00:10:55,680 --> 00:10:58,160
zero

269
00:10:58,720 --> 00:11:02,560
okay

270
00:10:59,760 --> 00:11:05,120
so again you can okay we consume this

271
00:11:02,560 --> 00:11:06,720
one again you can see that the same

272
00:11:05,120 --> 00:11:09,120
situation

273
00:11:06,720 --> 00:11:10,720
all over again so

274
00:11:09,120 --> 00:11:11,920
q2

275
00:11:10,720 --> 00:11:12,800
right

276
00:11:11,920 --> 00:11:14,480
and

277
00:11:12,800 --> 00:11:17,680
consume zero

278
00:11:14,480 --> 00:11:19,680
no pop from stack and push

279
00:11:17,680 --> 00:11:20,880
to stack

280
00:11:19,680 --> 00:11:23,760
right

281
00:11:20,880 --> 00:11:23,760
then again

282
00:11:24,640 --> 00:11:30,399
go back to q two

283
00:11:28,480 --> 00:11:32,959
consume zero

284
00:11:30,399 --> 00:11:35,760
push to uh sorry

285
00:11:32,959 --> 00:11:38,079
no pop from the stack and push to the

286
00:11:35,760 --> 00:11:38,079
stack

287
00:11:38,640 --> 00:11:45,440
okay so let's try again but this time we

288
00:11:42,000 --> 00:11:47,040
cannot go we cannot go

289
00:11:45,440 --> 00:11:50,160
follow we cannot follow the same

290
00:11:47,040 --> 00:11:52,560
transition again because this

291
00:11:50,160 --> 00:11:55,680
transition need input symbol to be zero

292
00:11:52,560 --> 00:11:56,959
but now we have one here

293
00:11:55,680 --> 00:11:57,920
right

294
00:11:56,959 --> 00:11:59,600
so

295
00:11:57,920 --> 00:12:02,959
we have one here

296
00:11:59,600 --> 00:12:05,120
okay let's say if your string on our uh

297
00:12:02,959 --> 00:12:08,560
the if the input string is only zero

298
00:12:05,120 --> 00:12:10,079
zero zero in this case the input string

299
00:12:08,560 --> 00:12:14,240
uh

300
00:12:10,079 --> 00:12:14,240
is processed but the machine

301
00:12:14,399 --> 00:12:22,480
stops at q2 so the machine will not

302
00:12:18,079 --> 00:12:24,880
accept string like zero zero zero

303
00:12:22,480 --> 00:12:26,959
zero right so the machine will not

304
00:12:24,880 --> 00:12:29,760
accept string like this

305
00:12:26,959 --> 00:12:31,040
okay let's go back to our zero zero zero

306
00:12:29,760 --> 00:12:33,279
one one

307
00:12:31,040 --> 00:12:33,279
so

308
00:12:33,680 --> 00:12:39,920
now the only way to go is follow this

309
00:12:36,800 --> 00:12:40,720
path right because the input symbol is 1

310
00:12:39,920 --> 00:12:44,320
now

311
00:12:40,720 --> 00:12:45,680
so for input symbol 1 here

312
00:12:44,320 --> 00:12:48,560
see

313
00:12:45,680 --> 00:12:51,440
you need to match that on the top of the

314
00:12:48,560 --> 00:12:53,519
stack it must be 0 if it's not you

315
00:12:51,440 --> 00:12:56,880
cannot go this way

316
00:12:53,519 --> 00:12:59,760
and luckily we have yes zero on the

317
00:12:56,880 --> 00:13:02,560
stack on the top of the stick right so

318
00:12:59,760 --> 00:13:04,560
when we when we go through this

319
00:13:02,560 --> 00:13:07,360
transition

320
00:13:04,560 --> 00:13:10,000
the machine goes to q3

321
00:13:07,360 --> 00:13:15,279
and consume 1

322
00:13:10,000 --> 00:13:18,399
for the input symbol and 0 popped 0

323
00:13:15,279 --> 00:13:22,800
from the stack so that's 0

324
00:13:18,399 --> 00:13:25,600
1 and 0 means okay then we push nothing

325
00:13:22,800 --> 00:13:26,480
on the stack so only pop

326
00:13:25,600 --> 00:13:29,600
okay

327
00:13:26,480 --> 00:13:32,000
so after going through the transition

328
00:13:29,600 --> 00:13:33,040
our stack content will be

329
00:13:32,000 --> 00:13:35,920
zero

330
00:13:33,040 --> 00:13:36,880
zero dollar sign like this

331
00:13:35,920 --> 00:13:39,120
okay

332
00:13:36,880 --> 00:13:40,480
then we are at q3

333
00:13:39,120 --> 00:13:42,160
so

334
00:13:40,480 --> 00:13:43,680
every time

335
00:13:42,160 --> 00:13:46,959
uh

336
00:13:43,680 --> 00:13:48,720
at q3 you have two possible two possible

337
00:13:46,959 --> 00:13:50,560
transitions

338
00:13:48,720 --> 00:13:53,680
one is

339
00:13:50,560 --> 00:13:58,480
going to q4 and the other is go back to

340
00:13:53,680 --> 00:14:00,480
q3 right let's check q4 although for

341
00:13:58,480 --> 00:14:03,600
the transition here you don't need to

342
00:14:00,480 --> 00:14:05,920
care about input string but you need to

343
00:14:03,600 --> 00:14:07,760
match

344
00:14:05,920 --> 00:14:10,320
dollar sign on the stack

345
00:14:07,760 --> 00:14:12,560
and now since we have zero on the stack

346
00:14:10,320 --> 00:14:14,079
on the top of the stack we cannot go

347
00:14:12,560 --> 00:14:18,720
this way right

348
00:14:14,079 --> 00:14:19,600
and let's try the other one so one

349
00:14:18,720 --> 00:14:20,880
yes

350
00:14:19,600 --> 00:14:22,079
that's uh

351
00:14:20,880 --> 00:14:22,880
checked

352
00:14:22,079 --> 00:14:25,600
okay

353
00:14:22,880 --> 00:14:26,480
then zero on the table stack

354
00:14:25,600 --> 00:14:28,480
checked

355
00:14:26,480 --> 00:14:30,800
so we go

356
00:14:28,480 --> 00:14:32,000
this way once

357
00:14:30,800 --> 00:14:33,839
so

358
00:14:32,000 --> 00:14:38,079
q3

359
00:14:33,839 --> 00:14:38,079
okay and comes from this one

360
00:14:39,519 --> 00:14:45,920
pop this one

361
00:14:42,320 --> 00:14:46,959
then same situation happens again

362
00:14:45,920 --> 00:14:48,560
q

363
00:14:46,959 --> 00:14:52,320
3

364
00:14:48,560 --> 00:14:54,720
comes from this one pop this one

365
00:14:52,320 --> 00:14:57,040
then you cannot go

366
00:14:54,720 --> 00:14:59,760
through the same transition again

367
00:14:57,040 --> 00:15:02,639
because now you have no transition

368
00:14:59,760 --> 00:15:04,560
same sorry no you have no input symbols

369
00:15:02,639 --> 00:15:06,399
and

370
00:15:04,560 --> 00:15:07,600
the top of the stack

371
00:15:06,399 --> 00:15:10,800
is not

372
00:15:07,600 --> 00:15:12,800
zero anymore right it's the dollar sign

373
00:15:10,800 --> 00:15:17,279
so let's try

374
00:15:12,800 --> 00:15:21,199
the one we previously cannot go through

375
00:15:17,279 --> 00:15:22,800
it doesn't need input okay

376
00:15:21,199 --> 00:15:26,240
then

377
00:15:22,800 --> 00:15:28,920
stack top is data sign in this case yes

378
00:15:26,240 --> 00:15:30,800
so we go to

379
00:15:28,920 --> 00:15:32,959
q4

380
00:15:30,800 --> 00:15:34,720
okay

381
00:15:32,959 --> 00:15:38,320
then

382
00:15:34,720 --> 00:15:40,320
epsilon so no problem and pop this one

383
00:15:38,320 --> 00:15:43,680
so

384
00:15:40,320 --> 00:15:46,079
no empty uh sorry no input

385
00:15:43,680 --> 00:15:49,120
the input string is empty now and the

386
00:15:46,079 --> 00:15:51,920
machine stops at q4

387
00:15:49,120 --> 00:15:54,399
one of the accept

388
00:15:51,920 --> 00:15:57,839
states so we say that

389
00:15:54,399 --> 00:16:01,600
the machine accepts this string zero

390
00:15:57,839 --> 00:16:03,920
zero zero one one one

391
00:16:01,600 --> 00:16:03,920
okay

392
00:16:05,199 --> 00:16:11,839
so when we have symbols here that is a

393
00:16:09,040 --> 00:16:14,880
pop front stack so you have to match the

394
00:16:11,839 --> 00:16:17,519
same symbol so you can pop that symbol

395
00:16:14,880 --> 00:16:18,720
and if we have a symbol

396
00:16:17,519 --> 00:16:20,160
here

397
00:16:18,720 --> 00:16:21,120
that's a push

398
00:16:20,160 --> 00:16:23,120
to

399
00:16:21,120 --> 00:16:26,399
uh to the stack so you push the

400
00:16:23,120 --> 00:16:28,000
corresponding symbol onto the stack

401
00:16:26,399 --> 00:16:30,160
so via the

402
00:16:28,000 --> 00:16:31,360
operation on the stack

403
00:16:30,160 --> 00:16:33,839
the

404
00:16:31,360 --> 00:16:36,320
size of the stack is assumed to be

405
00:16:33,839 --> 00:16:40,000
infinite okay so you have an input

406
00:16:36,320 --> 00:16:43,360
infinite memory only that it is a

407
00:16:40,000 --> 00:16:46,320
memory with restricted access it can

408
00:16:43,360 --> 00:16:50,560
only do first in less out or you said

409
00:16:46,320 --> 00:16:51,920
less in first out that's level or fifo

410
00:16:50,560 --> 00:16:54,800
le4 or

411
00:16:51,920 --> 00:16:57,440
lifo for stack

412
00:16:54,800 --> 00:16:59,920
and also you can see that this machine

413
00:16:57,440 --> 00:17:03,040
doesn't accept

414
00:16:59,920 --> 00:17:06,559
strings like 0 0 0 0 1 something like

415
00:17:03,040 --> 00:17:10,400
this right and it doesn't accept

416
00:17:06,559 --> 00:17:12,480
let's say 0 0 0 0

417
00:17:10,400 --> 00:17:13,360
and 1 1

418
00:17:12,480 --> 00:17:14,319
and

419
00:17:13,360 --> 00:17:17,120
when

420
00:17:14,319 --> 00:17:17,120
the 1

421
00:17:17,600 --> 00:17:22,559
are fewer than zero

422
00:17:20,000 --> 00:17:22,559
let's say

423
00:17:23,199 --> 00:17:26,079
it will get stuck

424
00:17:25,360 --> 00:17:30,400
at

425
00:17:26,079 --> 00:17:32,720
q3 which is not an accept state right so

426
00:17:30,400 --> 00:17:34,880
the machine will not accept this one the

427
00:17:32,720 --> 00:17:38,400
machine will accept

428
00:17:34,880 --> 00:17:42,080
zero and one n

429
00:17:38,400 --> 00:17:44,000
and larger than or equal to zero okay so

430
00:17:42,080 --> 00:17:46,480
that's like this

431
00:17:44,000 --> 00:17:47,360
or if you have

432
00:17:46,480 --> 00:17:48,720
more

433
00:17:47,360 --> 00:17:50,960
let's say

434
00:17:48,720 --> 00:17:54,720
more one

435
00:17:50,960 --> 00:17:58,000
then you also get stuck at q3 right

436
00:17:54,720 --> 00:18:01,840
because you don't see

437
00:17:58,000 --> 00:18:01,840
the other side on the stack

438
00:18:04,400 --> 00:18:07,360
oh sorry yeah

439
00:18:07,919 --> 00:18:12,679
you if you have

440
00:18:09,280 --> 00:18:12,679
more one

441
00:18:15,120 --> 00:18:18,000
then

442
00:18:16,160 --> 00:18:20,720
zero

443
00:18:18,000 --> 00:18:22,640
you see dollar sign on the stick

444
00:18:20,720 --> 00:18:25,120
yes you see dollar sign stick because

445
00:18:22,640 --> 00:18:26,880
all the zero is popped out and you see

446
00:18:25,120 --> 00:18:29,520
down the side when you see the other

447
00:18:26,880 --> 00:18:32,960
side on a stack you cannot go

448
00:18:29,520 --> 00:18:35,600
this transition again because

449
00:18:32,960 --> 00:18:38,160
you have no zero on a stack

450
00:18:35,600 --> 00:18:40,960
you can go through this transition

451
00:18:38,160 --> 00:18:43,039
arrive q4 yes but

452
00:18:40,960 --> 00:18:44,640
the machine doesn't accept the string

453
00:18:43,039 --> 00:18:46,880
why because

454
00:18:44,640 --> 00:18:46,880
the

455
00:18:47,200 --> 00:18:51,600
criteria to accept the string is that

456
00:18:49,679 --> 00:18:52,799
when you arrive when you

457
00:18:51,600 --> 00:18:55,280
stop at

458
00:18:52,799 --> 00:18:57,600
one of the accept states there must

459
00:18:55,280 --> 00:19:00,320
there is no empty string anymore

460
00:18:57,600 --> 00:19:04,960
but in this case in this case

461
00:19:00,320 --> 00:19:06,400
your string will be n uh sorry 1

462
00:19:04,960 --> 00:19:09,679
u

463
00:19:06,400 --> 00:19:11,679
n minus n once the string looks like

464
00:19:09,679 --> 00:19:15,919
this one so

465
00:19:11,679 --> 00:19:16,799
you still have string but you arrived q4

466
00:19:15,919 --> 00:19:18,320
so

467
00:19:16,799 --> 00:19:21,440
and nothing

468
00:19:18,320 --> 00:19:26,240
no transition out of q4 right no

469
00:19:21,440 --> 00:19:26,240
transition out of q4 so the machine will

470
00:19:27,039 --> 00:19:32,160
get stuck at q4 but not accept that

471
00:19:30,400 --> 00:19:35,760
string

472
00:19:32,160 --> 00:19:39,600
and if you have some string like 0 0

473
00:19:35,760 --> 00:19:41,840
and 1 1 zero one something like that

474
00:19:39,600 --> 00:19:44,000
the same thing happened when you have

475
00:19:41,840 --> 00:19:47,440
you know on the first part of the

476
00:19:44,000 --> 00:19:50,480
mixture of the zero one strings

477
00:19:47,440 --> 00:19:52,559
it will not accept those kind of strings

478
00:19:50,480 --> 00:19:56,320
so

479
00:19:52,559 --> 00:19:57,600
we have m1 recognize

480
00:19:56,320 --> 00:20:00,559
this language

481
00:19:57,600 --> 00:20:03,200
and if you remember that this language

482
00:20:00,559 --> 00:20:04,320
is the first example

483
00:20:03,200 --> 00:20:05,520
not

484
00:20:04,320 --> 00:20:07,840
a regular

485
00:20:05,520 --> 00:20:07,840
language

486
00:20:07,919 --> 00:20:10,240
okay

487
00:20:13,840 --> 00:20:19,280
so if you have no problem with

488
00:20:16,240 --> 00:20:20,960
this example let's go back to

489
00:20:19,280 --> 00:20:23,440
check the form of this

490
00:20:20,960 --> 00:20:26,640
formal definition and the acceptance for

491
00:20:23,440 --> 00:20:29,600
a pda to accept a string

492
00:20:26,640 --> 00:20:32,640
so the formal description is like this

493
00:20:29,600 --> 00:20:34,480
one and if you compare this definition

494
00:20:32,640 --> 00:20:36,480
with all those

495
00:20:34,480 --> 00:20:38,640
definitions we have

496
00:20:36,480 --> 00:20:39,600
for

497
00:20:38,640 --> 00:20:41,520
finite

498
00:20:39,600 --> 00:20:44,240
including deterministic final automata

499
00:20:41,520 --> 00:20:45,280
and non-deterministic final automata you

500
00:20:44,240 --> 00:20:48,240
will see

501
00:20:45,280 --> 00:20:49,039
the similarity between these definitions

502
00:20:48,240 --> 00:20:51,039
and

503
00:20:49,039 --> 00:20:52,640
no more

504
00:20:51,039 --> 00:20:54,320
regarding these

505
00:20:52,640 --> 00:20:56,000
computational models

506
00:20:54,320 --> 00:20:58,720
okay let's

507
00:20:56,000 --> 00:21:00,320
see the formal description here sorry

508
00:20:58,720 --> 00:21:03,760
definition here

509
00:21:00,320 --> 00:21:05,760
so a push down automata is

510
00:21:03,760 --> 00:21:08,640
as hours back

511
00:21:05,760 --> 00:21:11,520
so six tuple

512
00:21:08,640 --> 00:21:12,960
we said of push down automata

513
00:21:11,520 --> 00:21:17,679
accept input

514
00:21:12,960 --> 00:21:19,120
w if w can be returned as

515
00:21:17,679 --> 00:21:22,559
n parts

516
00:21:19,120 --> 00:21:25,120
m parts okay

517
00:21:22,559 --> 00:21:27,440
where each part is

518
00:21:25,120 --> 00:21:29,200
either a symbol or

519
00:21:27,440 --> 00:21:32,080
epsilon

520
00:21:29,200 --> 00:21:34,400
and there is a sequence sequence of

521
00:21:32,080 --> 00:21:39,360
states

522
00:21:34,400 --> 00:21:40,159
r 0 r 1 through r m

523
00:21:39,360 --> 00:21:45,280
and

524
00:21:40,159 --> 00:21:46,400
corresponding strings s 0 s 1 to sn

525
00:21:45,280 --> 00:21:50,000
as

526
00:21:46,400 --> 00:21:51,200
strings compare composed of stack

527
00:21:50,000 --> 00:21:52,720
symbols

528
00:21:51,200 --> 00:21:56,480
exists that

529
00:21:52,720 --> 00:21:59,600
satisfy the following three conditions

530
00:21:56,480 --> 00:22:02,320
the strings s i

531
00:21:59,600 --> 00:22:04,880
represents the sequence of stack

532
00:22:02,320 --> 00:22:04,880
contents

533
00:22:06,960 --> 00:22:09,280
first

534
00:22:09,600 --> 00:22:15,120
the machine starts at starts from its

535
00:22:13,440 --> 00:22:17,520
start state

536
00:22:15,120 --> 00:22:19,440
and initially

537
00:22:17,520 --> 00:22:20,320
the stack contents

538
00:22:19,440 --> 00:22:21,679
are

539
00:22:20,320 --> 00:22:23,760
empty

540
00:22:21,679 --> 00:22:25,600
okay empty string

541
00:22:23,760 --> 00:22:27,039
and finally

542
00:22:25,600 --> 00:22:30,799
the last

543
00:22:27,039 --> 00:22:34,400
the last state here is one of the

544
00:22:30,799 --> 00:22:35,200
one of the accept states okay

545
00:22:34,400 --> 00:22:36,159
and

546
00:22:35,200 --> 00:22:37,919
the

547
00:22:36,159 --> 00:22:41,159
second condition is that

548
00:22:37,919 --> 00:22:41,159
for corresponding

549
00:22:42,000 --> 00:22:46,720
part part of part of the string and the

550
00:22:45,760 --> 00:22:49,120
states

551
00:22:46,720 --> 00:22:51,679
we have

552
00:22:49,120 --> 00:22:53,039
ri

553
00:22:51,679 --> 00:22:54,960
with

554
00:22:53,039 --> 00:22:57,200
w i plus 1

555
00:22:54,960 --> 00:22:57,200
and

556
00:22:58,559 --> 00:23:02,240
at that time

557
00:23:01,039 --> 00:23:06,480
the stick

558
00:23:02,240 --> 00:23:09,360
the top of the top of the stick is a

559
00:23:06,480 --> 00:23:11,360
and when you look at

560
00:23:09,360 --> 00:23:13,520
the transition function here

561
00:23:11,360 --> 00:23:15,280
you look up the entry

562
00:23:13,520 --> 00:23:17,200
you will find that

563
00:23:15,280 --> 00:23:19,039
next state

564
00:23:17,200 --> 00:23:20,320
and b

565
00:23:19,039 --> 00:23:22,640
which is

566
00:23:20,320 --> 00:23:25,200
the next

567
00:23:22,640 --> 00:23:30,320
state content

568
00:23:25,200 --> 00:23:30,320
are connected through the whole process

569
00:23:30,720 --> 00:23:34,080
okay

570
00:23:32,320 --> 00:23:38,080
so that is the

571
00:23:34,080 --> 00:23:39,760
definition for a pda to accept

572
00:23:38,080 --> 00:23:41,919
a string

573
00:23:39,760 --> 00:23:43,520
and let's go back to our example to

574
00:23:41,919 --> 00:23:45,760
check that okay

575
00:23:43,520 --> 00:23:45,760
so

576
00:23:46,640 --> 00:23:52,240
we said that this machine accept zero

577
00:23:49,760 --> 00:23:54,880
zero zero one one one

578
00:23:52,240 --> 00:23:58,159
not because what we just described

579
00:23:54,880 --> 00:24:00,240
informally it is because

580
00:23:58,159 --> 00:24:02,159
it satisfies

581
00:24:00,240 --> 00:24:03,039
the definition

582
00:24:02,159 --> 00:24:06,559
okay

583
00:24:03,039 --> 00:24:06,559
we say that this machine

584
00:24:13,919 --> 00:24:18,520
we say that this machine accepts

585
00:24:19,919 --> 00:24:24,159
accept zero zero one one because

586
00:24:25,760 --> 00:24:33,039
zero uh zero zero zero one one one

587
00:24:30,159 --> 00:24:34,960
can be set uh can be

588
00:24:33,039 --> 00:24:36,960
written as

589
00:24:34,960 --> 00:24:41,679
epsilon

590
00:24:36,960 --> 00:24:44,880
zero zero zero one one one epsilon

591
00:24:41,679 --> 00:24:47,200
okay so that would be w one

592
00:24:44,880 --> 00:24:49,520
w 2

593
00:24:47,200 --> 00:24:50,559
3 4 5 6 7

594
00:24:49,520 --> 00:24:52,880
8

595
00:24:50,559 --> 00:24:53,840
w 8

596
00:24:52,880 --> 00:24:56,000
okay

597
00:24:53,840 --> 00:24:57,919
and we have

598
00:24:56,000 --> 00:25:00,720
r 0 here

599
00:24:57,919 --> 00:25:09,200
r 1 here

600
00:25:00,720 --> 00:25:10,480
2 3 4 5 6 7 8. so q the final one r8

601
00:25:09,200 --> 00:25:11,520
is q4

602
00:25:10,480 --> 00:25:13,520
okay

603
00:25:11,520 --> 00:25:15,200
and what is the corresponding stack

604
00:25:13,520 --> 00:25:18,080
content string

605
00:25:15,200 --> 00:25:20,640
that will be epsilon right

606
00:25:18,080 --> 00:25:20,640
and then

607
00:25:20,960 --> 00:25:26,159
dollar sign

608
00:25:23,679 --> 00:25:28,960
then zero dollar sign

609
00:25:26,159 --> 00:25:32,799
then zero zero dollar sign

610
00:25:28,960 --> 00:25:35,200
then zero zero zero dollar sign then

611
00:25:32,799 --> 00:25:37,440
zero zero dollar sign

612
00:25:35,200 --> 00:25:39,840
zero dollar sign

613
00:25:37,440 --> 00:25:41,840
dollar sign

614
00:25:39,840 --> 00:25:43,120
and

615
00:25:41,840 --> 00:25:44,480
empty

616
00:25:43,120 --> 00:25:46,080
right

617
00:25:44,480 --> 00:25:49,039
so

618
00:25:46,080 --> 00:25:51,360
s0 as 1

619
00:25:49,039 --> 00:25:57,440
s2

620
00:25:51,360 --> 00:26:01,200
3 4 5 6 7 8 this is 8

621
00:25:57,440 --> 00:26:01,200
and you can easily check that

622
00:26:02,880 --> 00:26:08,320
the

623
00:26:05,039 --> 00:26:13,279
string as the

624
00:26:08,320 --> 00:26:16,320
w1 through w8 and we have a sequence r0

625
00:26:13,279 --> 00:26:17,679
through r8 like this

626
00:26:16,320 --> 00:26:19,200
and we have

627
00:26:17,679 --> 00:26:20,960
stack strings

628
00:26:19,200 --> 00:26:22,000
like this

629
00:26:20,960 --> 00:26:23,279
and

630
00:26:22,000 --> 00:26:25,840
they

631
00:26:23,279 --> 00:26:29,600
satisfy the three conditions first one

632
00:26:25,840 --> 00:26:30,400
is r0 is the start state of the machine

633
00:26:29,600 --> 00:26:32,080
right

634
00:26:30,400 --> 00:26:35,520
and our stack

635
00:26:32,080 --> 00:26:40,080
content string start from epsilon

636
00:26:35,520 --> 00:26:41,840
and final one our r8 is one of the

637
00:26:40,080 --> 00:26:44,960
accept string

638
00:26:41,840 --> 00:26:48,080
sorry except uh states which q1 which

639
00:26:44,960 --> 00:26:48,960
are q1 and q4

640
00:26:48,080 --> 00:26:50,480
so

641
00:26:48,960 --> 00:26:52,480
the first

642
00:26:50,480 --> 00:26:55,039
condition the third condition

643
00:26:52,480 --> 00:26:56,559
for the second condition you will find

644
00:26:55,039 --> 00:26:59,360
for any pair

645
00:26:56,559 --> 00:26:59,360
for example

646
00:26:59,600 --> 00:27:04,400
for example when you check delta

647
00:27:03,200 --> 00:27:08,240
r1

648
00:27:04,400 --> 00:27:08,240
which is what q2

649
00:27:08,559 --> 00:27:10,799
and

650
00:27:11,039 --> 00:27:16,480
w3

651
00:27:12,559 --> 00:27:16,480
oh sorry i shouldn't write that

652
00:27:17,679 --> 00:27:20,679
w3

653
00:27:26,799 --> 00:27:34,559
0 and then you have 0 on the stack

654
00:27:30,799 --> 00:27:38,880
it will go to

655
00:27:34,559 --> 00:27:38,880
q 2 and the push 0

656
00:27:39,039 --> 00:27:41,279
right

657
00:27:41,520 --> 00:27:47,440
not not equal sorry it should be a

658
00:27:43,760 --> 00:27:48,720
belong to because that is a set

659
00:27:47,440 --> 00:27:51,039
okay

660
00:27:48,720 --> 00:27:53,760
so for all i

661
00:27:51,039 --> 00:27:53,760
you will have

662
00:27:54,159 --> 00:27:58,880
you will the second conditions are

663
00:27:56,960 --> 00:28:03,080
satisfied for

664
00:27:58,880 --> 00:28:03,080
r0 through r8

665
00:28:03,360 --> 00:28:08,799
so that's why we said

666
00:28:05,840 --> 00:28:11,840
uh this machine

667
00:28:08,799 --> 00:28:14,159
accepts zero zero zero one one one the

668
00:28:11,840 --> 00:28:14,159
string

669
00:28:15,520 --> 00:28:17,840
okay

670
00:28:24,159 --> 00:28:31,760
so for pda m1 you see that

671
00:28:28,000 --> 00:28:33,200
although it's it isn't a

672
00:28:31,760 --> 00:28:35,200
non-deterministic

673
00:28:33,200 --> 00:28:37,679
machine

674
00:28:35,200 --> 00:28:40,559
in fact at any given moment you have

675
00:28:37,679 --> 00:28:41,760
only one way to go if you can go

676
00:28:40,559 --> 00:28:43,200
so

677
00:28:41,760 --> 00:28:45,760
and

678
00:28:43,200 --> 00:28:48,080
uh it is easy to see how this machine

679
00:28:45,760 --> 00:28:51,600
operates you can see that this machine

680
00:28:48,080 --> 00:28:54,080
push o zero when it's this level push o0

681
00:28:51,600 --> 00:28:55,279
onto stack and match

682
00:28:54,080 --> 00:28:57,039
one

683
00:28:55,279 --> 00:28:59,760
with the input string

684
00:28:57,039 --> 00:29:01,120
right so as long as

685
00:28:59,760 --> 00:29:03,279
uh

686
00:29:01,120 --> 00:29:05,600
the number of zeros and the number of

687
00:29:03,279 --> 00:29:08,320
ones are identical the machine accept

688
00:29:05,600 --> 00:29:11,440
that string basically it runs like that

689
00:29:08,320 --> 00:29:13,360
so let's see another example slightly

690
00:29:11,440 --> 00:29:15,600
more complicated

691
00:29:13,360 --> 00:29:15,600
so

692
00:29:15,679 --> 00:29:20,799
the same part

693
00:29:18,320 --> 00:29:23,520
you can see the same parts here

694
00:29:20,799 --> 00:29:25,200
and here okay

695
00:29:23,520 --> 00:29:27,760
then

696
00:29:25,200 --> 00:29:30,640
no matter you see

697
00:29:27,760 --> 00:29:34,000
zero or one you push

698
00:29:30,640 --> 00:29:36,799
on to the stick okay if you zero zero

699
00:29:34,000 --> 00:29:38,480
you push zero if you see one you push

700
00:29:36,799 --> 00:29:39,360
one okay

701
00:29:38,480 --> 00:29:41,360
and

702
00:29:39,360 --> 00:29:42,960
for any

703
00:29:41,360 --> 00:29:44,000
steps

704
00:29:42,960 --> 00:29:47,679
you can

705
00:29:44,000 --> 00:29:50,640
go from q2 to q3

706
00:29:47,679 --> 00:29:52,000
okay there there will be no change on

707
00:29:50,640 --> 00:29:53,279
the input

708
00:29:52,000 --> 00:29:57,039
and the node

709
00:29:53,279 --> 00:29:59,760
no change no match for stack

710
00:29:57,039 --> 00:30:00,720
and and there's no up and no push no pop

711
00:29:59,760 --> 00:30:03,600
on

712
00:30:00,720 --> 00:30:05,440
to and from the stack

713
00:30:03,600 --> 00:30:07,200
so you can see that

714
00:30:05,440 --> 00:30:11,919
for any steps

715
00:30:07,200 --> 00:30:15,840
you always have one more new branch fork

716
00:30:11,919 --> 00:30:16,720
from the process and it goes to q3

717
00:30:15,840 --> 00:30:18,240
okay

718
00:30:16,720 --> 00:30:21,679
and what

719
00:30:18,240 --> 00:30:23,760
does this machine operate at q3 it

720
00:30:21,679 --> 00:30:27,520
matches

721
00:30:23,760 --> 00:30:29,279
input and the tub of stack input and the

722
00:30:27,520 --> 00:30:31,200
top of the stack

723
00:30:29,279 --> 00:30:33,600
right

724
00:30:31,200 --> 00:30:36,799
so every time it

725
00:30:33,600 --> 00:30:38,640
it will fork a new process and try

726
00:30:36,799 --> 00:30:40,000
to think of

727
00:30:38,640 --> 00:30:42,320
this moment

728
00:30:40,000 --> 00:30:42,320
is a

729
00:30:43,919 --> 00:30:49,279
is the split point which you can try to

730
00:30:46,720 --> 00:30:51,840
match the reverse

731
00:30:49,279 --> 00:30:51,840
of

732
00:30:52,080 --> 00:30:56,960
the first part of the input string

733
00:30:54,240 --> 00:30:58,480
so let's say you have a

734
00:30:56,960 --> 00:31:02,480
a string like

735
00:30:58,480 --> 00:31:02,480
0 1 1 0

736
00:31:02,840 --> 00:31:07,919
then

737
00:31:04,640 --> 00:31:11,360
let's make it longer okay so

738
00:31:07,919 --> 00:31:12,320
one one zero something like this

739
00:31:11,360 --> 00:31:15,039
then

740
00:31:12,320 --> 00:31:17,200
you will push on the stack and try to

741
00:31:15,039 --> 00:31:18,559
match this one and fail

742
00:31:17,200 --> 00:31:21,679
and you

743
00:31:18,559 --> 00:31:25,039
have another process going on try this

744
00:31:21,679 --> 00:31:29,760
possibly this possibility and try this

745
00:31:25,039 --> 00:31:30,640
possibility and try this possibility

746
00:31:29,760 --> 00:31:32,880
okay

747
00:31:30,640 --> 00:31:34,320
it will not accept this string so let's

748
00:31:32,880 --> 00:31:36,640
say this one

749
00:31:34,320 --> 00:31:40,320
so when you try

750
00:31:36,640 --> 00:31:40,320
this split point

751
00:31:40,799 --> 00:31:45,360
okay this is a bad example so we we may

752
00:31:44,080 --> 00:31:47,279
should have

753
00:31:45,360 --> 00:31:48,159
it should have this one

754
00:31:47,279 --> 00:31:49,519
okay

755
00:31:48,159 --> 00:31:51,120
and

756
00:31:49,519 --> 00:31:52,080
one more zero here

757
00:31:51,120 --> 00:31:54,960
so

758
00:31:52,080 --> 00:31:57,360
when you try this possibility

759
00:31:54,960 --> 00:32:00,559
you will see that on the stack it should

760
00:31:57,360 --> 00:32:01,519
be 0 0 1 1 0

761
00:32:00,559 --> 00:32:02,720
and

762
00:32:01,519 --> 00:32:03,760
now b

763
00:32:02,720 --> 00:32:09,039
and

764
00:32:03,760 --> 00:32:14,000
when a process fork at this this moment

765
00:32:09,039 --> 00:32:16,880
0 match 0 1 match 1 one match 1 zero

766
00:32:14,000 --> 00:32:20,159
match zero zero mesh zero and

767
00:32:16,880 --> 00:32:22,000
q four accepted so that is why this

768
00:32:20,159 --> 00:32:25,440
machine m3

769
00:32:22,000 --> 00:32:25,440
recognize the language

770
00:32:27,440 --> 00:32:32,640
this one so first part of the string

771
00:32:29,919 --> 00:32:33,679
first half of the string exactly

772
00:32:32,640 --> 00:32:36,320
uh is

773
00:32:33,679 --> 00:32:38,399
the exact reverse of the second part of

774
00:32:36,320 --> 00:32:40,960
the string

775
00:32:38,399 --> 00:32:42,640
okay and it is not so-called palendra

776
00:32:40,960 --> 00:32:43,679
palindrome

777
00:32:42,640 --> 00:32:45,919
okay

778
00:32:43,679 --> 00:32:49,360
palendron is like uh

779
00:32:45,919 --> 00:32:50,559
w and w are

780
00:32:49,360 --> 00:32:52,640
identical

781
00:32:50,559 --> 00:32:55,840
so they are different

782
00:32:52,640 --> 00:32:57,519
it's this language is a subset of that

783
00:32:55,840 --> 00:32:59,200
because

784
00:32:57,519 --> 00:33:00,480
such

785
00:32:59,200 --> 00:33:03,679
uh

786
00:33:00,480 --> 00:33:05,519
link strings in such language

787
00:33:03,679 --> 00:33:08,320
possible that it's

788
00:33:05,519 --> 00:33:11,919
the length is odd okay

789
00:33:08,320 --> 00:33:14,720
like zero zero one zero zero

790
00:33:11,919 --> 00:33:15,760
it's it's this one but not this one

791
00:33:14,720 --> 00:33:17,440
okay

792
00:33:15,760 --> 00:33:21,600
so anyway

793
00:33:17,440 --> 00:33:23,039
it is uh m3 is another example for the

794
00:33:21,600 --> 00:33:24,960
pda

795
00:33:23,039 --> 00:33:27,919
okay

796
00:33:24,960 --> 00:33:29,120
then we need to have two uh

797
00:33:27,919 --> 00:33:32,000
notes here

798
00:33:29,120 --> 00:33:34,880
first one is that for the uh

799
00:33:32,000 --> 00:33:39,760
for the definition of pdas initially the

800
00:33:34,880 --> 00:33:40,720
stack is empty right

801
00:33:39,760 --> 00:33:42,320
but

802
00:33:40,720 --> 00:33:45,760
it is hard

803
00:33:42,320 --> 00:33:49,600
according to the definition of

804
00:33:45,760 --> 00:33:51,679
pda it is very difficult to detect

805
00:33:49,600 --> 00:33:54,559
if

806
00:33:51,679 --> 00:33:57,440
the stack is empty

807
00:33:54,559 --> 00:34:00,720
we know that it is initially empty but

808
00:33:57,440 --> 00:34:02,399
during the operation of the stack

809
00:34:00,720 --> 00:34:06,559
sorry of the pda

810
00:34:02,399 --> 00:34:07,840
you don't have a mechanism to

811
00:34:06,559 --> 00:34:10,399
detect

812
00:34:07,840 --> 00:34:11,679
the emptiness of the stick

813
00:34:10,399 --> 00:34:14,480
you see

814
00:34:11,679 --> 00:34:16,960
it is this this

815
00:34:14,480 --> 00:34:18,399
this this is not

816
00:34:16,960 --> 00:34:21,280
to detect

817
00:34:18,399 --> 00:34:24,720
to detect if the stack is empty that

818
00:34:21,280 --> 00:34:27,520
means the epsilon here just means we

819
00:34:24,720 --> 00:34:28,960
don't need to refer to the content of

820
00:34:27,520 --> 00:34:29,760
the stick

821
00:34:28,960 --> 00:34:33,359
okay

822
00:34:29,760 --> 00:34:37,760
so there is no way for the programmer

823
00:34:33,359 --> 00:34:40,480
writing transition functions to detect

824
00:34:37,760 --> 00:34:43,520
if currency the stack is empty

825
00:34:40,480 --> 00:34:44,399
according to the definition of pda

826
00:34:43,520 --> 00:34:46,960
so

827
00:34:44,399 --> 00:34:50,879
we usually use a technique that

828
00:34:46,960 --> 00:34:53,599
initially we insert some particular

829
00:34:50,879 --> 00:34:58,079
symbol which is not in the input string

830
00:34:53,599 --> 00:35:00,560
or whatever places we just use a new

831
00:34:58,079 --> 00:35:02,640
artificial symbol

832
00:35:00,560 --> 00:35:04,160
and we put that

833
00:35:02,640 --> 00:35:05,760
into stack

834
00:35:04,160 --> 00:35:06,720
initially

835
00:35:05,760 --> 00:35:09,040
okay

836
00:35:06,720 --> 00:35:13,200
so that's why you will see all the

837
00:35:09,040 --> 00:35:16,720
examples basically in the textbook

838
00:35:13,200 --> 00:35:20,560
we have a spatial symbol dollar sign

839
00:35:16,720 --> 00:35:23,440
here for example and initially we push

840
00:35:20,560 --> 00:35:23,440
that symbol

841
00:35:23,680 --> 00:35:27,680
onto stack

842
00:35:25,760 --> 00:35:29,599
then we know

843
00:35:27,680 --> 00:35:32,640
whenever

844
00:35:29,599 --> 00:35:35,440
we want to check if the stack is empty

845
00:35:32,640 --> 00:35:37,200
we can use dollar sign like this

846
00:35:35,440 --> 00:35:38,720
right like this

847
00:35:37,200 --> 00:35:41,680
so that's one

848
00:35:38,720 --> 00:35:41,680
mechanism here

849
00:35:42,400 --> 00:35:48,560
and the other is that uh

850
00:35:45,200 --> 00:35:51,359
when pushdown automata was proposed in

851
00:35:48,560 --> 00:35:55,040
the literature firstly proposed it is

852
00:35:51,359 --> 00:35:56,960
not it is not defined like we just

853
00:35:55,040 --> 00:35:59,680
introduced

854
00:35:56,960 --> 00:36:03,040
the accept of a string for push down

855
00:35:59,680 --> 00:36:05,839
automata was defined as

856
00:36:03,040 --> 00:36:09,200
when the stack is empty

857
00:36:05,839 --> 00:36:13,200
okay when the stack is empty

858
00:36:09,200 --> 00:36:16,320
but now we want to make all machines

859
00:36:13,200 --> 00:36:20,400
in our course in our course

860
00:36:16,320 --> 00:36:22,560
share the same way to determine if the

861
00:36:20,400 --> 00:36:25,599
machine accepts a string

862
00:36:22,560 --> 00:36:26,640
we use accept states

863
00:36:25,599 --> 00:36:28,560
as

864
00:36:26,640 --> 00:36:30,880
final automata

865
00:36:28,560 --> 00:36:32,720
as in chapter one

866
00:36:30,880 --> 00:36:34,000
so

867
00:36:32,720 --> 00:36:36,000
now

868
00:36:34,000 --> 00:36:37,920
we change to use

869
00:36:36,000 --> 00:36:39,920
accept states

870
00:36:37,920 --> 00:36:41,200
to the to

871
00:36:39,920 --> 00:36:43,680
define

872
00:36:41,200 --> 00:36:46,400
if a machine accept the string

873
00:36:43,680 --> 00:36:49,119
so we can make the definition

874
00:36:46,400 --> 00:36:50,800
for accepting a string very similar

875
00:36:49,119 --> 00:36:54,480
through all the machines

876
00:36:50,800 --> 00:36:56,480
including two machines later

877
00:36:54,480 --> 00:36:59,040
but

878
00:36:56,480 --> 00:37:01,119
in this case the change the change of

879
00:36:59,040 --> 00:37:02,400
definition makes

880
00:37:01,119 --> 00:37:05,839
the

881
00:37:02,400 --> 00:37:07,200
previously proven theorems

882
00:37:05,839 --> 00:37:09,040
no longer

883
00:37:07,200 --> 00:37:12,000
working okay

884
00:37:09,040 --> 00:37:13,599
so in order to solve that

885
00:37:12,000 --> 00:37:17,040
we can make

886
00:37:13,599 --> 00:37:18,880
the you know using accept states and

887
00:37:17,040 --> 00:37:20,960
empty stack

888
00:37:18,880 --> 00:37:23,280
you know somewhat uh

889
00:37:20,960 --> 00:37:24,400
compatible so

890
00:37:23,280 --> 00:37:27,119
you can

891
00:37:24,400 --> 00:37:30,800
also see that

892
00:37:27,119 --> 00:37:34,480
in for the examples in the textbook

893
00:37:30,800 --> 00:37:37,640
when we try to accept

894
00:37:34,480 --> 00:37:37,640
a string

895
00:37:39,440 --> 00:37:42,480
we

896
00:37:40,400 --> 00:37:45,280
pop all the

897
00:37:42,480 --> 00:37:47,680
symbols out of stack of course for these

898
00:37:45,280 --> 00:37:49,680
two examples they are naturally doing

899
00:37:47,680 --> 00:37:54,160
that but

900
00:37:49,680 --> 00:37:54,160
you can always you can always uh

901
00:37:54,400 --> 00:37:59,280
have a pseudo

902
00:37:56,480 --> 00:38:01,440
accept states knowing that now you want

903
00:37:59,280 --> 00:38:04,079
to accept a string and before that you

904
00:38:01,440 --> 00:38:07,599
pop all the symbols because now you have

905
00:38:04,079 --> 00:38:09,119
the capability to detect of detecting

906
00:38:07,599 --> 00:38:11,839
the end of

907
00:38:09,119 --> 00:38:14,000
stack the empty emptiness of the stack

908
00:38:11,839 --> 00:38:16,240
so you can do that

909
00:38:14,000 --> 00:38:16,240
so

910
00:38:17,200 --> 00:38:20,079
that's how we

911
00:38:18,800 --> 00:38:22,480
make

912
00:38:20,079 --> 00:38:25,359
the new definition compatible with the

913
00:38:22,480 --> 00:38:26,400
old definition so that's all

914
00:38:25,359 --> 00:38:27,599
all the

915
00:38:26,400 --> 00:38:30,720
previously

916
00:38:27,599 --> 00:38:33,839
proven theorem still works for the new

917
00:38:30,720 --> 00:38:33,839
definition here

918
00:38:40,480 --> 00:38:44,400
okay so

919
00:38:42,240 --> 00:38:47,520
since we

920
00:38:44,400 --> 00:38:50,800
since we introduced the new machine then

921
00:38:47,520 --> 00:38:53,760
everybody knows that we want to prove

922
00:38:50,800 --> 00:38:56,400
the equivalence between pdas and context

923
00:38:53,760 --> 00:38:56,400
free grammars

924
00:38:58,839 --> 00:39:04,480
right that is

925
00:39:01,440 --> 00:39:04,480
we want to prove that

926
00:39:05,920 --> 00:39:09,760
a language is context-free

927
00:39:09,920 --> 00:39:16,960
if and only if some push-down automata

928
00:39:12,960 --> 00:39:20,119
recognize it okay if and only if that's

929
00:39:16,960 --> 00:39:20,119
a bi-directional

930
00:39:20,720 --> 00:39:24,320
stuff

931
00:39:22,079 --> 00:39:24,320
then

932
00:39:24,800 --> 00:39:31,839
we can say that if we are proof the both

933
00:39:28,560 --> 00:39:33,040
directions we know that for any context

934
00:39:31,839 --> 00:39:35,440
free grammar

935
00:39:33,040 --> 00:39:36,960
the language generated by the context

936
00:39:35,440 --> 00:39:38,960
free grammar

937
00:39:36,960 --> 00:39:40,560
which is a context-free language by our

938
00:39:38,960 --> 00:39:42,960
definition

939
00:39:40,560 --> 00:39:44,960
you can find the pda

940
00:39:42,960 --> 00:39:48,880
and

941
00:39:44,960 --> 00:39:50,640
the language recognize the pda is

942
00:39:48,880 --> 00:39:52,480
the context

943
00:39:50,640 --> 00:39:54,480
language generated by that contextual

944
00:39:52,480 --> 00:39:56,720
grammar also

945
00:39:54,480 --> 00:40:00,160
if you have a pda

946
00:39:56,720 --> 00:40:03,440
the language generated by the pda

947
00:40:00,160 --> 00:40:06,000
can be written as a contextual grammar

948
00:40:03,440 --> 00:40:08,720
and the language generate by that

949
00:40:06,000 --> 00:40:11,920
contextual grammar is the language

950
00:40:08,720 --> 00:40:12,880
recognized by the pda that's we want

951
00:40:11,920 --> 00:40:15,760
what we

952
00:40:12,880 --> 00:40:20,079
that's we want to prove here okay

953
00:40:15,760 --> 00:40:21,440
so firstly one direction which one we do

954
00:40:20,079 --> 00:40:23,680
if a

955
00:40:21,440 --> 00:40:24,560
language is context free

956
00:40:23,680 --> 00:40:27,359
then

957
00:40:24,560 --> 00:40:29,040
we can find some push down automata

958
00:40:27,359 --> 00:40:30,640
recognize it

959
00:40:29,040 --> 00:40:34,960
okay

960
00:40:30,640 --> 00:40:36,800
and let me note it first if we proved if

961
00:40:34,960 --> 00:40:39,520
we prove this

962
00:40:36,800 --> 00:40:42,160
theorem we know that we will know that

963
00:40:39,520 --> 00:40:43,920
the computational capability of context

964
00:40:42,160 --> 00:40:46,400
with grammar

965
00:40:43,920 --> 00:40:46,400
will be

966
00:40:47,440 --> 00:40:53,839
equal to our that's

967
00:40:50,839 --> 00:40:55,520
then push down automata

968
00:40:53,839 --> 00:40:58,079
that means

969
00:40:55,520 --> 00:40:58,960
the language

970
00:40:58,079 --> 00:41:03,680
of

971
00:40:58,960 --> 00:41:03,680
context free grammar for all g

972
00:41:04,240 --> 00:41:09,599
will be equal to our subset of

973
00:41:08,160 --> 00:41:10,640
all possible

974
00:41:09,599 --> 00:41:12,000
p

975
00:41:10,640 --> 00:41:16,240
something like that

976
00:41:12,000 --> 00:41:16,240
okay so that's one direction and

977
00:41:16,480 --> 00:41:18,839
we will prove

978
00:41:17,920 --> 00:41:21,839
these

979
00:41:18,839 --> 00:41:23,440
later so

980
00:41:21,839 --> 00:41:27,440
so

981
00:41:23,440 --> 00:41:28,800
clearance 220 is proved when they both

982
00:41:27,440 --> 00:41:31,680
are proofed

983
00:41:28,800 --> 00:41:34,560
so that's what what we are going to do

984
00:41:31,680 --> 00:41:37,200
okay so first first thing first

985
00:41:34,560 --> 00:41:40,880
we want to prove that given a contextual

986
00:41:37,200 --> 00:41:43,440
grammar you can find a pda

987
00:41:40,880 --> 00:41:45,680
okay so

988
00:41:43,440 --> 00:41:45,680
uh

989
00:41:46,079 --> 00:41:50,800
it is pretty straightforward for this

990
00:41:48,079 --> 00:41:55,440
direction because we just need to con

991
00:41:50,800 --> 00:41:57,839
convert the given cfg into a pda

992
00:41:55,440 --> 00:42:00,000
and you probably think uh how is that

993
00:41:57,839 --> 00:42:02,160
possible but it's quite

994
00:42:00,000 --> 00:42:03,359
simple if you understand what we are

995
00:42:02,160 --> 00:42:04,960
going to do

996
00:42:03,359 --> 00:42:06,880
we are going to

997
00:42:04,960 --> 00:42:08,720
use pda's

998
00:42:06,880 --> 00:42:10,800
capability of non-deterministic

999
00:42:08,720 --> 00:42:13,200
computation

1000
00:42:10,800 --> 00:42:14,960
and try

1001
00:42:13,200 --> 00:42:17,119
all possible

1002
00:42:14,960 --> 00:42:18,480
derivations

1003
00:42:17,119 --> 00:42:21,040
okay try

1004
00:42:18,480 --> 00:42:23,839
try all possible derivations

1005
00:42:21,040 --> 00:42:26,160
whenever you get some

1006
00:42:23,839 --> 00:42:28,319
terminal string you match

1007
00:42:26,160 --> 00:42:31,440
with the input string

1008
00:42:28,319 --> 00:42:35,040
and when you try all possible duration

1009
00:42:31,440 --> 00:42:36,480
then if there is there exists

1010
00:42:35,040 --> 00:42:38,720
a derivation

1011
00:42:36,480 --> 00:42:41,839
from start variable

1012
00:42:38,720 --> 00:42:43,200
to that terminal string as the input

1013
00:42:41,839 --> 00:42:46,640
string

1014
00:42:43,200 --> 00:42:48,800
then that string

1015
00:42:46,640 --> 00:42:50,079
is recognized by the pda

1016
00:42:48,800 --> 00:42:51,280
otherwise

1017
00:42:50,079 --> 00:42:52,400
it's not

1018
00:42:51,280 --> 00:42:55,440
okay

1019
00:42:52,400 --> 00:42:58,319
that's what that's the idea we want to

1020
00:42:55,440 --> 00:43:01,680
use a pda to recognize a language

1021
00:42:58,319 --> 00:43:03,599
generated by a contextual grammar

1022
00:43:01,680 --> 00:43:07,599
okay

1023
00:43:03,599 --> 00:43:09,280
so idea is like this

1024
00:43:07,599 --> 00:43:11,839
you see

1025
00:43:09,280 --> 00:43:13,920
we want to

1026
00:43:11,839 --> 00:43:18,000
the derivation actually

1027
00:43:13,920 --> 00:43:19,839
left most derivation we always process

1028
00:43:18,000 --> 00:43:21,520
always try to change

1029
00:43:19,839 --> 00:43:24,160
the first

1030
00:43:21,520 --> 00:43:25,359
from left to right the first variable

1031
00:43:24,160 --> 00:43:26,960
okay

1032
00:43:25,359 --> 00:43:29,680
so

1033
00:43:26,960 --> 00:43:32,240
we want to expand

1034
00:43:29,680 --> 00:43:35,520
the derivation onto the stack

1035
00:43:32,240 --> 00:43:38,960
on the stack and the match

1036
00:43:35,520 --> 00:43:41,520
input string here

1037
00:43:38,960 --> 00:43:43,359
so we push

1038
00:43:41,520 --> 00:43:45,200
input string

1039
00:43:43,359 --> 00:43:46,720
oh sorry uh

1040
00:43:45,200 --> 00:43:50,400
input symbol

1041
00:43:46,720 --> 00:43:50,400
to the stack to the stack

1042
00:43:52,839 --> 00:43:57,119
uh and match

1043
00:43:55,520 --> 00:44:01,280
it with

1044
00:43:57,119 --> 00:44:01,280
input string and then when we see

1045
00:44:02,720 --> 00:44:09,240
uh sorry we will push variable onto we

1046
00:44:05,839 --> 00:44:09,240
push the

1047
00:44:10,800 --> 00:44:17,839
expansion of the rule of a rule which of

1048
00:44:15,040 --> 00:44:22,599
which the head is that variable and to

1049
00:44:17,839 --> 00:44:22,599
the string and the match that generated

1050
00:44:23,760 --> 00:44:27,200
terminal strings with the input string

1051
00:44:26,319 --> 00:44:29,760
okay

1052
00:44:27,200 --> 00:44:32,160
so all the different uh the

1053
00:44:29,760 --> 00:44:34,720
leftmost derivation process

1054
00:44:32,160 --> 00:44:38,640
are using

1055
00:44:34,720 --> 00:44:40,240
stack and you can try all possible then

1056
00:44:38,640 --> 00:44:42,880
so

1057
00:44:40,240 --> 00:44:42,880
whenever

1058
00:44:43,359 --> 00:44:49,760
the body has

1059
00:44:46,480 --> 00:44:50,480
remember that for example a becomes 0 1

1060
00:44:49,760 --> 00:44:51,680
a

1061
00:44:50,480 --> 00:44:54,400
1

1062
00:44:51,680 --> 00:44:57,920
a 0 something like that so

1063
00:44:54,400 --> 00:45:01,440
when you see a you push in this example

1064
00:44:57,920 --> 00:45:05,440
you push 0 a 1 a

1065
00:45:01,440 --> 00:45:07,200
1 0 then you match this one and this one

1066
00:45:05,440 --> 00:45:11,359
that's how it works

1067
00:45:07,200 --> 00:45:14,640
then you have this one then pop a

1068
00:45:11,359 --> 00:45:17,119
and push what a can become

1069
00:45:14,640 --> 00:45:18,960
and then doing the same loop all over

1070
00:45:17,119 --> 00:45:22,160
again okay

1071
00:45:18,960 --> 00:45:26,160
so that's introduced a shorthand it's

1072
00:45:22,160 --> 00:45:32,280
not a modification on the definition of

1073
00:45:26,160 --> 00:45:32,280
pda it's it is just a shorthand or for

1074
00:45:32,880 --> 00:45:37,520
easier to

1075
00:45:35,200 --> 00:45:39,920
describe what we want to do

1076
00:45:37,520 --> 00:45:42,160
so we say that

1077
00:45:39,920 --> 00:45:43,839
we allow

1078
00:45:42,160 --> 00:45:47,280
transition like this

1079
00:45:43,839 --> 00:45:48,400
or describe with this

1080
00:45:47,280 --> 00:45:50,800
simply

1081
00:45:48,400 --> 00:45:50,800
simply

1082
00:45:50,880 --> 00:45:55,280
because we can

1083
00:45:52,640 --> 00:45:55,280
expand

1084
00:45:55,920 --> 00:46:01,040
this one into

1085
00:45:58,160 --> 00:46:05,200
we match a for the input

1086
00:46:01,040 --> 00:46:09,200
match s on the stack and firstly push z

1087
00:46:05,200 --> 00:46:10,079
then push y then push x

1088
00:46:09,200 --> 00:46:11,680
okay

1089
00:46:10,079 --> 00:46:13,200
so after

1090
00:46:11,680 --> 00:46:17,040
this this

1091
00:46:13,200 --> 00:46:19,040
this uh in fact three transitions

1092
00:46:17,040 --> 00:46:20,079
on the stack we see

1093
00:46:19,040 --> 00:46:21,040
the e

1094
00:46:20,079 --> 00:46:21,920
y

1095
00:46:21,040 --> 00:46:24,319
x

1096
00:46:21,920 --> 00:46:28,079
on the stack something like that

1097
00:46:24,319 --> 00:46:31,440
okay and you go from q to r

1098
00:46:28,079 --> 00:46:34,480
and you consume a for the input and

1099
00:46:31,440 --> 00:46:37,359
original s on the stack is popped

1100
00:46:34,480 --> 00:46:41,599
okay so that's only a shorthand a syntax

1101
00:46:37,359 --> 00:46:44,880
synthetic sugar not a change on the

1102
00:46:41,599 --> 00:46:46,400
change of the definition of pdas

1103
00:46:44,880 --> 00:46:51,119
then

1104
00:46:46,400 --> 00:46:52,720
we for a given for given

1105
00:46:51,119 --> 00:46:55,359
grammar

1106
00:46:52,720 --> 00:46:59,119
for given grammar

1107
00:46:55,359 --> 00:47:02,560
we have two kinds of rule firstly

1108
00:46:59,119 --> 00:47:04,000
for all symbols for all terminals

1109
00:47:02,560 --> 00:47:05,280
in

1110
00:47:04,000 --> 00:47:07,839
sigma

1111
00:47:05,280 --> 00:47:08,960
we have rules like this

1112
00:47:07,839 --> 00:47:12,880
okay

1113
00:47:08,960 --> 00:47:15,599
that that is that will be used to match

1114
00:47:12,880 --> 00:47:19,280
the symbol on the

1115
00:47:15,599 --> 00:47:21,440
stack and the symbol in the input string

1116
00:47:19,280 --> 00:47:23,760
and for all rules

1117
00:47:21,440 --> 00:47:27,599
for all rules

1118
00:47:23,760 --> 00:47:28,880
and for another oh sorry for variable a

1119
00:47:27,599 --> 00:47:29,920
we add

1120
00:47:28,880 --> 00:47:33,119
all

1121
00:47:29,920 --> 00:47:35,760
rules regarding the variable a

1122
00:47:33,119 --> 00:47:38,000
as the transition for our

1123
00:47:35,760 --> 00:47:38,960
pdas

1124
00:47:38,000 --> 00:47:42,319
then

1125
00:47:38,960 --> 00:47:42,319
for any possible

1126
00:47:42,640 --> 00:47:45,200
sorry this one

1127
00:47:43,839 --> 00:47:46,240
for any

1128
00:47:45,200 --> 00:47:48,559
given

1129
00:47:46,240 --> 00:47:50,839
context-free grammar

1130
00:47:48,559 --> 00:47:53,280
we have a pda look

1131
00:47:50,839 --> 00:47:55,040
look looks like

1132
00:47:53,280 --> 00:47:57,119
this one

1133
00:47:55,040 --> 00:47:58,559
start state

1134
00:47:57,119 --> 00:48:00,160
then

1135
00:47:58,559 --> 00:48:02,160
push

1136
00:48:00,160 --> 00:48:04,800
we don't we do nothing to the terminal

1137
00:48:02,160 --> 00:48:07,040
string and input string and we don't

1138
00:48:04,800 --> 00:48:09,680
need to refer to the content of the

1139
00:48:07,040 --> 00:48:12,720
stake we push

1140
00:48:09,680 --> 00:48:16,640
the other side as on to the stack which

1141
00:48:12,720 --> 00:48:17,839
actually two steps right then

1142
00:48:16,640 --> 00:48:21,520
when

1143
00:48:17,839 --> 00:48:23,359
the stack is m when we reach the end of

1144
00:48:21,520 --> 00:48:25,599
the stack it's not empty yet there is a

1145
00:48:23,359 --> 00:48:28,480
dollar sign on it but

1146
00:48:25,599 --> 00:48:31,760
when it reaches the

1147
00:48:28,480 --> 00:48:34,400
empty stack we don't need to check the

1148
00:48:31,760 --> 00:48:35,839
input string then we accept

1149
00:48:34,400 --> 00:48:39,200
that string

1150
00:48:35,839 --> 00:48:41,920
but remember that when you reach

1151
00:48:39,200 --> 00:48:44,800
accept state q accept

1152
00:48:41,920 --> 00:48:47,119
the input string must be empty to accept

1153
00:48:44,800 --> 00:48:49,760
the original input string okay

1154
00:48:47,119 --> 00:48:52,319
if there is any string left as input

1155
00:48:49,760 --> 00:48:54,240
string the machine doesn't accept it

1156
00:48:52,319 --> 00:48:56,640
okay so that's the

1157
00:48:54,240 --> 00:48:57,760
uh that that's uh that's that's

1158
00:48:56,640 --> 00:49:00,240
important

1159
00:48:57,760 --> 00:49:03,359
and we have transition back

1160
00:49:00,240 --> 00:49:05,200
to q loop for rule

1161
00:49:03,359 --> 00:49:07,200
and for turbido

1162
00:49:05,200 --> 00:49:09,599
okay

1163
00:49:07,200 --> 00:49:11,119
so that's the example for the

1164
00:49:09,599 --> 00:49:12,880
construction

1165
00:49:11,119 --> 00:49:14,839
let's say we have a context three

1166
00:49:12,880 --> 00:49:17,359
grammar

1167
00:49:14,839 --> 00:49:20,319
st a b

1168
00:49:17,359 --> 00:49:23,839
and this s is the star variable and we

1169
00:49:20,319 --> 00:49:25,599
have four rules s becomes s may become a

1170
00:49:23,839 --> 00:49:28,839
t b or b

1171
00:49:25,599 --> 00:49:32,400
t may become t a or

1172
00:49:28,839 --> 00:49:32,400
epsilon okay

1173
00:49:34,480 --> 00:49:38,960
and according to the construction we can

1174
00:49:37,440 --> 00:49:40,480
have

1175
00:49:38,960 --> 00:49:42,640
a

1176
00:49:40,480 --> 00:49:44,480
pda like this

1177
00:49:42,640 --> 00:49:46,000
there is a

1178
00:49:44,480 --> 00:49:48,480
middle state

1179
00:49:46,000 --> 00:49:51,359
anomalous state here so

1180
00:49:48,480 --> 00:49:53,839
we push down the sign push s

1181
00:49:51,359 --> 00:49:56,800
and then we pop down the sign

1182
00:49:53,839 --> 00:49:59,359
after q loop and for q loop there are

1183
00:49:56,800 --> 00:50:03,359
since we have four rules right so the

1184
00:49:59,359 --> 00:50:04,720
first rule s may become

1185
00:50:03,359 --> 00:50:06,160
a t

1186
00:50:04,720 --> 00:50:08,079
b

1187
00:50:06,160 --> 00:50:10,319
then this one is t

1188
00:50:08,079 --> 00:50:11,440
may become

1189
00:50:10,319 --> 00:50:13,760
t

1190
00:50:11,440 --> 00:50:15,040
a

1191
00:50:13,760 --> 00:50:17,280
right

1192
00:50:15,040 --> 00:50:17,280
and

1193
00:50:17,359 --> 00:50:22,880
s become b as may become f t may become

1194
00:50:20,720 --> 00:50:24,800
epsilon and

1195
00:50:22,880 --> 00:50:26,960
the last two rules

1196
00:50:24,800 --> 00:50:30,079
for all symbol

1197
00:50:26,960 --> 00:50:31,920
in sigma we have a

1198
00:50:30,079 --> 00:50:32,960
a epsilon

1199
00:50:31,920 --> 00:50:35,359
okay so

1200
00:50:32,960 --> 00:50:38,800
the last two is like this

1201
00:50:35,359 --> 00:50:38,800
then we have constructed

1202
00:50:39,440 --> 00:50:44,160
uh pda for the given grammar

1203
00:50:43,200 --> 00:50:47,119
okay

1204
00:50:44,160 --> 00:50:47,119
so let's see

1205
00:50:47,280 --> 00:50:49,839
a derivation

1206
00:50:48,960 --> 00:50:52,640
like

1207
00:50:49,839 --> 00:50:55,839
if you have

1208
00:50:52,640 --> 00:50:57,599
one star variable and it is possible

1209
00:50:55,839 --> 00:51:00,559
that

1210
00:50:57,599 --> 00:51:02,800
you become a t b

1211
00:51:00,559 --> 00:51:02,800
right

1212
00:51:03,680 --> 00:51:08,880
and for t you can become

1213
00:51:06,800 --> 00:51:10,319
t a

1214
00:51:08,880 --> 00:51:12,960
right

1215
00:51:10,319 --> 00:51:15,599
and then you can do that again but we

1216
00:51:12,960 --> 00:51:19,040
don't want to do that okay so t

1217
00:51:15,599 --> 00:51:20,640
become epsom then you have a a b

1218
00:51:19,040 --> 00:51:22,800
right so a b

1219
00:51:20,640 --> 00:51:24,640
is one of the string

1220
00:51:22,800 --> 00:51:25,920
in the language generated by that

1221
00:51:24,640 --> 00:51:29,040
grammar

1222
00:51:25,920 --> 00:51:31,440
and let's see if you put aab

1223
00:51:29,040 --> 00:51:33,839
into this

1224
00:51:31,440 --> 00:51:36,160
pda what will happen

1225
00:51:33,839 --> 00:51:37,599
so for pda

1226
00:51:36,160 --> 00:51:38,480
it will

1227
00:51:37,599 --> 00:51:40,559
push

1228
00:51:38,480 --> 00:51:44,160
firstly

1229
00:51:40,559 --> 00:51:44,160
uh push dollar sign

1230
00:51:44,319 --> 00:51:48,559
on the stack right and the start from

1231
00:51:46,319 --> 00:51:51,599
cues q start

1232
00:51:48,559 --> 00:51:54,079
then we'll push s

1233
00:51:51,599 --> 00:51:55,280
on the stack right

1234
00:51:54,079 --> 00:51:57,359
then

1235
00:51:55,280 --> 00:51:59,040
and reach q loop

1236
00:51:57,359 --> 00:51:59,920
then since

1237
00:51:59,040 --> 00:52:03,119
the

1238
00:51:59,920 --> 00:52:05,440
table of stack is s you have only

1239
00:52:03,119 --> 00:52:08,480
this path

1240
00:52:05,440 --> 00:52:09,760
and this path possible

1241
00:52:08,480 --> 00:52:13,359
but for the

1242
00:52:09,760 --> 00:52:14,720
s may become b it doesn't work

1243
00:52:13,359 --> 00:52:17,440
right

1244
00:52:14,720 --> 00:52:20,559
let's try it okay

1245
00:52:17,440 --> 00:52:22,000
it can you you don't need to consume

1246
00:52:20,559 --> 00:52:23,040
a

1247
00:52:22,000 --> 00:52:24,559
right

1248
00:52:23,040 --> 00:52:25,520
and

1249
00:52:24,559 --> 00:52:28,880
you

1250
00:52:25,520 --> 00:52:31,760
pop s from the stick let's assume that

1251
00:52:28,880 --> 00:52:35,599
we do that you pop s from the stack and

1252
00:52:31,760 --> 00:52:36,640
push b in onto the stack you will get

1253
00:52:35,599 --> 00:52:37,920
s

1254
00:52:36,640 --> 00:52:41,040
b

1255
00:52:37,920 --> 00:52:42,800
if you go this way let's say if you go

1256
00:52:41,040 --> 00:52:45,119
this way

1257
00:52:42,800 --> 00:52:48,000
and after you go this way

1258
00:52:45,119 --> 00:52:50,240
the language the string got reject got

1259
00:52:48,000 --> 00:52:53,520
rejected you will never have no chance

1260
00:52:50,240 --> 00:52:54,960
to accept the string why because

1261
00:52:53,520 --> 00:52:57,119
you don't have

1262
00:52:54,960 --> 00:53:00,240
a transition for a

1263
00:52:57,119 --> 00:53:02,880
for the input symbol and the b for the

1264
00:53:00,240 --> 00:53:04,160
stake top right top of the stack

1265
00:53:02,880 --> 00:53:05,359
so

1266
00:53:04,160 --> 00:53:08,880
there is a

1267
00:53:05,359 --> 00:53:12,559
process forked for this way but it will

1268
00:53:08,880 --> 00:53:15,920
end with not accepting the string right

1269
00:53:12,559 --> 00:53:19,040
you you you still need to go this way

1270
00:53:15,920 --> 00:53:21,440
one of the process will go this way okay

1271
00:53:19,040 --> 00:53:22,960
and the other process goes to

1272
00:53:21,440 --> 00:53:24,640
goes this way

1273
00:53:22,960 --> 00:53:26,839
so pop s

1274
00:53:24,640 --> 00:53:30,240
and the push what

1275
00:53:26,839 --> 00:53:31,680
push b

1276
00:53:30,240 --> 00:53:34,800
t

1277
00:53:31,680 --> 00:53:36,079
a and go back to the loop right

1278
00:53:34,800 --> 00:53:39,680
then since

1279
00:53:36,079 --> 00:53:41,440
input string a stack type a you go

1280
00:53:39,680 --> 00:53:43,520
these

1281
00:53:41,440 --> 00:53:45,040
transition once

1282
00:53:43,520 --> 00:53:47,359
back to q loop

1283
00:53:45,040 --> 00:53:49,599
and you will have

1284
00:53:47,359 --> 00:53:52,800
t b dot sign on the stack

1285
00:53:49,599 --> 00:53:55,440
then for t there are two possibilities

1286
00:53:52,800 --> 00:53:57,680
one is epsilon right

1287
00:53:55,440 --> 00:53:58,640
and the other is

1288
00:53:57,680 --> 00:54:03,280
ta

1289
00:53:58,640 --> 00:54:06,160
but if you go epson first you will get

1290
00:54:03,280 --> 00:54:08,400
data sign b epsilon right then go back

1291
00:54:06,160 --> 00:54:11,040
to q loop but

1292
00:54:08,400 --> 00:54:12,800
same thing you cannot match is one and

1293
00:54:11,040 --> 00:54:14,720
that's a that's n

1294
00:54:12,800 --> 00:54:18,240
that's a dead end

1295
00:54:14,720 --> 00:54:18,240
so the other way

1296
00:54:19,119 --> 00:54:23,760
you go

1297
00:54:20,880 --> 00:54:25,760
t become ta now

1298
00:54:23,760 --> 00:54:27,040
the you will

1299
00:54:25,760 --> 00:54:28,559
push

1300
00:54:27,040 --> 00:54:29,839
a

1301
00:54:28,559 --> 00:54:31,440
t

1302
00:54:29,839 --> 00:54:32,480
to the stack

1303
00:54:31,440 --> 00:54:34,720
right

1304
00:54:32,480 --> 00:54:39,680
then the same thing happen again this

1305
00:54:34,720 --> 00:54:42,400
time let's say we go t may become f zone

1306
00:54:39,680 --> 00:54:43,359
so we will have pop t

1307
00:54:42,400 --> 00:54:46,799
and

1308
00:54:43,359 --> 00:54:47,680
push epsilon onto the stack

1309
00:54:46,799 --> 00:54:48,640
right

1310
00:54:47,680 --> 00:54:51,119
then

1311
00:54:48,640 --> 00:54:52,480
comes soon a a

1312
00:54:51,119 --> 00:54:54,079
and comes to

1313
00:54:52,480 --> 00:54:55,359
bb

1314
00:54:54,079 --> 00:54:58,960
and

1315
00:54:55,359 --> 00:55:02,559
the other side shows up then we go

1316
00:54:58,960 --> 00:55:04,480
to q accept and we have no

1317
00:55:02,559 --> 00:55:05,599
input string anymore

1318
00:55:04,480 --> 00:55:08,480
so

1319
00:55:05,599 --> 00:55:12,240
this pda accepts

1320
00:55:08,480 --> 00:55:15,520
a a b as its input string and you can

1321
00:55:12,240 --> 00:55:18,400
see that why it accepts a b

1322
00:55:15,520 --> 00:55:21,200
because all possible

1323
00:55:18,400 --> 00:55:23,200
left most duration from stop starts

1324
00:55:21,200 --> 00:55:24,960
variable

1325
00:55:23,200 --> 00:55:28,160
have been

1326
00:55:24,960 --> 00:55:29,839
well simulated or been processed

1327
00:55:28,160 --> 00:55:31,839
on the stacks

1328
00:55:29,839 --> 00:55:34,319
within

1329
00:55:31,839 --> 00:55:37,440
our veer all

1330
00:55:34,319 --> 00:55:39,119
the possible

1331
00:55:37,440 --> 00:55:42,079
forked processes

1332
00:55:39,119 --> 00:55:45,839
okay many of them may uh

1333
00:55:42,079 --> 00:55:49,280
stop at an a dead end but

1334
00:55:45,839 --> 00:55:51,839
as long as one of

1335
00:55:49,280 --> 00:55:53,599
the computational paths goes through

1336
00:55:51,839 --> 00:55:55,920
stop at the

1337
00:55:53,599 --> 00:55:57,760
accept states then the machine accept

1338
00:55:55,920 --> 00:55:59,119
the

1339
00:55:57,760 --> 00:56:02,240
string

1340
00:55:59,119 --> 00:56:04,880
and as you can see that since the

1341
00:56:02,240 --> 00:56:07,520
operation of the machine

1342
00:56:04,880 --> 00:56:08,319
is based on the left most derivation

1343
00:56:07,520 --> 00:56:09,680
so

1344
00:56:08,319 --> 00:56:12,640
all the

1345
00:56:09,680 --> 00:56:13,839
strings generated by the given grammar

1346
00:56:12,640 --> 00:56:17,040
will be

1347
00:56:13,839 --> 00:56:18,960
accepted by the machine here and the

1348
00:56:17,040 --> 00:56:20,480
machine will not accept any other

1349
00:56:18,960 --> 00:56:22,640
strings because

1350
00:56:20,480 --> 00:56:24,480
as long as the leftmost derivation

1351
00:56:22,640 --> 00:56:27,440
cannot generate that string the machine

1352
00:56:24,480 --> 00:56:29,280
will not accept

1353
00:56:27,440 --> 00:56:31,359
so we can see that

1354
00:56:29,280 --> 00:56:34,640
for any given context free grammar we

1355
00:56:31,359 --> 00:56:36,960
can write uh this we can convert it into

1356
00:56:34,640 --> 00:56:39,200
a pda like this

1357
00:56:36,960 --> 00:56:39,200
so

1358
00:56:39,760 --> 00:56:43,160
we know that

1359
00:56:44,079 --> 00:56:48,960
if a language is a context tree it can

1360
00:56:46,799 --> 00:56:51,040
be described can be generated by a

1361
00:56:48,960 --> 00:56:54,000
continuous grammar and then we can

1362
00:56:51,040 --> 00:56:58,000
convert that context to grammar into a

1363
00:56:54,000 --> 00:57:00,160
pda like we just described and that pda

1364
00:56:58,000 --> 00:57:03,400
recognized

1365
00:57:00,160 --> 00:57:03,400
the language

